

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/tom.png">
  <link rel="icon" href="/img/tom.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tom">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux 设备树什么是设备树？设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图 43.1.1所示：   在图 43.1.1 中，树的主干就是系">
<meta property="og:type" content="article">
<meta property="og:title" content="device tree">
<meta property="og:url" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/index.html">
<meta property="og:site_name" content="TomWithKernel&#39;s Blog">
<meta property="og:description" content="Linux 设备树什么是设备树？设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图 43.1.1所示：   在图 43.1.1 中，树的主干就是系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/devicetree.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi1.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi2.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/error.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/start_kernel.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/a.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/b.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/c.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/d.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/e.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/f.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/g.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/h.png">
<meta property="og:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/i.png">
<meta property="article:published_time" content="2024-11-21T03:34:18.000Z">
<meta property="article:modified_time" content="2025-05-13T03:22:32.886Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="device tree">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tomwithkernel.github.io/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/devicetree.png">
  
  
  
  <title>device tree - TomWithKernel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">
<link rel="stylesheet" href="/css/selection.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tomwithkernel.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","app_key":"jxVWH2hG2DLvf0KjiGZ93acw","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TomWithKernel&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="device tree"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-21 11:34" pubdate>
          2024年11月21日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          481 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">device tree</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Linux-设备树"><a href="#Linux-设备树" class="headerlink" title="Linux 设备树"></a>Linux 设备树</h2><h3 id="什么是设备树？"><a href="#什么是设备树？" class="headerlink" title="什么是设备树？"></a>什么是设备树？</h3><p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图 43.1.1所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/devicetree.png" srcset="/img/loading.gif" lazyload class title="devicetree">

<p>在图 43.1.1 中，树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。DTS 文件的主要功能就是按照图 43.1.1所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。</p>
<p>在 3.x 版本(具体哪个版本笔者也无从考证)以前的 Linux 内核中 ARM 架构并没有采用设备树。在没有设备树的时候 Linux 是如何描述 ARM 架构中的板级信息呢？在 Linux 内核源码中大量的 arch&#x2F;arm&#x2F;mach-xxx 和 arch&#x2F;arm&#x2F;plat-xxx 文件夹，这些文件夹里面的文件就是对应平台下的板级信息。比如在 arch&#x2F;arm&#x2F;mach-smdk2440.c 中有如下内容(有缩减)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_display</span> <span class="hljs-title">smdk2440_lcd_cfg</span> __<span class="hljs-title">initdata</span> =</span> &#123;<br><br>    .lcdcon5 = S3C2410_LCDCON5_FRM565 |<br>    S3C2410_LCDCON5_INVVLINE |<br>    S3C2410_LCDCON5_INVVFRAME |<br>    S3C2410_LCDCON5_PWREN |<br>    S3C2410_LCDCON5_HWSWP,<br>    ......<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_mach_info</span> <span class="hljs-title">smdk2440_fb_info</span> __<span class="hljs-title">initdata</span> =</span> &#123;<br>    .displays = &amp;smdk2440_lcd_cfg,<br>    .num_displays = <span class="hljs-number">1</span>,<br>    .default_display = <span class="hljs-number">0</span>,<br>    ......<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<br>    &amp;s3c_device_ohci,<br>    &amp;s3c_device_lcd,<br>    &amp;s3c_device_wdt,<br>    &amp;s3c_device_i2c0,<br>    &amp;s3c_device_iis,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述代码中的结构体变量 smdk2440_fb_info 就是描述 SMDK2440 这个开发板上的 LCD 信息的，结构体指针数组 smdk2440_devices 描述的 SMDK2440 这个开发板上的所有平台相关信息。这个仅仅是使用 2440 这个芯片的 SMDK2440 开发板下的 LCD 信息，SMDK2440 开发板还有很多的其他外设硬件和平台硬件信息。使用 2440 这个芯片的板子有很多，每个板子都有描述相应板级信息的文件，这仅仅只是一个 2440。随着智能手机的发展，每年新出的 ARM 架构芯片少说都在数十、数百款，Linux 内核下板级信息文件将会成指数级增长！这些板级信息文件都是.c 或.h 文件，都会被硬编码进 Linux 内核中，导致 Linux 内核“虚胖”。就好比你喜欢吃自助餐，然后花了 100 多到一家宣传看着很不错的自助餐厅，结果你想吃的牛排、海鲜、烤肉基本没多少，全都是一些凉菜、炒面、西瓜、饮料等小吃，相信你此时肯定会脱口而出一句“F<em>k!”、“骗子！”。同样的，当 Linux 之父 linus 看到 ARM 社区向 Linux 内核添加了大量“无用”、冗余的板级信息文件，不禁的发出了一句“This whole ARM thing is a f</em>cking pain in the ass”。从此以后 ARM 社区就引入了 PowerPC 等架构已经采用的设备树(Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件，类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)，.dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。<br>这个就是设备树的由来，简而言之就是，Linux 内核中 ARM 架构下有太多的冗余的垃圾板级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树。</p>
<h3 id="DTS、DTB、DTC"><a href="#DTS、DTB、DTC" class="headerlink" title="DTS、DTB、DTC"></a>DTS、DTB、DTC</h3><p>DTS 是设备树源码文件，DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！DTC 工具源码在 Linux 内核的 scripts&#x2F;dtc 目录下，scripts&#x2F;dtc&#x2F;Makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">hostprogs-y := dtc<br>always := $(hostprogs-y)<br><br>dtc-objs := dtc.o flattree.o fstree.o data.o livetree.o treesource.o \<br>srcpos.o checks.o util.o<br>dtc-objs += dtc-lexer.lex.o dtc-parser.tab.o<br>......<br></code></pre></td></tr></table></figure>

<p>可以看出，DTC 工具依赖于 dtc.c、flattree.c、fstree.c 等文件，最终编译并链接出 DTC 这个主机文件。如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行<code>make all</code>或者<code>make dtbs</code><br><code>make all</code>命令是编译 Linux 源码中的所有东西，包括 zImage，.ko 驱动模块以及设备树，如果只是编译设备树的话建议使用<code>make dtbs</code>命令。</p>
<p>基于 ARM 架构的 SOC 有很多种，一种 SOC 又可以制作出很多款板子，每个板子都有一个对应的 DTS 文件，那么如何确定编译哪一个 DTS 文件呢？我们就以 I.MX6ULL 这款芯片对应的板子为例来看一下，打开 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，有如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6UL)</span> += \<br>imx6ul-14x14-ddr3-arm2.dtb \<br>imx6ul-14x14-ddr3-arm2-emmc.dtb \<br>......<br>dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6ULL)</span> += \<br>imx6ull-14x14-ddr3-arm2.dtb \<br>imx6ull-14x14-ddr3-arm2-adc.dtb \<br>imx6ull-14x14-ddr3-arm2-cs42888.dtb \<br>imx6ull-14x14-ddr3-arm2-ecspi.dtb \<br>imx6ull-14x14-ddr3-arm2-emmc.dtb \<br>imx6ull-14x14-ddr3-arm2-epdc.dtb \<br>imx6ull-14x14-ddr3-arm2-flexcan2.dtb \<br>imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb \<br>imx6ull-14x14-ddr3-arm2-lcdif.dtb \<br>imx6ull-14x14-ddr3-arm2-ldo.dtb \<br>imx6ull-14x14-ddr3-arm2-qspi.dtb \<br>imx6ull-14x14-ddr3-arm2-qspi-all.dtb \<br>imx6ull-14x14-ddr3-arm2-tsc.dtb \<br>imx6ull-14x14-ddr3-arm2-uart2.dtb \<br>imx6ull-14x14-ddr3-arm2-usb.dtb \<br>imx6ull-14x14-ddr3-arm2-wm8958.dtb \<br>imx6ull-14x14-evk.dtb \<br>imx6ull-14x14-evk-btwifi.dtb \<br>imx6ull-14x14-evk-emmc.dtb \<br>imx6ull-14x14-evk-gpmi-weim.dtb \<br>imx6ull-14x14-evk-usb-certi.dtb \<br>imx6ull-alientek-emmc.dtb \<br>imx6ull-alientek-nand.dtb \<br>imx6ull-9x9-evk.dtb \<br>imx6ull-9x9-evk-btwifi.dtb \<br>imx6ull-9x9-evk-ldo.dtb<br>dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6SLL)</span> += \<br>imx6sll-lpddr2-arm2.dtb \<br>imx6sll-lpddr3-arm2.dtb \<br>......<br></code></pre></td></tr></table></figure>

<p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL&#x3D;y)，所有使用到I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用 I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会将对应的.dts 编译为二进制的.dtb文件。</p>
<h3 id="DTS语法"><a href="#DTS语法" class="headerlink" title="DTS语法"></a>DTS语法</h3><h4 id="dtsi头文件"><a href="#dtsi头文件" class="headerlink" title="dtsi头文件"></a>dtsi头文件</h4><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-alientek-emmc.dts 中有如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/input/input.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull.dtsi&quot;</span></span><br></code></pre></td></tr></table></figure>

<p>在.dts 设备树文件中，可以通过“#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。</p>
<p>一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。比如 imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息的，内容如下：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi1.png" srcset="/img/loading.gif" lazyload class title="dtsi1">

<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi2.png" srcset="/img/loading.gif" lazyload class title="dtsi2">

<p>示例代码 43.3.1.3 中第 54<del>89 行就是 cpu0 这个设备节点信息，这个节点信息描述了I.MX6ULL 这颗 SOC 所使用的 CPU 信息，比如架构是 cortex-A7，频率支持 996MHz、792MHz、528MHz、396MHz 和 198MHz 等等。在 imx6ull.dtsi 文件中不仅仅描述了 cpu0 这一个节点信息，I.MX6ULL 这颗 SOC 所有的外设都描述的清清楚楚，比如 ecspi1</del>4、uart1<del>8、usbphy1</del>2、i2c1~4等等</p>
<h4 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h4><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。以下是从imx6ull.dtsi 文件中缩减出来的设备树文件内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">/ &#123;<br>    aliases &#123;<br>        can0 = &amp;flexcan1;<br>    &#125;;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<br>        compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<br>        <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><br>        interrupt-controller;<br>        reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<br>        &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第 1 行，“&#x2F;”是根节点，每个设备树文件只有一个根节点。细心的同学应该会发现，imx6ull.dtsi和 imx6ull-alientek-emmc.dts 这两个文件都有一个“&#x2F;”根节点，这样不会出错吗？不会的，因为这两个“&#x2F;”根节点的内容会合并成一个根节点。</p>
<p>第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">node-name@unit-address<br></code></pre></td></tr></table></figure>

<p>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。<br>但是我们在示例代码 43.3.2.1 中我们看到的节点命名却如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu0:cpu@<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">label: node-name@unit-address<br></code></pre></td></tr></table></figure>

<p>引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。再比如节点 “intc: interrupt-controller@00a01000”，节点 label 是 intc，而节点名字就很长了，为“interruptcontroller@00a01000”。很明显通过&amp;intc 来访问“interrupt-controller@00a01000”这个节点要方便很多！<br>每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。</p>
<p>设备树源码中常用的几种数据形式如下所示：<br>1、字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;	<span class="hljs-comment">//设置 compatible 属性的值为字符串“arm,cortex-a7”。</span><br></code></pre></td></tr></table></figure>

<p>2、32位无符号整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">reg = &lt;<span class="hljs-number">0</span>&gt;;		<span class="hljs-comment">//设置 reg 属性的值为 0</span><br><span class="hljs-comment">//reg 的值也可以设置为一组值，例如：</span><br>reg = &lt;<span class="hljs-number">0</span> <span class="hljs-number">0x123456</span> <span class="hljs-number">100</span>&gt;;<br></code></pre></td></tr></table></figure>

<p>3、字符串列表<br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-nand&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h4><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性，Linux 下的很多外设驱动都会使用这些标准属性。</p>
<h5 id="compatible属性"><a href="#compatible属性" class="headerlink" title="compatible属性"></a>compatible属性</h5><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;manufacturer,model&quot;</span><br></code></pre></td></tr></table></figure>

<p>其中 manufacturer 表示厂商，model 一般是模块对应的驱动名字。比如 imx6ull-alientek-emmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点，I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960，sound 节点的 compatible 属性值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,<span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p>
<p>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。<br>比如在文件 imx-wm8960.c 中有如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">632</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx_wm8960_dt_ids</span>[] =</span> &#123;<br><span class="hljs-number">633</span>     &#123; .compatible = <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,<br><span class="hljs-number">634</span>     &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<br><span class="hljs-number">635</span> &#125;;<br><span class="hljs-number">636</span> MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);<br><span class="hljs-number">637</span><br><span class="hljs-number">638</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx_wm8960_driver</span> =</span> &#123;<br><span class="hljs-number">639</span>     .driver = &#123;<br><span class="hljs-number">640</span>         .name = <span class="hljs-string">&quot;imx-wm8960&quot;</span>,<br><span class="hljs-number">641</span>         .pm = &amp;snd_soc_pm_ops,<br><span class="hljs-number">642</span>         .of_match_table = imx_wm8960_dt_ids,<br><span class="hljs-number">643</span>     &#125;,<br><span class="hljs-number">644</span>     .probe = imx_wm8960_probe,<br><span class="hljs-number">645</span>     .remove = imx_wm8960_remove,<br><span class="hljs-number">646</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>第 632-635 行的数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br>第 642 行，wm8960 采用了 platform_driver 驱动模式，此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个 platform_driver 所使用的OF 匹配表。</p>
<h5 id="model属性"><a href="#model属性" class="headerlink" title="model属性"></a>model属性</h5><p>model属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">model = <span class="hljs-string">&quot;wm8960-audio&quot;</span>;<br></code></pre></td></tr></table></figure>

<h5 id="status属性"><a href="#status属性" class="headerlink" title="status属性"></a>status属性</h5><p>status 属性看名字就知道是和设备状态有关的，status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表所示：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>okay</td>
<td>表明设备是可操作的</td>
</tr>
<tr>
<td>disabled</td>
<td>表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。</td>
</tr>
<tr>
<td>fail</td>
<td>表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。</td>
</tr>
<tr>
<td>fail-sss</td>
<td>含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td>
</tr>
</tbody></table>
<h5 id="address-cells和-size-cells属性"><a href="#address-cells和-size-cells属性" class="headerlink" title="#address-cells和#size-cells属性"></a>#address-cells和#size-cells属性</h5><p>这两个属性的值都是无符号 32 位整形，#address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)，#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。#address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度，reg 属性的格式一为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;<br></code></pre></td></tr></table></figure>

<p>每个“address length”组合表示一个地址范围，其中 address 是起始地址，length 是地址长度，#address-cells 表明 address 这个数据所占用的字长，#size-cells 表明 length 这个数据所占用的字长，比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C">spi4 &#123;<br>    compatible = <span class="hljs-string">&quot;spi-gpio&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>    gpio_spi: gpio_spi@<span class="hljs-number">0</span> &#123;<br>        compatible = <span class="hljs-string">&quot;fairchild,74hc595&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0</span>&gt;;<br>    &#125;;<br>&#125;;<br><br>aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><br>    dcp: dcp@<span class="hljs-number">02280000</span> &#123;<br>        compatible = <span class="hljs-string">&quot;fsl,imx6sl-dcp&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0x02280000</span> <span class="hljs-number">0x4000</span>&gt;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>第 3，4 行，节点 spi4 的#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，说明 spi4 的子节点 reg 属性中起始地址所占用的字长为 1，地址长度所占用的字长为 0。<br>第 8 行，子节点 gpio_spi: gpio_spi@0 的 reg 属性值为 &lt;0&gt;，因为父节点设置了#addresscells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，因此 addres&#x3D;0，没有 length 的值相当于设置了起始地址，而没有设置地址长度。<br>第 14，15 行，设置 aips3: aips-bus@02200000 节点#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1。<br>第 19 行，子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，address&#x3D; 0x02280000，length&#x3D; 0x4000，相当于设置了起始地址为 0x02280000，地址长度为 0x40000。</p>
<h5 id="reg属性"><a href="#reg属性" class="headerlink" title="reg属性"></a>reg属性</h5><p>reg 属性前面已经提到过了，reg 属性的值一般是(address，length)对。reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，比如在 imx6ull.dtsi 中有如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uart1: serial@<span class="hljs-number">02020000</span> &#123;<br>	compatible = <span class="hljs-string">&quot;fsl,imx6ul-uart&quot;</span>,<br>		<span class="hljs-string">&quot;fsl,imx6q-uart&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-uart&quot;</span>;<br>	reg = &lt;<span class="hljs-number">0x02020000</span> <span class="hljs-number">0x4000</span>&gt;;<br>	interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br>	clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,<br>		&lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;<br>	clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<br>	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述代码是节点 uart1，uart1 节点描述了 I.MX6ULL 的 UART1 相关信息，重点是第 326 行的 reg 属性。其中 uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、#sizecells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000，length&#x3D;0x4000。查阅《I.MX6ULL 参考手册》可知，I.MX6ULL 的 UART1 寄存器首地址为 0x02020000，但是 UART1 的地址长度(范围)并没有 0x4000 这么多，这里我们重点是获取 UART1 寄存器首地址。</p>
<h5 id="ranges属性"><a href="#ranges属性" class="headerlink" title="ranges属性"></a>ranges属性</h5><p>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵，ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：<br><strong>child-bus-address</strong>：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>parent-bus-address</strong>：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>length</strong>：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。</p>
<p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于我们所使用的 I.MX6ULL 来说，子地址空间和父地址空间完全相同，因此会在 imx6ull.dtsi中找到大量的值为空的 ranges 属性，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">137</span> soc &#123;<br><span class="hljs-number">138</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">139</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">140</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">141</span> interrupt-parent = &lt;&amp;gpc&gt;;<br><span class="hljs-number">142</span> ranges;<br>......<br><span class="hljs-number">1177</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 142 行定义了 ranges 属性，但是 ranges 属性值为空。<br>ranges 属性不为空的示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">soc &#123;<br>    compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    ranges = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0xe0000000</span> <span class="hljs-number">0x00100000</span>&gt;;<br><br>    serial &#123;<br>        device_type = <span class="hljs-string">&quot;serial&quot;</span>;<br>        compatible = <span class="hljs-string">&quot;ns16550&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;;<br>        clock-frequency = &lt;<span class="hljs-number">0</span>&gt;;<br>        interrupts = &lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;;<br>        interrupt-parent = &lt;&amp;ipic&gt;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>第 5 行，节点 soc 定义的 ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。<br>第 10 行，serial 是串口设备节点，reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换，serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。</p>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>name 属性值为字符串，name 属性用于记录节点名字，name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p>
<h5 id="device-type属性"><a href="#device-type属性" class="headerlink" title="device_type属性"></a>device_type属性</h5><p>device_type 属性值为字符串，IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设备树没有 FCode，所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。imx6ull.dtsi 的 cpu0 节点用到了此属性，内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>	compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>	device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>	reg = &lt;<span class="hljs-number">0</span>&gt;;<br>	......<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="根节点compatible属性"><a href="#根节点compatible属性" class="headerlink" title="根节点compatible属性"></a>根节点compatible属性</h4><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外，imx6ull-alientek-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">/ &#123;<br>	model = <span class="hljs-string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;<br>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出，compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，那么根节点中的 compatible属性是为了做什么工作的？ 通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第二个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。接下来我们就来学习一下 Linux 内核在使用设备树前后是如何判断是否支持某款设备的。</p>
<h6 id="使用设备树的设备匹配方法"><a href="#使用设备树的设备匹配方法" class="headerlink" title="使用设备树的设备匹配方法"></a>使用设备树的设备匹配方法</h6><p>DT_MACHINE_START 也定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h里面，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span><br><span class="hljs-meta">static const struct machine_desc __mach_desc_##_name \</span><br><span class="hljs-meta">__used \</span><br><span class="hljs-meta">__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span><br><span class="hljs-meta"> .nr = ~0, \</span><br><span class="hljs-meta"> .name = _namestr,</span><br></code></pre></td></tr></table></figure>

<p>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *imx6ul_dt_compat[] __initconst = &#123;<br>	<span class="hljs-string">&quot;fsl,imx6ul&quot;</span>,<br>	<span class="hljs-string">&quot;fsl,imx6ull&quot;</span>,<br>	<span class="hljs-literal">NULL</span>,<br>&#125;;<br><br>DT_MACHINE_START(IMX6UL, <span class="hljs-string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)<br>	.map_io = imx6ul_map_io,<br>	.init_irq = imx6ul_init_irq,<br>	.init_machine = imx6ul_init_machine,<br>	.init_late = imx6ul_init_late,<br>	.dt_compat = imx6ul_dt_compat,<br>MACHINE_END<br></code></pre></td></tr></table></figure>

<p>machine_desc 结构体中有个.dt_compat 成员变量，此成员变量保存着本设备兼容属性，示例代码中设置.dt_compat &#x3D; imx6ul_dt_compat，imx6ul_dt_compat 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“&#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。imx6ull-alientek-emmc.dts 中根节点的 compatible 属性值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。如果将 imx6ull-alientek-emmc.dts 根节点的 compatible 属性改为其他的值，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ullll&quot;</span><br></code></pre></td></tr></table></figure>

<p>重新编译 DTS，并用新的 DTS 启动 Linux 内核，结果如图所示的错误提示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/error.png" srcset="/img/loading.gif" lazyload class title="error">

<p>当我们修改了根节点 compatible 属性内容以后，因为 Linux 内核找不到对应的设备，因此Linux 内核无法启动。在 uboot 输出 Starting kernel…以后就再也没有其他信息输出了。</p>
<p>接下来我们简单看一下 Linux 内核是如何根据设备树根节点的 compatible 属性来匹配出对应的 machine_desc，Linux 内核调用 start_kernel 函数来启动内核，start_kernel 函数会调用setup_arch 函数来匹配 machine_desc，setup_arch 函数定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中，函数内容如下(有缩减)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">913</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span><br>914 &#123;<br><span class="hljs-number">915</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>;</span><br><span class="hljs-number">916</span><br><span class="hljs-number">917</span> setup_processor();<br><span class="hljs-number">918</span> mdesc = setup_machine_fdt(__atags_pointer);<br><span class="hljs-number">919</span> <span class="hljs-keyword">if</span> (!mdesc)<br><span class="hljs-number">920</span> mdesc = setup_machine_tags(__atags_pointer, <br>__machine_arch_type);<br><span class="hljs-number">921</span> machine_desc = mdesc;<br><span class="hljs-number">922</span> machine_name = mdesc-&gt;name;<br>......<br><span class="hljs-number">986</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址，setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。<br>函数 setup_machine_fdt 定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 中，内容如下(有缩减)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">204</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> machine_desc * __init <span class="hljs-title function_">setup_machine_fdt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dt_phys)</span><br>205 &#123;<br><span class="hljs-number">206</span> 	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>, *<span class="hljs-title">mdesc_best</span> =</span> <span class="hljs-literal">NULL</span>;<br>......<br><span class="hljs-number">214</span><br><span class="hljs-number">215</span> 	<span class="hljs-keyword">if</span> (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))<br><span class="hljs-number">216</span> 		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">217</span><br><span class="hljs-number">218</span> 	mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);<br><span class="hljs-number">219</span><br>......<br><span class="hljs-number">247</span> 	__machine_arch_type = mdesc-&gt;nr;<br><span class="hljs-number">248</span><br><span class="hljs-number">249</span> 	<span class="hljs-keyword">return</span> mdesc;<br><span class="hljs-number">250</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 218 行，调用函数 of_flat_dt_match_machine 来获取匹配的 machine_desc，参数 mdesc_best是默认的 machine_desc ，参数 arch_get_next_mach 是个函数，此函数定义在定义在arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 文件中。找到匹配的 machine_desc 的过程就是用设备树根节点的compatible 属性值和 Linux 内核中 machine_desc 下.dt_compat 的值比较，看看那个相等，如果相等的话就表示找到匹配的 machine_desc，arch_get_next_mach 函数的工作就是获取 Linux 内核中下一个 machine_desc 结构体。<br>最后再来看一下 of_flat_dt_match_machine 函数，此函数定义在文件 drivers&#x2F;of&#x2F;fdt.c 中，内容如下(有缩减)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">705</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> * __init <span class="hljs-title function_">of_flat_dt_match_machine</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span></span><br><span class="hljs-params">*default_match,</span><br><span class="hljs-params"><span class="hljs-number">706</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> * (*get_next_compat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span>**))</span><br>707 &#123;<br><span class="hljs-number">708</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">709</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *best_data = default_match;<br><span class="hljs-number">710</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> *compat;<br><span class="hljs-number">711</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dt_root;<br><span class="hljs-number">712</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> best_score = ~<span class="hljs-number">1</span>, score = <span class="hljs-number">0</span>;<br><span class="hljs-number">713</span><br><span class="hljs-number">714</span> dt_root = of_get_flat_dt_root();<br><span class="hljs-number">715</span> <span class="hljs-keyword">while</span> ((data = get_next_compat(&amp;compat))) &#123;<br><span class="hljs-number">716</span> score = of_flat_dt_match(dt_root, compat);<br><span class="hljs-number">717</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">0</span> &amp;&amp; score &lt; best_score) &#123;<br><span class="hljs-number">718</span> best_data = data;<br><span class="hljs-number">719</span> best_score = score;<br><span class="hljs-number">720</span> &#125;<br><span class="hljs-number">721</span> &#125;<br>......<br><span class="hljs-number">739</span><br><span class="hljs-number">740</span> pr_info(<span class="hljs-string">&quot;Machine model: %s\n&quot;</span>, of_flat_dt_get_machine_name());<br><span class="hljs-number">741</span><br><span class="hljs-number">742</span> <span class="hljs-keyword">return</span> best_data;<br><span class="hljs-number">743</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 714 行，通过函数 of_get_flat_dt_root 获取设备树根节点。<br>第 715-720 行，此循环就是查找匹配的 machine_desc 过程，第 716 行的 of_flat_dt_match 函数会将根节点 compatible 属性的值和每个 machine_desc 结构体中. dt_compat 的值进行比较，直至找到匹配的那个 machine_desc。<br>总结一下，Linux 内核通过根节点 compatible 属性找到对应的设备的函数调用过程，如图所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/start_kernel.png" srcset="/img/loading.gif" lazyload class title="start_kernel">

<h4 id="向节点追加或修改内容"><a href="#向节点追加或修改内容" class="headerlink" title="向节点追加或修改内容"></a>向节点追加或修改内容</h4><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片fxls8471，fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.1 i2c1 节点</span><br><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-number">938</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">939</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">940</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-number">941</span> 	reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">942</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-number">943</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-number">944</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">945</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>示例代码 43.3.5.1 就是 I.MX6ULL 的 I2C1 节点，现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.2 添加 fxls8471 子节点</span><br><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-number">938</span> 	<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">939</span> 	<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">940</span> 	compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-number">941</span> 	reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">942</span> 	interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-number">943</span> 	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-number">944</span> 	status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">945</span><br><span class="hljs-number">946</span> 	<span class="hljs-comment">//fxls8471 子节点</span><br><span class="hljs-number">947</span> 	fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-number">948</span> 		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-number">949</span> 		reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<br><span class="hljs-number">950</span> 	&#125;;<br><span class="hljs-number">951</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>第 947-950 行就是添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码 43.3.5.2 这样写肯定是不行的。<br>这里就要引入另外一个内容，那就是如何向节点追加数据，我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-alientek-emmc.dts，因此我们需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.3 节点追加数据方法</span><br>&amp;i2c1 &#123;<br>	<span class="hljs-comment">/* 要追加或修改的内容 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>第 1 行，&amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1: i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。<br>打开 imx6ull-alientek-emmc.dts，找到如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.4 向 i2c1 节点追加数据</span><br><span class="hljs-number">224</span> &amp;i2c1 &#123;<br><span class="hljs-number">225</span> 	clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br><span class="hljs-number">226</span> 	pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br><span class="hljs-number">227</span> 	pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br><span class="hljs-number">228</span> 	status = <span class="hljs-string">&quot;okay&quot;</span>;<br><span class="hljs-number">229</span><br><span class="hljs-number">230</span> 	mag3110@<span class="hljs-number">0</span>e &#123;<br><span class="hljs-number">231</span> 		compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<br><span class="hljs-number">232</span> 		reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<br><span class="hljs-number">233</span> 		position = &lt;<span class="hljs-number">2</span>&gt;;<br><span class="hljs-number">234</span> 	&#125;;<br><span class="hljs-number">235</span><br><span class="hljs-number">236</span> 	fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-number">237</span> 		compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-number">238</span> 		reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<br><span class="hljs-number">239</span> 		position = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-number">240</span> 		interrupt-parent = &lt;&amp;gpio5&gt;;<br><span class="hljs-number">241</span> 		interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;<br><span class="hljs-number">242</span> 	&#125;;<br><span class="hljs-number">243</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>示例代码 43.3.5.4 就是向 i2c1 节点添加&#x2F;修改数据，比如第 225 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第 228 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 230-234 行，i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用mag3110。<br>第 236-242 行，i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。<br>因为示例代码 43.3.5.4 中的内容是 imx6ull-alientek-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容。</p>
<h3 id="创建小型模板设备树"><a href="#创建小型模板设备树" class="headerlink" title="创建小型模板设备树"></a>创建小型模板设备树</h3><p>上一节已经对 DTS 的语法做了比较详细的讲解，本节我们就根据前面讲解的语法，从头到尾编写一个小型的设备树文件。当然了，这个小型设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。在实际产品开发中，我们是不需要完完全全的重写一个.dts 设备树文件，一般都是使用 SOC 厂商提供好的.dts 文件，我们只需要在上面根据自己的实际情况做相应的修改即可。在编写设备树之前要先定义一个设备，我们就以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：<br>①、I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000，大小为 0x4000。<br>④、I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为 0x02184000，大小为 0x4000。<br>⑤、I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。<br>为了简单起见，我们就在设备树里面就实现这些内容即可，首先，搭建一个仅含有根节点“&#x2F;”的基础的框架，新建一个名为 myfirst.dts 文件，在里面输入如下所示内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.1 设备树基础框架</span><br>/ &#123;<br>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设备树框架很简单，就一个根节点“&#x2F;”，根节点里面只有一个 compatible 属性。我们就在这个基础框架上面将上面列出的内容一点点添加进来。</p>
<p>1、添加cpus节点</p>
<p>首先添加 CPU 节点，I.MX6ULL 采用 Cortex-A7 架构，而且只有一个 CPU，因此只有一个cpu0 节点，完成以后如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.2 添加 CPU0 节点</span><br>/ &#123;<br>	compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>    <br>	cpus &#123;<br>		<span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>		<span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>    <br>		<span class="hljs-comment">//CPU0 节点</span><br>		cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>			compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>			device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>			reg = &lt;<span class="hljs-number">0</span>&gt;;<br>		&#125;;<br>	&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第 4~14 行，cpus 节点，此节点用于描述 SOC 内部的所有 CPU，因为 I.MX6ULL 只有一个CPU，因此只有一个 cpu0 子节点。</p>
<p>2、添加soc节点</p>
<p>像 uart，iic 控制器等等这些都属于 SOC 内部外设，因此一般会创建一个叫做 soc 的父节点来管理这些 SOC 内部外设的子节点，添加 soc 节点以后的 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.3 添加 soc 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>第 17~22 行，soc 节点，soc 节点设置#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，这样 soc 子节点的 reg 属性中起始地占用一个字长，地址空间长度也占用一个字长。<br>第 21 行，ranges 属性，ranges 属性为空，说明子空间和父空间地址范围相同。</p>
<p>3、添加ocram节点</p>
<p>根据第②点的要求，添加 ocram 节点，ocram 是 I.MX6ULL 内部 RAM，因此 ocram 节点应该是 soc 节点的子节点。ocram 起始地址为 0x00900000，大小为 128KB(0x20000)，添加 ocram节点以后 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.4 添加 ocram 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>        compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>        device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>第 24~27 行，ocram 节点，第 24 行节点名字@后面的 0x00900000 就是 ocram 的起始地址。<br>第 26 行的 reg 属性也指明了 ocram 内存的起始地址为 0x00900000，大小为 0x20000。</p>
<p>4、添加 aips1、aips2 和 aips3 这三个子节点</p>
<p>I.MX6ULL 内部分为三个域：aips1-3，这三个域分管不同的外设控制器，aips1-3 这三个域对应的内存范围如表所示：</p>
<table>
<thead>
<tr>
<th>域</th>
<th>起始地址</th>
<th>大小（十六进制）</th>
</tr>
</thead>
<tbody><tr>
<td>AIPS1</td>
<td>0x02000000</td>
<td>0x100000</td>
</tr>
<tr>
<td>AIPS2</td>
<td>0x02100000</td>
<td>0x100000</td>
</tr>
<tr>
<td>AIPS3</td>
<td>0x02200000</td>
<td>0x100000</td>
</tr>
</tbody></table>
<p>我们先在设备树中添加这三个域对应的子节点。aips1~3 这三个域都属于 soc 节点的子节点，完成以后的 myfirst.dts 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.5 添加 aips1~3 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br><br>        <span class="hljs-comment">//aips1 节点</span><br>        aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br><br>        <span class="hljs-comment">//aips2 节点</span><br>        aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br><br>        <span class="hljs-comment">//aips3 节点 </span><br>        aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5、添加 ecspi1、usbotg1 和 rngb 这三个外设控制器节点</p>
<p>最后我们在 myfirst.dts 文件中加入 ecspi1，usbotg1 和 rngb 这三个外设控制器对应的节点，其中 ecspi1 属于 aips1 的子节点，usbotg1 属于 aips2 的子节点，rngb 属于 aips3 的子节点。最终的 myfirst.dts 文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.6 添加 ecspi1、usbotg1 和 rngb 这三个节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br><br>        <span class="hljs-comment">//aips1 节点</span><br>        aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//ecspi1 节点</span><br>            ecspi1: ecspi@<span class="hljs-number">02008000</span> &#123;<br>                <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>                <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>                compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02008000</span> <span class="hljs-number">0x4000</span>&gt;;<br>                status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//aips2 节点</span><br>        aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//usbotg1 节点</span><br>            usbotg1: usb@<span class="hljs-number">02184000</span> &#123;<br>                compatible = <span class="hljs-string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-usb&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02184000</span> <span class="hljs-number">0x4000</span>&gt;;<br>                status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//aips3 节点 </span><br>        aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//rngb 节点</span><br>            rngb: rngb@<span class="hljs-number">02284000</span> &#123;<br>                compatible = <span class="hljs-string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="hljs-string">&quot;fsl,imx-rng&quot;</span>, <span class="hljs-string">&quot;imx-rng&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02284000</span> <span class="hljs-number">0x4000</span>&gt;;<br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，myfirst.dts 这个小型的模板设备树就编写好了，基本和 imx6ull.dtsi 很像，可以看做是 imx6ull.dtsi 的缩小版。在 myfirst.dts 里面我们仅仅是编写了 I.MX6ULL 的外设控制器节点，像 IIC 接口，SPI 接口下所连接的具体设备我们并没有写，因为具体的设备其设备树属性内容不同，这个等到具体的实验在详细讲解。</p>
<h3 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h3><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹，如图 43.5.1 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/a.png" srcset="/img/loading.gif" lazyload class title="a">

<p>图 43.5.1 就是目录&#x2F;proc&#x2F;device-tree 目录下的内容，&#x2F;proc&#x2F;device-tree 目录下是根节点“&#x2F;”的所有属性和子节点，我们依次来看一下这些属性和子节点。</p>
<p>1、根节点 “&#x2F;” 各个属性值</p>
<p>在图 43.5.1 中，根节点属性属性表现为一个个的文件(图中细字体文件)，比如图 43.5.1 中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件，它们在设备树中就是根节点的 5个属性。既然是文件那么肯定可以查看其内容，输入 cat 命令来查看 model和 compatible 这两个文件的内容，结果如图 43.5.2 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/b.png" srcset="/img/loading.gif" lazyload class title="b">

<p>从图 43.5.2 可以看出，文件 model 的内容是“Freescale i.MX6 ULL 14x14 EVK Board”，文件 compatible 的内容为“fsl,imx6ull-14x14-evkfsl,imx6ull”。打开文件 imx6ull-alientek-emmc.dts查看一下，这不正是根节点“&#x2F;”的 model 和 compatible 属性值吗！</p>
<p>2、根节点 “&#x2F;” 各子节点</p>
<p>图 43.5.1 中各个文件夹(图中粗字体文件夹)就是根节点“&#x2F;”的各个子节点，比如“aliases”、“backlight”、“chosen”和“clocks”等等。大家可以查看一下 imx6ull-alientek-emmc.dts 和imx6ull.dtsi 这两个文件，看看根节点的子节点都有哪些，看看是否和图 43.5.1 中的一致。<br>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点，如图 43.5.3 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/c.png" srcset="/img/loading.gif" lazyload class title="c">

<p>和根节点“&#x2F;”一样，图 43.5.3 中的所有文件分别为 soc 节点的属性文件和子节点文件夹。大家可以自行查看一下这些属性文件的内容是否和 imx6ull.dtsi 中 soc 节点的属性值相同，也可以进入“busfreq”这样的文件夹里面查看 soc 节点的子节点信息。</p>
<h3 id="特殊节点"><a href="#特殊节点" class="headerlink" title="特殊节点"></a>特殊节点</h3><p>在根节点“&#x2F;”中有两个特殊的子节点：aliases 和 chosen，我们接下来看一下这两个特殊的子节点。</p>
<h4 id="aliases子节点"><a href="#aliases子节点" class="headerlink" title="aliases子节点"></a>aliases子节点</h4><p>打开 imx6ull.dtsi 文件，aliases 节点内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.1.1 aliases 子节点</span><br><span class="hljs-number">18</span> aliases &#123;<br><span class="hljs-number">19</span>      can0 = &amp;flexcan1;<br><span class="hljs-number">20</span>      can1 = &amp;flexcan2;<br><span class="hljs-number">21</span>      ethernet0 = &amp;fec1;<br><span class="hljs-number">22</span>      ethernet1 = &amp;fec2;<br><span class="hljs-number">23</span>      gpio0 = &amp;gpio1;<br><span class="hljs-number">24</span>      gpio1 = &amp;gpio2;<br>        ......       <br><span class="hljs-number">42</span>      spi0 = &amp;ecspi1;<br><span class="hljs-number">43</span>      spi1 = &amp;ecspi2;<br><span class="hljs-number">44</span>      spi2 = &amp;ecspi3;<br><span class="hljs-number">45</span>      spi3 = &amp;ecspi4;<br><span class="hljs-number">46</span>      usbphy0 = &amp;usbphy1;<br><span class="hljs-number">47</span>      usbphy1 = &amp;usbphy2;<br><span class="hljs-number">48</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p>
<h4 id="chosen子节点"><a href="#chosen子节点" class="headerlink" title="chosen子节点"></a>chosen子节点</h4><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少，imx6ull-alientek-emmc.dts 中 chosen 节点内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.2.1 chosen 子节点</span><br>chosen &#123;<br>	<span class="hljs-built_in">stdout</span>-path = &amp;uart1;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>从示例代码 43.6.2.1 中可以看出，chosen 节点仅仅设置了属性“stdout-path”，表示标准输出使用 uart1。但是当我们进入到&#x2F;proc&#x2F;device-tree&#x2F;chosen 目录里面，会发现多了 bootargs 这个属性，如图 43.6.2.1 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/d.png" srcset="/img/loading.gif" lazyload class title="d">

<p>输入 cat 命令查看 bootargs 这个文件的内容，结果如图 43.6.2.2 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/e.png" srcset="/img/loading.gif" lazyload class title="e">

<p>从图 43.6.2.2 可以看出，bootargs 这个文件的内容为“console&#x3D;ttymxc0,115200……”，这个不就是我们在 uboot 中设置的 bootargs 环境变量的值吗？现在有两个疑点：<br>①、我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么图 43.6.2.1 中 bootargs这个属性是怎么产生的？<br>②、为何 bootargs 文件的内容和 uboot 中 bootargs 环境变量的值一样？它们之间有什么关系？</p>
<p>前面讲解 uboot 的时候说过，uboot 在启动 Linux 内核的时候会将 bootargs 的值传递给 Linux内核，bootargs 会作为 Linux 内核的命令行参数，Linux 内核启动的时候会打印出命令行参数(也就是 uboot 传递进来的 bootargs 的值)，如图 43.6.2.3 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/f.png" srcset="/img/loading.gif" lazyload class title="f">

<p>既然 chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性！并且设置 bootargs 属性的值为 bootargs环境变量的值。因为在启动 Linux 内核之前，只有 uboot 知道 bootargs 环境变量的值，并且 uboot也知道.dtb 设备树文件在 DRAM 中的位置，因此 uboot 的“作案”嫌疑最大。在 uboot 源码中全局搜索“chosen”这个字符串，看看能不能找到一些蛛丝马迹。果然不出所料，在common&#x2F;fdt_support.c 文件中发现了“chosen”的身影，fdt_support.c 文件中有个 fdt_chosen 函数，此函数内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.2.2 uboot 源码中的 fdt_chosen 函数</span><br><span class="hljs-number">275</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fdt_chosen</span><span class="hljs-params">(<span class="hljs-type">void</span> *fdt)</span><br>276 &#123;<br><span class="hljs-number">277</span>     <span class="hljs-type">int</span> nodeoffset;<br><span class="hljs-number">278</span>     <span class="hljs-type">int</span> err;<br><span class="hljs-number">279</span>     <span class="hljs-type">char</span> *str; <span class="hljs-comment">/* used to set string properties */</span><br><span class="hljs-number">280</span><br><span class="hljs-number">281</span>     err = fdt_check_header(fdt);<br><span class="hljs-number">282</span>     <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">283</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));<br><span class="hljs-number">284</span>         <span class="hljs-keyword">return</span> err;<br><span class="hljs-number">285</span>     &#125;<br><span class="hljs-number">286</span><br><span class="hljs-number">287</span>     <span class="hljs-comment">/* find or create &quot;/chosen&quot; node. */</span><br><span class="hljs-number">288</span>     nodeoffset = fdt_find_or_add_subnode(fdt, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;chosen&quot;</span>);<br><span class="hljs-number">289</span>     <span class="hljs-keyword">if</span> (nodeoffset &lt; <span class="hljs-number">0</span>)<br><span class="hljs-number">290</span>         <span class="hljs-keyword">return</span> nodeoffset;<br><span class="hljs-number">291</span><br><span class="hljs-number">292</span>     str = getenv(<span class="hljs-string">&quot;bootargs&quot;</span>);<br><span class="hljs-number">293</span>     <span class="hljs-keyword">if</span> (str) &#123;<br><span class="hljs-number">294</span>         err = fdt_setprop(fdt, nodeoffset, <span class="hljs-string">&quot;bootargs&quot;</span>, str,<br><span class="hljs-number">295</span>         <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br><span class="hljs-number">296</span>         <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">297</span>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,<br><span class="hljs-number">298</span>             fdt_strerror(err));<br><span class="hljs-number">299</span>             <span class="hljs-keyword">return</span> err;<br><span class="hljs-number">300</span>         &#125;<br><span class="hljs-number">301</span>     &#125;<br><span class="hljs-number">302</span><br><span class="hljs-number">303</span>     <span class="hljs-keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);<br><span class="hljs-number">304</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 288 行，调用函数 fdt_find_or_add_subnode 从设备树(.dtb)中找到 chosen 节点，如果没有找到的话就会自己创建一个 chosen 节点。<br>第 292 行，读取 uboot 中 bootargs 环境变量的内容。<br>第 294 行，调用函数 fdt_setprop 向 chosen 节点添加 bootargs 属性，并且 bootargs 属性的值就是环境变量 bootargs 的内容。<br>证据“实锤”了，就是 uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。接下来我们顺着 fdt_chosen 函数一点点的抽丝剥茧，看看都有哪些函数调用了 fdt_chosen，一直找到最终的源头。见图 43.6.2.4：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/g.png" srcset="/img/loading.gif" lazyload class title="g">

<p>图 43.6.2.4 中框起来的部分就是函数 do_bootm_linux 函数的执行流程，也就是说do_bootm_linux 函数会通过一系列复杂的调用，最终通过 fdt_chosen 函数在 chosen 节点中加入了 bootargs 属性。而我们通过 bootz 命令启动 Linux 内核的时候会运行 do_bootm_linux 函数，至此，真相大白，一切事情的源头都源于如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bootz 80800000 – 83000000<br></code></pre></td></tr></table></figure>

<h3 id="Linux-内核解析-DTB-文件"><a href="#Linux-内核解析-DTB-文件" class="headerlink" title="Linux 内核解析 DTB 文件"></a>Linux 内核解析 DTB 文件</h3><p>Linux 内核在启动的时候会解析 DTB 文件，然后在&#x2F;proc&#x2F;device-tree 目录下生成相应的设备树节点文件。接下来我们简单分析一下 Linux 内核是如何解析 DTB 文件的，流程如图 43.7.1 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/h.png" srcset="/img/loading.gif" lazyload class title="h">

<p>从图 43.7.1 中可以看出，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。</p>
<h3 id="绑定信息文档"><a href="#绑定信息文档" class="headerlink" title="绑定信息文档"></a>绑定信息文档</h3><p>设备树是用来描述板子上的设备信息的，不同的设备其信息不同，反映到设备树中就是属性不同。那么我们在设备树中添加一个硬件对应的节点的时候从哪里查阅相关的说明呢？在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，如图 43.8.1 所示：</p>
<img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/i.png" srcset="/img/loading.gif" lazyload class title="i">

<p>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-imx.txt，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">* Freescale Inter <span class="hljs-title function_">IC</span> <span class="hljs-params">(I2C)</span> and High Speed Inter <span class="hljs-title function_">IC</span> <span class="hljs-params">(HS-I2C)</span> <span class="hljs-keyword">for</span> i.MX<br>Required properties:<br>- compatible :<br> - &quot;fsl,imx1-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on i.MX1 <br>SoC<br> - &quot;fsl,imx21-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on i.MX21 <br>SoC<br> - &quot;fsl,vf610-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on Vybrid <br>vf610 SoC<br>- reg : Should contain I2C/HS-I2C registers location and length<br>- interrupts : Should contain I2C/HS-I2C interrupt<br>- clocks : Should contain the I2C/HS-I2C clock specifier<br>    <br>Optional properties:<br>- clock-frequency : Constains desired I2C/HS-I2C bus clock frequency in <br>Hz.<br> The absence of the propoerty indicates the <span class="hljs-keyword">default</span> frequency 100 kHz.<br>- dmas: A <span class="hljs-built_in">list</span> of two dma specifiers, one <span class="hljs-keyword">for</span> each entry in dma-names.<br>- dma-names: should contain &quot;tx&quot; and &quot;rx&quot;.<br>    <br>Examples:<br><br>i2c@83fc4000 &#123; <span class="hljs-comment">/* I2C2 on i.MX51 */</span><br>     compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>     reg = &lt;<span class="hljs-number">0x83fc4000</span> <span class="hljs-number">0x4000</span>&gt;;<br>     interrupts = &lt;<span class="hljs-number">63</span>&gt;;<br>&#125;;<br><br>i2c@<span class="hljs-number">70038000</span> &#123; <span class="hljs-comment">/* HS-I2C on i.MX51 */</span><br>	compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>	reg = &lt;<span class="hljs-number">0x70038000</span> <span class="hljs-number">0x4000</span>&gt;;<br>	interrupts = &lt;<span class="hljs-number">64</span>&gt;;<br>	clock-frequency = &lt;<span class="hljs-number">400000</span>&gt;;<br>&#125;;<br><br>i2c0: i2c@<span class="hljs-number">40066000</span> &#123; <span class="hljs-comment">/* i2c0 on vf610 */</span><br>     compatible = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>;<br>     reg = &lt;<span class="hljs-number">0x40066000</span> <span class="hljs-number">0x1000</span>&gt;;<br>     interrupts =&lt;<span class="hljs-number">0</span> <span class="hljs-number">71</span> <span class="hljs-number">0x04</span>&gt;;<br>     dmas = &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">50</span>&gt;,<br>     &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">51</span>&gt;;<br>     dma-names = <span class="hljs-string">&quot;rx&quot;</span>,<span class="hljs-string">&quot;tx&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>有时候使用的一些芯片在 Documentation&#x2F;devicetree&#x2F;bindings 目录下找不到对应的文档，这个时候就要咨询芯片的提供商，让他们给你提供参考的设备树文件。</p>
<h3 id="设备树常用-OF-操作函数"><a href="#设备树常用-OF-操作函数" class="headerlink" title="设备树常用 OF 操作函数"></a>设备树常用 OF 操作函数</h3><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p>
<h4 id="查找节点的OF函数"><a href="#查找节点的OF函数" class="headerlink" title="查找节点的OF函数"></a>查找节点的OF函数</h4><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.9.1 device_node 节点</span><br><span class="hljs-number">49</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> &#123;</span><br><span class="hljs-number">50</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 节点名字 */</span><br><span class="hljs-number">51</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *type; <span class="hljs-comment">/* 设备类型 */</span><br><span class="hljs-number">52</span> 		phandle phandle;<br><span class="hljs-number">53</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *full_name; <span class="hljs-comment">/* 节点全名 */</span><br><span class="hljs-number">54</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> <span class="hljs-title">fwnode</span>;</span><br><span class="hljs-number">55</span><br><span class="hljs-number">56</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">properties</span>;</span> <span class="hljs-comment">/* 属性 */</span><br><span class="hljs-number">57</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">deadprops</span>;</span> <span class="hljs-comment">/* removed 属性 */</span><br><span class="hljs-number">58</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">/* 父节点 */</span><br><span class="hljs-number">59</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">child</span>;</span> <span class="hljs-comment">/* 子节点 */</span><br><span class="hljs-number">60</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">sibling</span>;</span><br><span class="hljs-number">61</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-number">62</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<br><span class="hljs-number">63</span> 		<span class="hljs-type">void</span> *data;<br><span class="hljs-number">64</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SPARC)</span><br><span class="hljs-number">65</span> 		<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path_component_name;<br><span class="hljs-number">66</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<br><span class="hljs-number">67</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_irq_controller</span> *<span class="hljs-title">irq_trans</span>;</span><br><span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">69</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p>
<h5 id="of-find-node-by-name"><a href="#of-find-node-by-name" class="headerlink" title="of_find_node_by_name"></a>of_find_node_by_name</h5><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>name</strong>：要查找的节点名字。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败。</p>
<h5 id="of-find-node-by-type"><a href="#of-find-node-by-type" class="headerlink" title="of_find_node_by_type"></a>of_find_node_by_type</h5><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败。</p>
<h5 id="of-find-compatible-node"><a href="#of-find-compatible-node" class="headerlink" title="of_find_compatible_node"></a>of_find_compatible_node</h5><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_compatible_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compatible)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。<br><strong>compatible</strong>：要查找的节点所对应的 compatible 属性列表。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p>
<h5 id="of-find-matching-node-and-match"><a href="#of-find-matching-node-and-match" class="headerlink" title="of_find_matching_node_and_match"></a>of_find_matching_node_and_match</h5><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_matching_node_and_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from,</span><br><span class="hljs-params"> 											<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id *matches,</span><br><span class="hljs-params"> 											<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id **match)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>from：</strong>开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>matches：</strong>of_device_id 匹配表，也就是在此匹配表里面查找节点。<br><strong>match：</strong>找到的匹配的 of_device_id。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败</p>
<h5 id="of-find-node-by-path-函数"><a href="#of-find-node-by-path-函数" class="headerlink" title="of_find_node_by_path 函数"></a>of_find_node_by_path 函数</h5><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_path</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>path：</strong>带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个节点的全路径。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="查找父-子节点的OF函数"><a href="#查找父-子节点的OF函数" class="headerlink" title="查找父&#x2F;子节点的OF函数"></a>查找父&#x2F;子节点的OF函数</h4><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p>
<h5 id="of-get-parent"><a href="#of-get-parent" class="headerlink" title="of_get_parent"></a>of_get_parent</h5><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_parent</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>node：</strong>要查找的父节点的节点。<br><strong>返回值：</strong>找到的父节点。</p>
<h5 id="of-get-next-child"><a href="#of-get-next-child" class="headerlink" title="of_get_next_child"></a>of_get_next_child</h5><p>of_get_next_child 函数用迭代的方式查找子节点，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_next_child</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node,</span><br><span class="hljs-params"> 												<span class="hljs-keyword">struct</span> device_node *prev)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>node：</strong>父节点。<br><strong>prev：</strong>前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。<br><strong>返回值：</strong>找到的下一个子节点。</p>
<h4 id="提取属性值的-OF-函数"><a href="#提取属性值的-OF-函数" class="headerlink" title="提取属性值的 OF 函数"></a>提取属性值的 OF 函数</h4><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件include&#x2F;linux&#x2F;of.h 中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.3.1 property 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> &#123;</span><br>	<span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 属性名字 */</span><br>	<span class="hljs-type">int</span> length; <span class="hljs-comment">/* 属性长度 */</span><br>	<span class="hljs-type">void</span> *value; <span class="hljs-comment">/* 属性值 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个属性 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> <span class="hljs-title">attr</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下。</p>
<h5 id="of-find-property"><a href="#of-find-property" class="headerlink" title="of_find_property"></a>of_find_property</h5><p>of_find_property 函数用于查找指定的属性，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">property *<span class="hljs-title function_">of_find_property</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> *lenp)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>name：</strong> 属性名字。<br><strong>lenp：</strong>属性值的字节数<br><strong>返回值：</strong>找到的属性。</p>
<h5 id="of-property-count-elems-of-size"><a href="#of-property-count-elems-of-size" class="headerlink" title="of_property_count_elems_of_size"></a>of_property_count_elems_of_size</h5><p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_count_elems_of_size</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">int</span> elem_size)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 需要统计元素数量的属性名字。<br><strong>elem_size：</strong>元素长度。<br><strong>返回值：</strong>得到的属性元素数量。</p>
<h5 id="of-property-read-u32-index"><a href="#of-property-read-u32-index" class="headerlink" title="of_property_read_u32_index"></a>of_property_read_u32_index</h5><p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值(无符号 32位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_index</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u32 index,  u32 *out_value)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>index：</strong>要读取的值标号。<br><strong>out_value：</strong>读取到的值<br><strong>返回值：</strong>0 读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<h5 id="of-property-read-u8-array-of-property-read-u16-array-of-property-read-u32-array-of-property-read-u64-array"><a href="#of-property-read-u8-array-of-property-read-u16-array-of-property-read-u32-array-of-property-read-u64-array" class="headerlink" title="of_property_read_u8_array  of_property_read_u16_array of_property_read_u32_array of_property_read_u64_array"></a>of_property_read_u8_array  of_property_read_u16_array of_property_read_u32_array of_property_read_u64_array</h5><p>这 4 个函数分别是读取属性中 u8、u16、u32 和 u64 类型的数组数据，比如大多数的 reg 属性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据。这四个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u8 *out_values, <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u16 *out_values,  <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u32 *out_values, <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u64 *out_values, <span class="hljs-type">size_t</span> sz)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_value：</strong>读取到的数组值，分别为 u8、u16、u32 和 u64。<br><strong>sz：</strong>要读取的数组元素数量。<br><strong>返回值：</strong>0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<h5 id="of-property-read-u8-of-property-read-u16-of-property-read-u32-of-property-read-u64"><a href="#of-property-read-u8-of-property-read-u16-of-property-read-u32-of-property-read-u64" class="headerlink" title="of_property_read_u8 of_property_read_u16 of_property_read_u32 of_property_read_u64"></a>of_property_read_u8 of_property_read_u16 of_property_read_u32 of_property_read_u64</h5><p>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，分别用于读取 u8、u16、u32 和 u64 类型属性值，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u8 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u16 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u32 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u64 *out_value)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_value：</strong>读取到的数组值。<br><strong>返回值：</strong>0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p>
<h5 id="of-property-read-string"><a href="#of-property-read-string" class="headerlink" title="of_property_read_string"></a>of_property_read_string</h5><p>of_property_read_string 函数用于读取属性中字符串值，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_string</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **out_string)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_string：</strong>读取到的字符串值。<br><strong>返回值：</strong>0，读取成功，负值，读取失败。</p>
<h5 id="of-n-addr-cells"><a href="#of-n-addr-cells" class="headerlink" title="of_n_addr_cells"></a>of_n_addr_cells</h5><p>of_n_addr_cells 函数用于获取#address-cells 属性值，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_addr_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>返回值：</strong>获取到的#address-cells 属性值。</p>
<h5 id="of-n-size-cells"><a href="#of-n-size-cells" class="headerlink" title="of_n_size_cells"></a>of_n_size_cells</h5><p>of_size_cells 函数用于获取#size-cells 属性值，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_size_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>返回值：</strong>获取到的#size-cells 属性值。</p>
<h4 id="其他常用的OF函数"><a href="#其他常用的OF函数" class="headerlink" title="其他常用的OF函数"></a>其他常用的OF函数</h4><h5 id="of-device-is-compatible"><a href="#of-device-is-compatible" class="headerlink" title="of_device_is_compatible"></a>of_device_is_compatible</h5><p>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_device_is_compatible</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *device, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compat)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>device：</strong>设备节点。<br><strong>compat：</strong>要查看的字符串。<br><strong>返回值：</strong>0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，节点的 compatible属性中包含 compat 指定的字符串。</p>
<h5 id="of-get-address"><a href="#of-get-address" class="headerlink" title="of_get_address"></a>of_get_address</h5><p>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性值，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> __be32 *<span class="hljs-title function_">of_get_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">int</span> index, u64 *size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>index：</strong>要读取的地址标号。<br><strong>size：</strong>地址长度。<br><strong>flags：</strong>参数，比如 IORESOURCE_IO、IORESOURCE_MEM 等<br><strong>返回值：</strong>读取到的地址数据首地址，为 NULL 的话表示读取失败。</p>
<h5 id="of-translate-address"><a href="#of-translate-address" class="headerlink" title="of_translate_address"></a>of_translate_address</h5><p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u64 <span class="hljs-title function_">of_translate_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">const</span> __be32 *in_addr)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>in_addr：</strong>要转换的地址。<br><strong>返回值：</strong>得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</p>
<h5 id="of-address-to-resource"><a href="#of-address-to-resource" class="headerlink" title="of_address_to_resource"></a>of_address_to_resource</h5><p>IIC、SPI、GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间，Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息，resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.4.1 resource 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><br>    <span class="hljs-type">resource_size_t</span> start;<br>    <span class="hljs-type">resource_size_t</span> end;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对于 32 位的 SOC 来说，resource_size_t 是 u32 类型的。其中 start 表示开始地址，end 表示结束地址，name 是这个资源的名字，flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.4.2 资源标志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PREFETCH 0x00002000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_READONLY 0x00004000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_STARTALIGN 0x00080000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM_64 0x00100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_WINDOW 0x00200000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MUXED 0x00400000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DISABLED 0x10000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_UNSET 0x20000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_AUTO 0x40000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUSY 0x80000000</span><br></code></pre></td></tr></table></figure>

<p>大 家 一 般 最 常 见 的 资 源 标 志 就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ 等。接下来我们回到 of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型，函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_address_to_resource</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,  <span class="hljs-type">int</span> index, <span class="hljs-keyword">struct</span> resource *r)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>index：</strong>地址资源标号。<br><strong>r：</strong>得到的 resource 类型的资源值。<br><strong>返回值：</strong>0，成功；负值，失败。</p>
<h5 id="of-iomap"><a href="#of-iomap" class="headerlink" title="of_iomap"></a>of_iomap</h5><p>of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。当然了，你也可以使用 ioremap 函数来完成物理地址到虚拟地址的内存映射，只是在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段，of_iomap 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __iomem *<span class="hljs-title function_">of_iomap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">int</span> index)</span><br></code></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>index：</strong>reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。<br><strong>返回值：</strong>经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</p>
<p>关于设备树常用的 OF 函数就先讲解到这里，Linux 内核中关于设备树的 OF 函数不仅仅只有前面讲的这几个，还有很多 OF 函数我们并没有讲解，这些没有讲解的 OF 函数要结合具体的驱动，比如获取中断号的 OF 函数、获取 GPIO 的 OF 函数等等。</p>
<p>关于设备树就讲解到这里，关于设备树我们重点要了解一下几点内容：</p>
<ul>
<li>DTS、DTB 和 DTC 之间的区别，如何将.dts 文件编译为.dtb 文件。</li>
<li>设备树语法，这个是重点，因为在实际工作中我们是需要修改设备树的。</li>
<li>设备树的几个特殊子节点。</li>
<li>关于设备树的 OF 操作函数，也是重点，因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数。</li>
</ul>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.yuanzige.com/">www.yuanzige.com</a></li>
<li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/device-tree/" class="category-chain-item">device tree</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/device-tree/" class="print-no-link">#device tree</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>device tree</div>
      <div>https://tomwithkernel.github.io/devicetree/linux设备树/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tom</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月21日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年5月13日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/i2c/i2c%E9%A9%B1%E5%8A%A8/" title="I2C">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">I2C</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/platform/platform%E6%A1%86%E6%9E%B6/" title="platform框架">
                        <span class="hidden-mobile">platform框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","appKey":"jxVWH2hG2DLvf0KjiGZ93acw","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://tomwithkernel.github.io/" target="_blank" rel="nofollow noopener"><span>Tom</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/TomWithKernel/kernel" target="_blank" rel="nofollow noopener"><span>repository</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
