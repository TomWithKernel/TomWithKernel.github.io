

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/tom.png">
  <link rel="icon" href="/img/tom.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tom">
  <meta name="keywords" content="">
  
    <meta name="description" content="文章介绍了USB基本常识，USB硬件框架，USB子系统，包括如何传输，以及相关描述符的使用方法，USB hub以及USB设备插入检测等等">
<meta property="og:type" content="article">
<meta property="og:title" content="USB">
<meta property="og:url" content="https://tomwithkernel.github.io/usb/usb/index.html">
<meta property="og:site_name" content="TomWithKernel&#39;s Blog">
<meta property="og:description" content="文章介绍了USB基本常识，USB硬件框架，USB子系统，包括如何传输，以及相关描述符的使用方法，USB hub以及USB设备插入检测等等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/a.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/b.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/c.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/d.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/e.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/f.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/g.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/h.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/i.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/j.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/k.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/l.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/m.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/n.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/o.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/p.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/q.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/r.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/s.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/t.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/u.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/v.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/w.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/x.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/usb.png">
<meta property="og:image" content="https://tomwithkernel.github.io/usb/usb/usb_intf_image.png">
<meta property="article:published_time" content="2024-05-18T02:09:00.000Z">
<meta property="article:modified_time" content="2025-06-06T01:39:16.953Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="usb">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tomwithkernel.github.io/usb/usb/a.png">
  
  
  
  <title>USB - TomWithKernel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">
<link rel="stylesheet" href="/css/selection.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tomwithkernel.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","app_key":"jxVWH2hG2DLvf0KjiGZ93acw","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TomWithKernel&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="USB"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-18 10:09" pubdate>
          2024年5月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          396 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">USB</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h1><h2 id="USB-简介"><a href="#USB-简介" class="headerlink" title="USB 简介"></a>USB 简介</h2><h3 id="什么是USB"><a href="#什么是USB" class="headerlink" title="什么是USB"></a>什么是USB</h3><p>USB 全称为 Universal Serial Bus，翻译过来就是通用串行总线。由英特尔与众多电脑公司提出来，用于规范电脑与外部设备的连接与通讯。目前 USB 接口已经得到了大范围的应用，已经是电脑、手机等终端设备的必配接口，甚至取代了大量的其他接口。比如最新的智能手机均采用 USB Typec 取代了传统的 3.5mm 耳机接口，苹果最新的 MacBook 只有 USB Typec 接口，至于其他的 HDMI、网口等均可以通过 USB Typec 扩展坞来扩展。<br>按照大版本划分，USB 目前可以划分为 USB1.0、USB2.0、USB3.0 以及即将到来的 USB4.0。</p>
<p><strong>USB1.0：</strong>USB 规范于 1995 年第一次发布，由 Inter、IBM、Microsoft 等公司组成的 USB-IF(USB Implement Forum)组织提出。USB-IF 于 1996 年正式发布USB1.0，理论速度为 1.5Mbps。1998 年 USBIF 在 USB1.0 的基础上提出了 USB1.1 规范。</p>
<p><strong>USB2.0：</strong>USB2.0 依旧由 Inter、IBM、Microsoft 等公司提出并发布，USB2.0 分为两个版本:Full-Speed 和 High-Speed，也就是全速(FS)和高速(HS)。USB2.0 FS 的速度为 12Mbps，USB2.0 HS 速度为 480Mbps。目前大多数单片机以及低端 Cortex-A 芯片配置的都是 USB2.0 接口，比如 STM32 和 ALPHA 开发板所使用的 I.MX6ULL。USB2.0 全面兼容 USB1.0 标准。</p>
<p><strong>USB3.0：</strong>USB3.0 同样有 Inter 等公司发起的，USB3.0 最大理论传输速度为 5.0Gbps，USB3.0引入了全双工数据传输，USB2.0 的 480Mbps 为半双工。USB3.0 中两根线用于发送数据，另外两根用于接收数据。在 USB3.0 的基础上又提出了 USB3.1、USB3.2 等规范，USB3.1 理论传输速度提升到了 10Gbps，USB3.2 理论传输速度为 20Gbps。为了规范 USB3.0 标准的命名，USBIF 公布了最新的 USB 命名规范，原来的 USB3.0 和 USB3.1 命名将不会采用，所有的 3.0 版本的 USB 都命名为 USB3.2，以前的 USB3.0、USB3.1 和 USB3.2 分别叫做 USB3.2 Gen1、USB3.2 Gen2、USB3.2 Gen 2X2。</p>
<p><strong>USB4.0：</strong>目前还在标准定制中，目前还没有设备搭载，据说是在 Inter 的雷电接口上改进而来。USB4.0 的速度将提升到了 40Gbps，最高支持 100W 的供电能力，只需要一根线就可以完成数据传输与供电，极大的简化了设备之间的链接线数，期待 USB4.0 设备上市。</p>
<p>如果按照接口类型划分的话 USB 就要分为很多种了，最常见的就是 USB A 插头和插座，如图 67.1.1.1 所示：</p>
<img src="/usb/usb/a.png" srcset="/img/loading.gif" lazyload class title="a">

<p>使用过JLINK 调试器的朋友应该还见过USB B插头和插座，USB B插头和插座如图67.1.1.2所示：</p>
<img src="/usb/usb/b.png" srcset="/img/loading.gif" lazyload class title="b">

<p>USB 插头在不断的缩小，由此产生了 Mini USB 接口，正点原子的 I.MX6ULL-ALPHA 开发板使用的就是 Mini USB，Mini USB 插头和插座如图 67.1.1.3 所示：</p>
<img src="/usb/usb/c.png" srcset="/img/loading.gif" lazyload class title="c">

<p>比 Mini USB 更小的就是 Micro USB 接口了，以前的智能手机基本都是 Micro USB 接口的，Micro USB 插头和插座如图 67.1.1.4 所示：</p>
<img src="/usb/usb/d.png" srcset="/img/loading.gif" lazyload class title="d">

<p>现在最流行的就是 USB Typec 了，USB Typec 插头和插座如图 67.1.1.5 所示：</p>
<img src="/usb/usb/e.png" srcset="/img/loading.gif" lazyload class title="e">

<h3 id="USB-电气特性"><a href="#USB-电气特性" class="headerlink" title="USB 电气特性"></a>USB 电气特性</h3><p>此我们就以 Mini USB 为例讲解一下 USB 的基本电气属性。Mini USB 线一般都是一头为 USB A 插头，一头为 Mini USB插头。一共有四个触点，也就是 4 根线，这四根线的顺序如图 67.1.2.1 所示：</p>
<img src="/usb/usb/f.png" srcset="/img/loading.gif" lazyload class title="f">

<p>如图 67.1.2.1 所示，USB A 插头从左到右线序依次为 1,2,3,4，第 1 根线为 VBUS，电压为5V，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 GND。USB 采用差分信号来传输数据，因此有 D-和 D+两根差分信号线。大家仔细观察的话会发现 USB A 插头的 1 和 4 这两个触点比较长，2 和 3 这两个触点比较短。1 和 4 分别为 VBUS 和 GND，也就是供电引脚，当插入 USB 的时候会先供电，然后再接通数据线。拔出的时候先断开数据线，然后再断开电源线。<br>大家再观察一下 Mini USB 插头，会发现 Mini USB 插头有 5 个触点，也就是 5 根线，线序从左往右依次是 1-5。第 1 根线为 VCC(5V)，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 ID，第 5 根线为 GND。可以看出 Mini USB 插头相比 USB A 插头多了一个 ID 线，这个 ID 线用于实现 OTG 功能，通过 ID 线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。<br>USB 是一种支持热插拔的总线接口，使用差分线(D-和 D+)来传输数据，USB 支持两种供电模式：总线供电和自供电，总线供电就是由 USB 接口为外部设备供电，在 USB2.0 下，总线供电最大可以提供 500mA 的电流。</p>
<h3 id="USB-拓扑结构"><a href="#USB-拓扑结构" class="headerlink" title="USB 拓扑结构"></a>USB 拓扑结构</h3><p>USB 是主从结构的，也就是分为主机和从机两部分，一般主机叫做 Host，从机叫做 Device。主机就是提供 USB A 插座来连接外部的设备，比如电脑作为主机，对外提供 USB A 插座，我们可以通过 USB 线来连接一些 USB 设备，比如声卡、手机等。因此电脑带的 USB A 插座数量就决定了你能外接多少个 USB 设备，如果不够用的话我们可以购买 USB 集线器来扩展电脑的USB 插口，USB 集线器也叫做 USB HUB，USB HUB 如图 67.1.3.1 所示：</p>
<img src="/usb/usb/g.png" srcset="/img/loading.gif" lazyload class title="g">

<p>图 67.1.3.1 是一个一拖四的 USB HUB，也就是将一个 USB 接口扩展为 4 个。主机一般会带几个原生的 USB 主控制器，比如 I.MX6ULL 就有两个原生的 USB 主控制器，因此 I.MX6ULL对外提供两个 USB 接口，这两个接口肯定不够用，正点原子的 ALPHA 开发板上有 4 个 HOST接口，其中一路是 USB1 的 OTG 接口，其他的三路就是 USB2 通过 USB HUB 芯片扩展出来的，稍后我们会讲解其原理图。<br>虽然我们可以对原生的 USB 口数量进行扩展，但是我们不能对原生 USB 口的带宽进行扩展，比如 I.MX6ULL 的两个原生 USB 口都是 USB2.0 的，带宽最大为 480Mbps，因此接到下面的的所有 USB 设备总带宽最大为 480Mbps。</p>
<p>USB 只能主机与设备之间进行数据通信，USB 主机与主机、设备与设备之间是不能通信的。因此两个正常通信的 USB 接口之间必定有一个主机，一个设备。为此使用了不同的插头和插座来区分主机与设备，比如主机提供 USB A 插座，从机提供 Mini USB、Micro USB 等插座。在一个 USB 系统中，仅有一个 USB 主机，但是可以有多个 USB 设备，包括 USB 功能设备和 USB HUB，最多支持 127 个设备。一个 USB 主控制器支持 128 个地址，地址 0 是默认地址，只有在设备枚举的时候才会使用，地址 0 不会分配给任何一个设备。所以一个 USB 主控制器最多可以分配 127 个地址。整个 USB 的拓扑结构就是一个分层的金字塔形，如图 67.1.3.2 所示(参考自USB2.0 协议中文版.pdf)：</p>
<img src="/usb/usb/h.png" srcset="/img/loading.gif" lazyload class title="h">

<p>图 67.1.3.2 中可以看出从 Root Hub 开始，一共有 7 层，金字塔顶部是 Root Hub，这个是USB 控制器内部的。图中的 Hub 就是连接的 USB 集线器，Func 就是具体的 USB 设备。<br>USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个特定的端点。</p>
<h3 id="什么是USB-OTG"><a href="#什么是USB-OTG" class="headerlink" title="什么是USB OTG"></a>什么是USB OTG</h3><p>前面我们讲了，USB 分为 HOST(主机)和从机(或 DEVICE)，有些设备可能有时候需要做HOST，有时候又需要做 DEVICE，配两个 USB 口当然可以实现，但是太浪费资源了。如果一个 USB 接口既可以做 HOST 又可以做 DEVICE 那就太好了，使用起来就方便很多。为此，USB OTG 应运而生，OTG 是 On-The-Go 的缩写，支持 USB OTG 功能的 USB 接口既可以做 HOST，也可以做 DEVICE。那么问题来了，一个 USB 接口如何知道应该工作在 HOST 还是 DEVICE呢？这里就引入了 ID 线这个概念，前面讲解 USB 电气属性的时候已经说过了，Mini USB 插头有 5 根线，其中一条就是 ID 线。ID 线的高低电平表示 USB 口工作在 HOST 还是 DEVICE 模式：</p>
<p><strong>ID&#x3D;1：</strong>OTG 设备工作在从机模式。</p>
<p><strong>ID&#x3D;0：</strong>OTG 设备工作在主机模式。</p>
<p>支持 OTG 模式的 USB 接口一般都是那些带有 ID 线的接口，比如 I.MX6ULL-ALPHA 开发板的 USB_OTG 接口就是支持 OTG 模式的，USB_OTG 连接到了I.MX6ULL 的USB1 接口上。如果只有一个 Mini USB 或者 Type-C USB 接口的话如果要使用 OTG 的主机模式，那么就需要一根 OTG 线，Mini USB 的 OTG 线如图 67.1.4.1 所示：</p>
<img src="/usb/usb/i.png" srcset="/img/loading.gif" lazyload class title="i">

<p>Type-C USB OTG 线如图 67.1.4.2 所示：</p>
<img src="/usb/usb/j.png" srcset="/img/loading.gif" lazyload class title="j">

<p>可以看出，不管是 Mini USB OTG 还是 Type-C USB OTG 线，一头都是 USB A 插座，另外一头是 Mini USB 或者 Type-C USB 插头，将 Mini USB 或者 Type-C USB 插头插入机器的 MiniUSB 或 Type-C 接口上，需要连接的 USB 设备插到另一端的 USB A 插座上，比如 U 盘啥的。USB OTG 线会将 ID 线拉低，这样机器就知道自己要做为一个主机，用来连接外部的从机设备(U 盘)。</p>
<h3 id="OHCI-UHCI-EHCI-XHCI"><a href="#OHCI-UHCI-EHCI-XHCI" class="headerlink" title="OHCI UHCI EHCI XHCI"></a>OHCI UHCI EHCI XHCI</h3><p><strong>OHCI：</strong>全称为 Open Host Controller Interface，这是一种 USB 控制器标准，厂商在设计 USB控制器的时候需要遵循此标准，用于 USB1.1 标准。OHCI 不仅仅用于 USB，也支持一些其他的接口，比如苹果的 Firewire 等，OHCI 由于硬件比较难，所以软件要求就降低了，软件相对来说比较简单。OHCI 主要用于非 X86 的 USB，比如扩展卡、嵌入式 USB 控制器。</p>
<p><strong>UHCI：</strong>全称是 Universal Host Controller Interface，UHCI 是 Inter 主导的一个用于 USB1.0&#x2F;1.1的标准，与 OHCI 不兼容。与 OHCI 相比 UHCI 硬件要求低，但是软件要求相应就高了，因此硬件成本上就比较低。</p>
<p><strong>EHCI：</strong>全称是 Enhanced Host Controller Interface，是 Inter 主导的一个用于 USB2.0 的 USB控制器标准。EHCI 仅提供USB2.0 的高速功能，至于全速和低速功能就由 OHCI 或 UHCI 来提供。</p>
<p><strong>xHCI：</strong>全称是 eXtensible Host Controller Interface，是目前最流行的 USB3.0 控制器标准，在速度、能效和虚拟化等方面比前三个都有较大的提高。xHCI 支持所有速度种类的 USB 设备，xHCI 出现的目的就是为了替换前面三个。</p>
<h3 id="USB-协议简析"><a href="#USB-协议简析" class="headerlink" title="USB 协议简析"></a>USB 协议简析</h3><h4 id="USB-描述符"><a href="#USB-描述符" class="headerlink" title="USB 描述符"></a>USB 描述符</h4><p>顾名思义，USB 描述符就是用来描述 USB 信息的，描述符就是一串按照一定规则构建的字符串，USB 设备使用描述符来向主机报告自己的相关属性信息，常用的描述符如表 67.3.1.1所示：</p>
<img src="/usb/usb/k.png" srcset="/img/loading.gif" lazyload class title="k">

<p>我们依次来看一下表 67.3.1.1 中这 5 个描述符的含义：</p>
<h5 id="设备描述符"><a href="#设备描述符" class="headerlink" title="设备描述符"></a>设备描述符</h5><p>设备描述符用于描述 USB 设备的一般信息，USB 设备只有一个设备描述符。设备描述符里面记录了设备的 USB 版本号、设备类型、VID(厂商 ID)、PID(产品 ID)、设备序列号等。设备描述符结构如表 67.3.1.2 所示：</p>
<img src="/usb/usb/l.png" srcset="/img/loading.gif" lazyload class title="l">

<img src="/usb/usb/m.png" srcset="/img/loading.gif" lazyload class title="m">

<h5 id="配置描述符"><a href="#配置描述符" class="headerlink" title="配置描述符"></a>配置描述符</h5><p>设备描述符的 bNumConfigurations 域定义了一个 USB 设备的配置描述符数量，一个 USB设备至少有一个配置描述符。配置描述符描述了设备可提供的接口(Interface)数量、配置编号、供电信息等，配置描述符结构如表 67.3.1.3 所示：</p>
<img src="/usb/usb/n.png" srcset="/img/loading.gif" lazyload class title="n">

<h5 id="字符串描述符"><a href="#字符串描述符" class="headerlink" title="字符串描述符"></a>字符串描述符</h5><p>字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都必须为 0，字符串描述符结构如表 67.3.1.4 所示：</p>
<img src="/usb/usb/o.png" srcset="/img/loading.gif" lazyload class title="o">

<p>wLANGID[0]-wLANGID[x] 指明了设备支持的语言，具体含义要查阅文档《USB_LANGIDs.pdf 》</p>
<p>主机会再次根据自己所需的语言向设备请求字符串描述符，这次会主机会指明要得到的字符串索引值和语言。设备返回 Unicode 编码的字符串描述符，结构如表 67.3.1.5 所示：</p>
<img src="/usb/usb/p.png" srcset="/img/loading.gif" lazyload class title="p">

<h5 id="接口描述符"><a href="#接口描述符" class="headerlink" title="接口描述符"></a>接口描述符</h5><p>配置描述符中指定了该配置下的接口数量，可以提供一个或多个接口，接口描述符用于描述接口属性。接口描述符中一般记录接口编号、接口对应的端点数量、接口所述的类等，接口描述符结构如表 67.3.1.6 所示：</p>
<img src="/usb/usb/q.png" srcset="/img/loading.gif" lazyload class title="q">

<h5 id="端点描述符"><a href="#端点描述符" class="headerlink" title="端点描述符"></a>端点描述符</h5><p>接口描述符定义了其端点数量，端点是设备与主机之间进行数据传输的逻辑接口，除了端点 0 是双向端口，其他的端口都是单向的。端点描述符描述了传输类型、方向、数据包大小、端点号等信息，端点描述符结构如表 67.3.1.7 所示：</p>
<img src="/usb/usb/r.png" srcset="/img/loading.gif" lazyload class title="r">

<img src="/usb/usb/s.png" srcset="/img/loading.gif" lazyload class title="s">

<h4 id="USB-数据包类型"><a href="#USB-数据包类型" class="headerlink" title="USB 数据包类型"></a>USB 数据包类型</h4><p>USB 是串行通信，需要一位一位的去传输数据，USB 传输的时候先将原始数据进行打包，所以 USB 中传输的基本单元就是数据包。根据用途的不同，USB 协议定义了 4 种不同的包结构：令牌(Token)包、数据(Data)包、握手(Handshake)包和特殊(Special)包。这四种包通过包标识符 PID 来区分，PID 共有 8 位，USB 协议使用低 4 位 PID3-PID0，另外的高四位 PID7-PID4 是PID3-PID0 的取反，传输顺序是 PID0、PID1、PID2、PID3…PID7。令牌包的 PID1-0 为 01，数据包的 PID1-0 为 11，握手包的 PID1-0 为 10，特殊包的 PID1-0 为 00。每种类型的包又有多种具体的包，如表 67.3.3.1 所示：</p>
<img src="/usb/usb/t.png" srcset="/img/loading.gif" lazyload class title="t">

<p>一个完整的包分为多个域，所有的数据包都是以同步域(SYNC)开始，后面紧跟着包标识符(PID)，最终都以包结束(EOP)信号结束。不同的数据包中间位域不同，一般有包目标地址(ADDR)、包目标端点(ENDP)、数据、帧索引、CRC 等，这个要具体数据包具体分析。接下来简单看一下这些数据包的结构。</p>
<h5 id="令牌包"><a href="#令牌包" class="headerlink" title="令牌包"></a>令牌包</h5><p>令牌包结构如图 67.3.3.1 所示：</p>
<img src="/usb/usb/u.png" srcset="/img/loading.gif" lazyload class title="u">

<p>图 67.3.3.1 是一个 SETUP 令牌包结构，首先是 SYNC 同步域，包同步域为 00000001，也就是连续 7 个 0，后面跟一个 1，如果是高速设备的话就是 31 个 0 后面跟一个 1。紧跟着是 PID，这里是 SETUP 包，为 0XB4，大家可能会好奇为什么不是 0X2D(00101101)，0XB4 的原因如下：</p>
<p>①、SETUP 包的 PID3-PID0 为 1101，因此对应的 PID7-PID4 就是 0010。</p>
<p>②、PID 传输顺序为 PID0、PID1、PID2…PID7，因此按照传输顺序排列的话此处的 PID 就是 10110100&#x3D;0XB4，并不是 0X2D。</p>
<p>PID 后面跟着地址域(ADDR)和端点域(ENDP)，为目标设备的地址和端点号。CRC5 域是 5位 CRC 值，是 ADDR 和 ENDP 这两个域的校验值。最后就是包结束域(EOP)，标记本数据包结束。其他令牌包的结构和 SETUP 基本类似，只是 SOF 令包中间没有 ADDR 和 ENDP 这两个域，而是只有一个 11 位的帧号域。</p>
<h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><p>数据包结构如图 67.3.3.2 所示：</p>
<img src="/usb/usb/v.png" srcset="/img/loading.gif" lazyload class title="v">

<p>数据包比较简单，同样的，数据包从 SYNC 同步域开始，然后紧跟着是 PID，这里就是DATA0，PID 值为 0XC3。接下来就是具体的数据，数据完了以后就是 16 位的 CRC 校验值，最后是 EOP。</p>
<h5 id="握手包"><a href="#握手包" class="headerlink" title="握手包"></a>握手包</h5><p>握手包结构如图 67.3.3.3 所示：</p>
<img src="/usb/usb/w.png" srcset="/img/loading.gif" lazyload class title="w">

<p>图 67.3.3.3 是 ACK 握手包，很简单，首先是 SYNC 同步域，然后就是 ACK 包的 PID，为0X4B，最后就是 EOP。其他的 NAK、STALL、NYET 和 ERR 握手包结构都是一样的，只是其中的 PID 不同而已。</p>
<h4 id="USB-传输类型"><a href="#USB-传输类型" class="headerlink" title="USB 传输类型"></a>USB 传输类型</h4><p>在端点描述符中 bmAttributes 指定了端点的传输类型，一共有 4 种，本节我们来看一下这四种传输类型的区别。</p>
<h5 id="控制传输"><a href="#控制传输" class="headerlink" title="控制传输"></a>控制传输</h5><p>控制传输一般用于特定的请求，比如枚举过程就是全部由控制传输来完成的，比如获取描述符、设置地址、设置配置等。控制传输分为三个阶段：建立阶段(SETUP)、数据阶段(DATA)和状态阶段(STATUS)，其中数据阶段是可选的。建立阶段使用 SETUP 令牌包，SETUP 使用DATA0 包。数据阶段是 0 个、1 个或多个输入(IN)&#x2F;输出(OUT)事务，数据阶段的所有输入事务必须是同一个方向的，比如都为 IN 或都为 OUT。数据阶段的第一个数据包必须是 DATA1，每次正确传输以后就在 DATA0 和 DATA1 之间进行切换。数据阶段完成以后就是状态阶段，状态阶段的传输方向要和数据阶段相反，比如数据阶段为 IN 的话状态阶段就要为 OUT，状态阶段使用 DATA1 包。比如一个读控制传输格式如图 67.3.4.1 所示：</p>
<img src="/usb/usb/x.png" srcset="/img/loading.gif" lazyload class title="x">

<h5 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h5><p>同步传输用于周期性、低时延、数据量大的场合，比如音视频传输，这些场合对于时延要求很高，但是不要求数据 100%正确，允许有少量的错误。因此，同步传输没有握手阶段，即使数据传输出错了也不会重传。</p>
<h5 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h5><p>提起“批量”，我们第一反应就是“多”、“大”等，因此，批量传输就是用于大批量传输大块数据的，这些数据对实时性没有要求，比如 MSD 类设备(存储设备)，U 盘之类的。批量传输分为批量读(输入)和批量写(输出)，如果是批量读的话第一阶段的 IN 令牌包，如果是批量写那么第一阶段就是 OUT 令牌包。</p>
<p>我们就以批量写为例简单介绍一下批量传输过程：</p>
<p>①、主机发出 OUT 令牌包，令牌包里面包含了设备地址、端点等信息。</p>
<p>②、如果 OUT 令牌包正确的话，也就是设备地址和端点号匹配，主机就会向设备发送一个数据(DATA)包，发送完成以后主机进入接收模式，等待设备返回握手包，一切都正确的话设备就会向主机返回一个 ACK 握手信号。</p>
<p>批量读的过程刚好相反：</p>
<p>①、主机发出 IN 令牌包，令牌包里面包含了设备地址、端点等信息。发送完成以后主机就进入到数据接收状态，等待设备返回数据。</p>
<p>②、如果 IN 令牌包正确的话，设备就会将一个 DATA 包放到总线上发送给主机。主机收到这个 DATA 包以后就会向设备发送一个 ACK 握手信号。</p>
<h5 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h5><p>这里的中断传输并不是我们传统意义上的硬件中断，而是一种保持一定频率的传输，中断传输适用于传输数据量小、具有周期性并且要求响应速度快的数据，比如键盘、鼠标等。中断的端点会在端点描述符中报告自己的查询时间间隔，对于时间要求严格的设备可以采用中断传输。</p>
<h4 id="USB-枚举"><a href="#USB-枚举" class="headerlink" title="USB 枚举"></a>USB 枚举</h4><p>当 USB 设备与 USB 主机连接以后主机就会对 USB 设备进行枚举，通过枚举来获取设备的描述符信息，主机得到这些信息以后就知道该加载什么样的驱动、如何进行通信等。USB 枚举过程如下：</p>
<p>①、第一回合，当 USB 主机检测到 USB 设备插入以后主机会发出总线复位信号来复位设备。USB 设备复位完成以后地址为 0，主机向地址 0 的端点 0 发送数据，请求设备的描述符。设备得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。</p>
<p>②、第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0 的端点 0 发送设置地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0 字节状态数据包，表明设备已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到主机发送的 ACK 包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。</p>
<p>③、第三回合，主机向新的设备地址端点 0 发送请求设备描述符数据包，这一次主机要获取整个设备描述符，一共是 18 个字节。</p>
<p>④、和第③步类似，接下来依次获取配置描述符、配置集合、字符串描述符等等。</p>
<h2 id="USB子系统"><a href="#USB子系统" class="headerlink" title="USB子系统"></a>USB子系统</h2><h3 id="USB子系统框架"><a href="#USB子系统框架" class="headerlink" title="USB子系统框架"></a>USB子系统框架</h3><img src="/usb/usb/usb.png" srcset="/img/loading.gif" lazyload class title="usb"> 

<ul>
<li>USB设备驱动：用于和枚举到的USB设备进行绑定，完成特定的功能</li>
<li>USB Core：用于内核USB总线的初始化及USB相关API，为设备驱动和HCD的交互提供桥梁</li>
<li>USB主机控制器HCD：完成主机控制器的初始化以及数据的传输，并监测外部设备插入，完成设备枚举</li>
</ul>
<h3 id="USB传输类型"><a href="#USB传输类型" class="headerlink" title="USB传输类型"></a>USB传输类型</h3><ul>
<li>控制传输：控制传输是双向传输，数据量通常比较小，主要指由USB总线驱动程序用来进行查询、配置以及给USB设备发送通用的命令。控制传输典型地用在主计算机和USB外设之间的端点0(Endpoint 0)之间的传输，但是指定供应商的控制传输可能用到其它的端点。比如：USB设备的识别过程。</li>
<li>批量传输：主要应用在数据大量传输，同时又没有带宽和间隔时间要求的情况下，进行可靠传输。比如：U盘拷贝数据。</li>
<li>中断传输：中断传输主要用于定时查询设备是否有中断数据要传输，设备的端点模式器的结构决定了它的查询频率，从1到255ms之间。这种传输方式典型的应用在少量的、分散的、不可预测数据的传输，比如，键盘和鼠标就属于这一类型。中断传输是单向的并且对于host来说只有输入的方式。</li>
<li>实时传输：实时传输提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传输率的即时应用中。比如：USB摄像头。</li>
</ul>
<h3 id="USB设备描述符"><a href="#USB设备描述符" class="headerlink" title="USB设备描述符"></a>USB设备描述符</h3><img src="/usb/usb/usb_intf_image.png" srcset="/img/loading.gif" lazyload class title="usb_intf">  

<ul>
<li>一个USB设备描述符中可以有多个配置描述符，即USB设备可以有多种配置；一个配置描述符中可以有多个接口描述符，即USB设备可以支持多种功能（接口）；一个接口描述符中可以有多个端点描述符。</li>
<li>一设备至少要包含设备描述符、配置描述符和接口描述符，如果USB设备没有端点描述符，则它仅仅用默认管道与主机进行数据传输。</li>
<li>接口，表示逻辑上的设备，比如USB声卡可以分为接口1-录音设备，接口2-播放设备。</li>
<li>访问设备时，即访问某个接口，接口表示逻辑设备。</li>
<li>传输数据时，即读写某个端口，端口是数据通道。</li>
</ul>
<h4 id="设备描述符-1"><a href="#设备描述符-1" class="headerlink" title="设备描述符"></a>设备描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_DEVICE: Device descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType; <span class="hljs-comment">//描述符类型 （此处应为0x01，即设备描述符）</span><br><br>    __le16 bcdUSB; <span class="hljs-comment">//usb版本号 200 -&gt; USB2.0</span><br>    __u8  bDeviceClass; <span class="hljs-comment">//设备类 </span><br>    __u8  bDeviceSubClass; <span class="hljs-comment">//设备类子类</span><br>    __u8  bDeviceProtocol; <span class="hljs-comment">//设备协议，以上三点都是USB官方定义</span><br>    __u8  bMaxPacketSize0; <span class="hljs-comment">//端点0最大包大小 （只能为8,16,32,64）</span><br>    __le16 idVendor; <span class="hljs-comment">//厂家id</span><br>    __le16 idProduct; <span class="hljs-comment">//产品id</span><br>    __le16 bcdDevice; <span class="hljs-comment">//设备出厂编号</span><br>    __u8  iManufacturer; <span class="hljs-comment">//描述厂商信息的字符串描述符的索引值</span><br>    __u8  iProduct; <span class="hljs-comment">//描述产品信息的字串描述符的索引值</span><br>    __u8  iSerialNumber; <span class="hljs-comment">//描述设备序列号信息的字串描述符的索引值 </span><br>    __u8  bNumConfigurations; <span class="hljs-comment">//可能的配置描述符的数目</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure>

<p> USB设备描述符位于USB设备结构体usb_device中的成员descriptor中。同样地,配置、接口、端点描述符也是位于USB配置、接口、端点结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_device - kernel&#x27;s representation of a USB device</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> &#123;</span><br>	<span class="hljs-type">int</span>		devnum;                    <span class="hljs-comment">// 设备编号；在USB总线上的地址</span><br>	<span class="hljs-type">char</span>		devpath[<span class="hljs-number">16</span>];              <span class="hljs-comment">// 设备ID字符串，用于消息（例如，/port/...）</span><br>	u32		route;                    <span class="hljs-comment">// 树拓扑的十六进制字符串，用于xHCI</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_state</span>	<span class="hljs-title">state</span>;</span>                <span class="hljs-comment">// 设备状态：配置、未连接等</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span>	<span class="hljs-title">speed</span>;</span>                <span class="hljs-comment">// 设备速度：高/全/低（或错误）</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		rx_lanes;              <span class="hljs-comment">// 使用中的接收通道数量，USB 3.2添加了双通道支持</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		tx_lanes;              <span class="hljs-comment">// 使用中的传输通道数量，USB 3.2添加了双通道支持</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_tt</span>	*<span class="hljs-title">tt</span>;</span>                    <span class="hljs-comment">// 事务转换器信息；用于低/全速设备、高速集线器</span><br>	<span class="hljs-type">int</span>		ttport;                   <span class="hljs-comment">// 在事务转换器集线器上的设备端口</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> toggle[<span class="hljs-number">2</span>];                   <span class="hljs-comment">// 每个端点一个位，([0] = 输入， [1] = 输出) 端点</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">parent</span>;</span>                <span class="hljs-comment">// 我们的集线器，除非我们是根</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_bus</span> *<span class="hljs-title">bus</span>;</span>                      <span class="hljs-comment">// 我们所属的总线</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> <span class="hljs-title">ep0</span>;</span>             <span class="hljs-comment">// 端点0数据（默认控制管道）</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                        <span class="hljs-comment">// 通用设备接口</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> <span class="hljs-title">descriptor</span>;</span>  <span class="hljs-comment">// USB设备描述符</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_bos</span> *<span class="hljs-title">bos</span>;</span>                 <span class="hljs-comment">// USB设备BOS描述符集</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">config</span>;</span>           <span class="hljs-comment">// 设备的所有配置</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">actconfig</span>;</span>        <span class="hljs-comment">// 活动配置</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_in</span>[16];</span>      <span class="hljs-comment">// 输入端点数组</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_out</span>[16];</span>     <span class="hljs-comment">// 输出端点数组</span><br><br>	<span class="hljs-type">char</span> **rawdescriptors;                    <span class="hljs-comment">// 每个配置的原始描述符</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bus_mA;                    <span class="hljs-comment">// 总线可用电流</span><br>	u8 portnum;                               <span class="hljs-comment">// 父端口号（起始值为1）</span><br>	u8 level;                                 <span class="hljs-comment">// USB集线器祖先的数量</span><br>	u8 devaddr;                               <span class="hljs-comment">// 设备地址，XHCI：由硬件分配，其他：与devnum相同</span><br><br>	<span class="hljs-type">unsigned</span> can_submit:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 可以提交URB</span><br>	<span class="hljs-type">unsigned</span> persist_enabled:<span class="hljs-number">1</span>;               <span class="hljs-comment">// 启用USB_PERSIST</span><br>	<span class="hljs-type">unsigned</span> reset_in_progress:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 设备正在复位</span><br>	<span class="hljs-type">unsigned</span> have_langid:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// string_langid是否有效</span><br>	<span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 策略已允许我们使用它</span><br>	<span class="hljs-type">unsigned</span> authenticated:<span class="hljs-number">1</span>;                 <span class="hljs-comment">// 通过加密认证</span><br>	<span class="hljs-type">unsigned</span> wusb:<span class="hljs-number">1</span>;                          <span class="hljs-comment">// 设备是无线USB</span><br>	<span class="hljs-type">unsigned</span> lpm_capable:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// 设备支持LPM</span><br>	<span class="hljs-type">unsigned</span> usb2_hw_lpm_capable:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 设备可以执行USB2硬件LPM</span><br>	<span class="hljs-type">unsigned</span> usb2_hw_lpm_besl_capable:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 设备可以执行USB2硬件BESL LPM</span><br>	<span class="hljs-type">unsigned</span> usb2_hw_lpm_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB2硬件LPM</span><br>	<span class="hljs-type">unsigned</span> usb2_hw_lpm_allowed:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 用户空间允许启用USB 2.0 LPM</span><br>	<span class="hljs-type">unsigned</span> usb3_lpm_u1_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U1 LPM</span><br>	<span class="hljs-type">unsigned</span> usb3_lpm_u2_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U2 LPM</span><br>	<span class="hljs-type">int</span> string_langid;                        <span class="hljs-comment">// 字符串的语言ID</span><br><br>	<span class="hljs-comment">/* static strings from the device */</span><br>	<span class="hljs-type">char</span> *product;                            <span class="hljs-comment">// 如果存在，iProduct字符串（静态）</span><br>	<span class="hljs-type">char</span> *manufacturer;                       <span class="hljs-comment">// 如果存在，iManufacturer字符串（静态）</span><br>	<span class="hljs-type">char</span> *serial;                             <span class="hljs-comment">// 如果存在，iSerialNumber字符串（静态）</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">filelist</span>;</span>                <span class="hljs-comment">// 此设备打开的usbfs文件</span><br><br>	<span class="hljs-type">int</span> maxchild;                             <span class="hljs-comment">// 如果是集线器，端口数量</span><br><br>	u32 quirks;                               <span class="hljs-comment">// 设备的怪癖</span><br>	<span class="hljs-type">atomic_t</span> urbnum;                          <span class="hljs-comment">// 提交的URB数量</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> active_duration;            <span class="hljs-comment">// 设备未挂起的总时间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> connect_time;               <span class="hljs-comment">// 设备首次连接时间</span><br><br>	<span class="hljs-type">unsigned</span> do_remote_wakeup:<span class="hljs-number">1</span>;              <span class="hljs-comment">// 启用远程唤醒</span><br>	<span class="hljs-type">unsigned</span> reset_resume:<span class="hljs-number">1</span>;                  <span class="hljs-comment">// 需要复位而不是恢复</span><br>	<span class="hljs-type">unsigned</span> port_is_suspended:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 上游端口被挂起（L2或U3）</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wusb_dev</span> *<span class="hljs-title">wusb_dev</span>;</span>                <span class="hljs-comment">// 如果这是无线USB设备，则链接到设备的WUSB特定数据</span><br>	<span class="hljs-type">int</span> slot_id;                              <span class="hljs-comment">// xHCI分配的插槽ID</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_removable</span> <span class="hljs-title">removable</span>;</span>      <span class="hljs-comment">// 设备可以从此端口物理移除</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb2_lpm_parameters</span> <span class="hljs-title">l1_params</span>;</span>     <span class="hljs-comment">// USB2 L1 LPM状态的最佳努力服务延迟和L1超时</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u1_params</span>;</span>     <span class="hljs-comment">// USB3 U1 LPM状态的退出延迟和集线器启动的超时</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u2_params</span>;</span>     <span class="hljs-comment">// USB3 U2 LPM状态的退出延迟和集线器启动的超时</span><br>	<span class="hljs-type">unsigned</span> lpm_disable_count;               <span class="hljs-comment">// Ref计数用于usb_disable_lpm()和usb_enable_lpm()跟踪需要禁用USB 3.0链路电源管理的函数数量。该计数应仅由这些函数在持有带宽互斥锁时操作。</span><br><br>	u16 hub_delay;                            <span class="hljs-comment">// 缓存值，包括：</span><br>	                                          <span class="hljs-comment">// parent-&gt;hub_delay + wHubDelay + tTPTransmissionDelay (40ns)</span><br>	                                          <span class="hljs-comment">// 将用作SetIsochDelay请求的wValue。</span><br>	<span class="hljs-type">unsigned</span> use_generic_driver:<span class="hljs-number">1</span>;            <span class="hljs-comment">// 请求驱动程序核心使用通用驱动程序重新探测。</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="配置描述符-1"><a href="#配置描述符-1" class="headerlink" title="配置描述符"></a>配置描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_config_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//描述符类型（本结构体中固定为0x02)  </span><br><br>    __le16 wTotalLength; <span class="hljs-comment">//该配置下，信息的总长度（包括配置，接口，端点和设备类及厂商定义的描述符）</span><br>    __u8  bNumInterfaces; <span class="hljs-comment">//接口的个数</span><br>    __u8  bConfigurationValue; <span class="hljs-comment">//Set_Configuration命令所需要的参数值，用来选定此配置</span><br>    __u8  iConfiguration; <span class="hljs-comment">//描述该配置的字符串描述的索引值 </span><br>    __u8  bmAttributes;<span class="hljs-comment">//供电模式的选择  </span><br>    __u8  bMaxPower;<span class="hljs-comment">//设备从总线提取的最大电流</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure>

<h4 id="接口描述符-1"><a href="#接口描述符-1" class="headerlink" title="接口描述符"></a>接口描述符</h4><p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为“功能”更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> &#123;</span><br>    __u8  bLength;      <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//接口描述符的类型编号(0x04）</span><br><br>    __u8  bInterfaceNumber;  <span class="hljs-comment">//该接口的编号  </span><br>    __u8  bAlternateSetting; <span class="hljs-comment">//备用的接口描述符编号  </span><br>    __u8  bNumEndpoints; <span class="hljs-comment">//该接口使用的端点数，不包括端点0  </span><br>    __u8  bInterfaceClass; <span class="hljs-comment">//接口类</span><br>    __u8  bInterfaceSubClass; <span class="hljs-comment">//子类</span><br>    __u8  bInterfaceProtocol; <span class="hljs-comment">//协议</span><br>    __u8  iInterface;<span class="hljs-comment">//描述此接口的字串描述表的索引值  </span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure>

<p>它位于usb_interface-&gt;cur_altsetting-&gt;desc 这个成员结构体里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_interface - what usb device drivers talk to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface</span> &#123;</span><br>	<span class="hljs-comment">/* array of alternate settings for this interface,</span><br><span class="hljs-comment">	 * stored in no particular order */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">altsetting</span>;</span>              <span class="hljs-comment">// 备用设置的数组，无特定顺序</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">cur_altsetting</span>;</span>          <span class="hljs-comment">// 当前活动的备用设置</span><br>	<span class="hljs-type">unsigned</span> num_altsetting;                            <span class="hljs-comment">// 定义的备用设置数量</span><br><br>	<span class="hljs-comment">/* If there is an interface association descriptor then it will list</span><br><span class="hljs-comment">	 * the associated interfaces */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_assoc_descriptor</span> *<span class="hljs-title">intf_assoc</span>;</span>  <span class="hljs-comment">// 接口关联描述符</span><br><br>	<span class="hljs-type">int</span> minor;                                          <span class="hljs-comment">// 分配给此接口的次设备号</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_interface_condition</span> <span class="hljs-title">condition</span>;</span>             <span class="hljs-comment">// 绑定状态</span><br>	<span class="hljs-type">unsigned</span> sysfs_files_created:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// sysfs属性存在</span><br>	<span class="hljs-type">unsigned</span> ep_devs_created:<span class="hljs-number">1</span>;                         <span class="hljs-comment">// 端点伪设备存在</span><br>	<span class="hljs-type">unsigned</span> unregistering:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 注销中</span><br>	<span class="hljs-type">unsigned</span> needs_remote_wakeup:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// 驱动程序需要远程唤醒</span><br>	<span class="hljs-type">unsigned</span> needs_altsetting0:<span class="hljs-number">1</span>;                       <span class="hljs-comment">// 切换到备用设置0待处理</span><br>	<span class="hljs-type">unsigned</span> needs_binding:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 需要延迟解除绑定/重新绑定</span><br>	<span class="hljs-type">unsigned</span> resetting_device:<span class="hljs-number">1</span>;                        <span class="hljs-comment">// 复位后需要带宽分配</span><br>	<span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                              <span class="hljs-comment">// 接口授权</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                                  <span class="hljs-comment">// 接口特定的设备信息</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">usb_dev</span>;</span>                             <span class="hljs-comment">// 如果接口绑定到USB主设备号，则指向该设备的sysfs表示</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">reset_ws</span>;</span>                        <span class="hljs-comment">// 用于在原子上下文中复位的工作结构</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* host-side wrapper for one interface setting&#x27;s parsed descriptors */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> <span class="hljs-title">desc</span>;</span>  <span class="hljs-comment">// 接口描述符</span><br><br>	<span class="hljs-type">int</span> extralen;                          <span class="hljs-comment">// 额外描述符的长度</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *extra;                  <span class="hljs-comment">// 额外描述符</span><br><br>	<span class="hljs-comment">/* array of desc.bNumEndpoints endpoints associated with this</span><br><span class="hljs-comment">	 * interface setting.  these will be in no particular order.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">endpoint</span>;</span>    <span class="hljs-comment">// 该接口设置关联的端点数组，无特定顺序</span><br><br>	<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>;                          <span class="hljs-comment">// iInterface字符串，如果存在</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="端点描述符-1"><a href="#端点描述符-1" class="headerlink" title="端点描述符"></a>端点描述符</h4><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。<br>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_ENDPOINT: Endpoint descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> &#123;</span><br>    __u8  bLength;        <span class="hljs-comment">//端点描述符字节数大小（7个字节）</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//端点描述符类型编号（0x05) </span><br><br>    __u8  bEndpointAddress; <span class="hljs-comment">//此描述表所描述的端点的地址、方向 : </span><br>                            <span class="hljs-comment">// bit3~bit0:端点号，bit6~bit4:保留，</span><br>                            <span class="hljs-comment">// bit7:方向，如果是控制端点则忽略，0-输出端点（主机到设备）1-输入端点（设备到主机）</span><br>    __u8  bmAttributes; <span class="hljs-comment">// 端点特性，bit1~bit0 表示传输类型，其他位保留</span><br>                        <span class="hljs-comment">// 00-控制传输  01-实时传输   10-批量传输 11-中断传输</span><br>    __le16 wMaxPacketSize;  <span class="hljs-comment">//端点收、发的最大包大小</span><br>    __u8  bInterval; <span class="hljs-comment">// 中断传输模式中主机查询端点的时间间隔。</span><br>                     <span class="hljs-comment">// 对于实时传输的端点此域必需为1，表示周期为1ms。对于中断传输的端点此域值的范围为1ms到255ms</span><br><br>    <span class="hljs-comment">/* <span class="hljs-doctag">NOTE:</span>  these two are _only_ in audio endpoints. */</span><br>    <span class="hljs-comment">/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */</span><br>    __u8  bRefresh;<br>    __u8  bSynchAddress;<br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure>

<h4 id="字符串描述符-1"><a href="#字符串描述符-1" class="headerlink" title="字符串描述符"></a>字符串描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_string_descriptor</span> &#123;</span><br>    __u8  bLength;  <span class="hljs-comment">// 此描述表的字节数（bString域的数值N＋2）</span><br>    __u8  bDescriptorType; <span class="hljs-comment">// 字串描述表类型（此处应为0x03）</span><br><br>    __le16 wData[<span class="hljs-number">1</span>];        <span class="hljs-comment">/* UTF-16LE encoded */</span>  <br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure>

<h4 id="人机接口描述符"><a href="#人机接口描述符" class="headerlink" title="人机接口描述符"></a>人机接口描述符</h4><p>USB 设备中有一大类就是 HID 设备，即 Human Interface Devices，人机接口设备。这类设备包括鼠标、键盘等，主要用于人与计算机进行交互。 它是 USB 协议最早支持的一种设备类。 HID 设备可以作为低速、全速、高速设备用。由于 HID 设备要求用户输入能得到及时响应，故其传输方式通常采用中断方式。 在 USB 协议中， HID 设备的定义放置在接口描述符中， USB 的设备描述符和配置描述符中不包含 HID 设备的信息。因此，对于某些特定的 HID 设备，可以定义多个接口，只有其中一个接口为 HID 设备类即可。</p>
<h4 id="USB描述符类型值"><a href="#USB描述符类型值" class="headerlink" title="USB描述符类型值"></a>USB描述符类型值</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述符</th>
<th>类型值</th>
</tr>
</thead>
<tbody><tr>
<td>标准描述符</td>
<td>设备描述符</td>
<td>0x01</td>
</tr>
<tr>
<td></td>
<td>配置描述符</td>
<td>0x02</td>
</tr>
<tr>
<td></td>
<td>字符串描述符</td>
<td>0x03</td>
</tr>
<tr>
<td></td>
<td>接口描述符</td>
<td>0x04</td>
</tr>
<tr>
<td></td>
<td>端点描述符</td>
<td>0x05</td>
</tr>
<tr>
<td>类描述符</td>
<td>集线器类描述符</td>
<td>0x29</td>
</tr>
<tr>
<td></td>
<td>人机接口类描述符</td>
<td>0x21</td>
</tr>
<tr>
<td>厂商定义的描述符</td>
<td></td>
<td>0xff</td>
</tr>
</tbody></table>
<h3 id="USB的数据传输对象"><a href="#USB的数据传输对象" class="headerlink" title="USB的数据传输对象"></a>USB的数据传输对象</h3><p>端点，一个USB设备可以有多个端点，和主机间的数据传输称为到设备端点的数据传输。比如说，对于一个U盘，可以细分为两个端点，把数据写到U盘的端点1、从U盘的端点2读取数据。</p>
<h2 id="USB总线驱动框架"><a href="#USB总线驱动框架" class="headerlink" title="USB总线驱动框架"></a>USB总线驱动框架</h2><h3 id="USB-Core"><a href="#USB-Core" class="headerlink" title="USB Core"></a>USB Core</h3><p>初始化内核USB总线提供USB相关API，为设备驱动和HCD的交互提供桥梁。</p>
<blockquote>
<p>Linux启动阶段，通过<strong>subsys_initcall</strong>会完成USB Core的加载</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">subsys_initcall(usb_init);<br></code></pre></td></tr></table></figure>

<h4 id="usb-init"><a href="#usb-init" class="headerlink" title="usb_init"></a>usb_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">usb_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> retval;<br>	<span class="hljs-keyword">if</span> (usb_disabled()) &#123;<br>		pr_info(<span class="hljs-string">&quot;%s: USB support disabled\n&quot;</span>, usbcore_name);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	usb_init_pool_max();<br><br>	usb_debugfs_init();			<span class="hljs-comment">//用于调试USB的虚拟文件系统初始化</span><br><br>	usb_acpi_register();<br>	retval = bus_register(&amp;usb_bus_type);	<span class="hljs-comment">//USB总线的创建</span><br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> bus_register_failed;<br>	retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<span class="hljs-comment">//各个子系统往往是相互独立的，因此当总线出现变化之后，需要通知其他总线</span><br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> bus_notifier_failed;<br>	retval = usb_major_init();<br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> major_init_failed;<br>	retval = usb_register(&amp;usbfs_driver);	<span class="hljs-comment">//注册usbfs驱动</span><br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> driver_register_failed;<br>	retval = usb_devio_init();<br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> usb_devio_init_failed;<br>	retval = usb_hub_init();				<span class="hljs-comment">//初始化一个USB设备集线器，用来检测USB设备的连接和断开。</span><br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> hub_init_failed;<br>	retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<span class="hljs-comment">//USB通用设备驱动的注册</span><br>	<span class="hljs-keyword">if</span> (!retval)<br>		<span class="hljs-keyword">goto</span> out;<br><br>	usb_hub_cleanup();<br>hub_init_failed:<br>	usb_devio_cleanup();<br>usb_devio_init_failed:<br>	usb_deregister(&amp;usbfs_driver);<br>driver_register_failed:<br>	usb_major_cleanup();<br>major_init_failed:<br>	bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br>bus_notifier_failed:<br>	bus_unregister(&amp;usb_bus_type);<br>bus_register_failed:<br>	usb_acpi_unregister();<br>	usb_debugfs_cleanup();<br>out:<br>	<span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注册USB总线"><a href="#注册USB总线" class="headerlink" title="注册USB总线"></a>注册USB总线</h4><p>USB是基于总线-驱动-设备模型的框架，其初始化阶段一个重点任务就是完成USB总线的创建。usb_bus_type提供了驱动和设备匹配的匹配函数，后面注册设备和驱动时会调用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = bus_register(&amp;usb_bus_type);<br><span class="hljs-keyword">if</span> (retval) <br>    <span class="hljs-keyword">goto</span> bus_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">usb_bus_type</span> =</span> &#123;<br>	.name =		<span class="hljs-string">&quot;usb&quot;</span>,<br>	.match =	usb_device_match,	<span class="hljs-comment">//只要总线上出现新的设备，match函数就会尝试为其匹配合适的驱动，每一个设备都要感谢match函数</span><br>	.uevent =	usb_uevent,		<span class="hljs-comment">//用于发送总线相关的总线事件</span><br>	.need_parent_lock =	<span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用bus_register接口注册USB总线，会创建出两条链表用来分别存放向USB总线注册的设备和驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);<br>klist_init(&amp;priv-&gt;klist_drivers, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<h4 id="注册USB接口驱动"><a href="#注册USB接口驱动" class="headerlink" title="注册USB接口驱动"></a>注册USB接口驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB接口驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register(&amp;usbfs_driver);<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> driver_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usbfs_driver</span> =</span> &#123;<br>    .name =     <span class="hljs-string">&quot;usbfs&quot;</span>,<br>    .probe =    driver_probe,<br>    .disconnect =   driver_disconnect,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="初始化USB-Hub"><a href="#初始化USB-Hub" class="headerlink" title="初始化USB Hub"></a>初始化USB Hub</h4><p>初始化一个USB设备集线器，用来检测USB设备的连接和断开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = usb_hub_init();<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> hub_init_failed;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_hub_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 在usb总线注册一个hub驱动，该驱动被放在usb总线的驱动链表中。</span><br>	<span class="hljs-keyword">if</span> (usb_register(&amp;hub_driver) &lt; <span class="hljs-number">0</span>) &#123;<br>		printk(KERN_ERR <span class="hljs-string">&quot;%s: can&#x27;t register hub driver\n&quot;</span>,<br>			usbcore_name);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The workqueue needs to be freezable to avoid interfering with</span><br><span class="hljs-comment">	 * USB-PERSIST port handover. Otherwise it might see that a full-speed</span><br><span class="hljs-comment">	 * device was gone before the EHCI controller had handed its port</span><br><span class="hljs-comment">	 * over to the companion full-speed controller.</span><br><span class="hljs-comment">	 * 工作队列需要可冻结以避免干扰 USB-PERSIST 端口切换。 </span><br><span class="hljs-comment">	 * 否则，在 EHCI 控制器将其端口移交给配套的全速控制器之前，它可能会发现全速设备已消失。</span><br><span class="hljs-comment">	 */</span><br>	hub_wq = alloc_workqueue(<span class="hljs-string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span> (hub_wq)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* Fall through if kernel_thread failed */</span><br>	usb_deregister(&amp;hub_driver);<br>	pr_err(<span class="hljs-string">&quot;%s: can&#x27;t allocate workqueue for usb hub\n&quot;</span>, usbcore_name);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">hub_driver</span> =</span> &#123;<br>	.name =		<span class="hljs-string">&quot;hub&quot;</span>,<br>	.probe =	hub_probe,<br>	.disconnect =	hub_disconnect,<br>	.suspend =	hub_suspend,<br>	.resume =	hub_resume,<br>	.reset_resume =	hub_reset_resume,<br>	.pre_reset =	hub_pre_reset,<br>	.post_reset =	hub_post_reset,<br>	.unlocked_ioctl = hub_ioctl,<br>	.id_table =	hub_id_table,<br>	.supports_autosuspend =	<span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="注册USB设备驱动"><a href="#注册USB设备驱动" class="headerlink" title="注册USB设备驱动"></a>注册USB设备驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB设备驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<br><span class="hljs-keyword">if</span> (!retval)<br>    <span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_driver</span> <span class="hljs-title">usb_generic_driver</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;usb&quot;</span>,<br>    .probe = generic_probe,<br>    .disconnect = generic_disconnect,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  CONFIG_PM</span><br>    .suspend = generic_suspend,<br>    .resume = generic_resume,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    .supports_autosuspend = <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="usb-register-和-usb-register-device-driver"><a href="#usb-register-和-usb-register-device-driver" class="headerlink" title="usb_register 和 usb_register_device_driver"></a>usb_register 和 usb_register_device_driver</h3><p>usb_register 注册一个USB接口驱动，一个设备可以有多个接口，一个接口表示一种功能。比如USB声卡设备，有两个接口，一个播放接口，一个录音接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_register(driver) \</span><br><span class="hljs-meta">	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_driver - register a USB interface driver</span><br><span class="hljs-comment"> * @new_driver: USB operations for the interface driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> * @mod_name: module name string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB interface driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached interfaces will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized interfaces.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> if you want your driver to use the USB major number, you must call</span><br><span class="hljs-comment"> * usb_register_dev() to enable that functionality.  This function no longer</span><br><span class="hljs-comment"> * takes care of that.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_driver *new_driver, <span class="hljs-keyword">struct</span> module *owner,</span><br><span class="hljs-params">			<span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name)</span><br>&#123;<br>	<span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (usb_disabled())<br>		<span class="hljs-keyword">return</span> -ENODEV;<br><br>	new_driver-&gt;drvwrap.for_devices = <span class="hljs-number">0</span>;<br>	new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;<br>	new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb接口“设备”被匹配时，首先会调用usb_probe_interface，然后在该接口中调用driver的probe</span><br>	new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;<br>	new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;<br>	new_driver-&gt;drvwrap.driver.owner = owner;<br>	new_driver-&gt;drvwrap.driver.mod_name = mod_name;<br>	new_driver-&gt;drvwrap.driver.dev_groups = new_driver-&gt;dev_groups;<br>	spin_lock_init(&amp;new_driver-&gt;dynids.lock);<br>	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="hljs-built_in">list</span>);<br><br>	retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);<br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> out;<br><br>	retval = usb_create_newid_files(new_driver);<br>	<span class="hljs-keyword">if</span> (retval)<br>		<span class="hljs-keyword">goto</span> out_newid;<br><br>	pr_info(<span class="hljs-string">&quot;%s: registered new interface driver %s\n&quot;</span>,<br>			usbcore_name, new_driver-&gt;name);<br><br>out:<br>	<span class="hljs-keyword">return</span> retval;<br><br>out_newid:<br>	driver_unregister(&amp;new_driver-&gt;drvwrap.driver);<br><br>	pr_err(<span class="hljs-string">&quot;%s: error %d registering interface driver %s\n&quot;</span>,<br>		usbcore_name, retval, new_driver-&gt;name);<br>	<span class="hljs-keyword">goto</span> out;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_driver);<br></code></pre></td></tr></table></figure>

<p>usb_register_device_driver 注册一个通用USB设备驱动，而不是USB接口驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_device_driver - register a USB device (not interface) driver</span><br><span class="hljs-comment"> * @new_udriver: USB operations for the device driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB device driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached devices will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized devices.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_device_driver *new_udriver,</span><br><span class="hljs-params">		<span class="hljs-keyword">struct</span> module *owner)</span><br>&#123;<br>	<span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (usb_disabled())<br>		<span class="hljs-keyword">return</span> -ENODEV;<br><br>	new_udriver-&gt;drvwrap.for_devices = <span class="hljs-number">1</span>;<br>	new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;<br>	new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb设备被匹配时，首先会调用usb_probe_device，然后在该接口中调用driver的probe</span><br>	new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;<br>	new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;<br>	new_udriver-&gt;drvwrap.driver.owner = owner;<br>	new_udriver-&gt;drvwrap.driver.dev_groups = new_udriver-&gt;dev_groups;<br><br>	retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);<br><br>	<span class="hljs-keyword">if</span> (!retval) &#123;<br>		pr_info(<span class="hljs-string">&quot;%s: registered new device driver %s\n&quot;</span>,<br>			usbcore_name, new_udriver-&gt;name);<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Check whether any device could be better served with</span><br><span class="hljs-comment">		 * this new driver</span><br><span class="hljs-comment">		 */</span><br>		bus_for_each_dev(&amp;usb_bus_type, <span class="hljs-literal">NULL</span>, new_udriver,<br>				 __usb_bus_reprobe_drivers);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		pr_err(<span class="hljs-string">&quot;%s: error %d registering device driver %s\n&quot;</span>,<br>			usbcore_name, retval, new_udriver-&gt;name);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> retval;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_device_driver);<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>USB core注册了一个USB总线，并向USB总线中注册了三个驱动，分别是USB接口驱动、HUB驱动、USB设备驱动。其中在注册HUB驱动前创建了一个hub_thread线程，用来处理hub上USB设备事件，比如插入和拔出；在HUB驱动的probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件。</p>
<h2 id="USB主机控制器驱动（HCD）"><a href="#USB主机控制器驱动（HCD）" class="headerlink" title="USB主机控制器驱动（HCD）"></a>USB主机控制器驱动（HCD）</h2><p>USB HCD注册在平台总线上。用来处理主机控制器的初始化以及数据的传输，并监测外部设备插入、拔出，完成设备枚举。</p>
<h3 id="USB主机控制器-设备"><a href="#USB主机控制器-设备" class="headerlink" title="USB主机控制器-设备"></a>USB主机控制器-设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//5.10/arch/arm/mach-s3c/mach-smdk2440.c</span><br>MACHINE_START(S3C2440, <span class="hljs-string">&quot;SMDK2440&quot;</span>)<br>	<span class="hljs-comment">/* Maintainer: Ben Dooks &lt;ben-linux@fluff.org&gt; */</span><br>	.atag_offset	= <span class="hljs-number">0x100</span>,<br><br>	.init_irq	= s3c2440_init_irq,<br>	.map_io		= smdk2440_map_io,<br>	.init_machine	= smdk2440_machine_init,<br>	.init_time	= smdk2440_init_time,<br>MACHINE_END<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init smdk2440_machine_init(<span class="hljs-type">void</span>)<br>&#123;<br>	s3c24xx_fb_set_platdata(&amp;smdk2440_fb_info);<br>	s3c_i2c0_set_platdata(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">/* Configure the I2S pins (GPE0...GPE4) in correct mode */</span><br>	s3c_gpio_cfgall_range(S3C2410_GPE(<span class="hljs-number">0</span>), <span class="hljs-number">5</span>, S3C_GPIO_SFN(<span class="hljs-number">2</span>),<br>			      S3C_GPIO_PULL_NONE);<br>	platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));<br>	smdk_machine_init();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<br>	&amp;s3c_device_ohci,<br>	&amp;s3c_device_lcd,<br>	&amp;s3c_device_wdt,<br>	&amp;s3c_device_i2c0,<br>	&amp;s3c_device_iis,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>	.id		= <span class="hljs-number">-1</span>,<br>	.num_resources	= ARRAY_SIZE(s3c_usb_resource),<br>	.resource	= s3c_usb_resource,<br>	.dev		= &#123;<br>		.dma_mask		= &amp;samsung_device_dma_mask,<br>		.coherent_dma_mask	= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="USB主机控制器-驱动"><a href="#USB主机控制器-驱动" class="headerlink" title="USB主机控制器-驱动"></a>USB主机控制器-驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// linux-2.6.22.6/drivers/usb/host/ohci-hcd.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_S3C2410</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ohci-s3c2410.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLATFORM_DRIVER     ohci_hcd_s3c2410_driver</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ohci_hcd_mod_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (usb_disabled())<br>		<span class="hljs-keyword">return</span> -ENODEV;<br><br>	printk(KERN_INFO <span class="hljs-string">&quot;%s: &quot;</span> DRIVER_DESC <span class="hljs-string">&quot;\n&quot;</span>, hcd_name);<br>	pr_debug (<span class="hljs-string">&quot;%s: block sizes: ed %zd td %zd\n&quot;</span>, hcd_name,<br>		<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> ed), <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> td));<br>	set_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br><br>	ohci_debug_root = debugfs_create_dir(<span class="hljs-string">&quot;ohci&quot;</span>, usb_debug_root);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>	retval = ps3_ohci_driver_register(&amp;PS3_SYSTEM_BUS_DRIVER);<br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> error_ps3;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>	retval = platform_driver_register(&amp;OF_PLATFORM_DRIVER);<br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> error_of_platform;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>	retval = sa1111_driver_register(&amp;SA1111_DRIVER);<br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> error_sa1111;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>	retval = platform_driver_register(&amp;SM501_OHCI_DRIVER);<br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> error_sm501;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>	retval = platform_driver_register(&amp;TMIO_OHCI_DRIVER);<br>	<span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> error_tmio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-keyword">return</span> retval;<br><br>	<span class="hljs-comment">/* Error path */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>	platform_driver_unregister(&amp;TMIO_OHCI_DRIVER);<br> error_tmio:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>	platform_driver_unregister(&amp;SM501_OHCI_DRIVER);<br> error_sm501:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>	sa1111_driver_unregister(&amp;SA1111_DRIVER);<br> error_sa1111:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>	platform_driver_unregister(&amp;OF_PLATFORM_DRIVER);<br> error_of_platform:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>	ps3_ohci_driver_unregister(&amp;PS3_SYSTEM_BUS_DRIVER);<br> error_ps3:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	debugfs_remove(ohci_debug_root);<br>	ohci_debug_root = <span class="hljs-literal">NULL</span>;<br><br>	clear_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br>	<span class="hljs-keyword">return</span> retval;<br>&#125;<br>module_init(ohci_hcd_mod_init);<br><br><span class="hljs-comment">// drivers/usb/host/ohci-s3c2410.c</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>	.probe		= ohci_hcd_s3c2410_probe,<br>	.remove		= ohci_hcd_s3c2410_remove,<br>	.shutdown	= usb_hcd_platform_shutdown,<br>	.driver		= &#123;<br>		.name	= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>		.pm	= &amp;ohci_hcd_s3c2410_pm_ops,<br>		.of_match_table	= ohci_hcd_s3c2410_dt_ids,<br>	&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="USB主机控制器设备和驱动的匹配"><a href="#USB主机控制器设备和驱动的匹配" class="headerlink" title="USB主机控制器设备和驱动的匹配"></a>USB主机控制器设备和驱动的匹配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_driver_register-&gt;<br>    driver_register-&gt;<br>        bus_add_driver-&gt;<br>            driver_attach-&gt;<br>                bus_for_each_dev-&gt; <span class="hljs-comment">// 从平台总线的的设备链表中，取出每一项设备进行匹配</span><br>                    __driver_attach-&gt;<br>                        driver_probe_device-&gt;<br>                            <span class="hljs-comment">// 此总线类型为平台总线，其存在match函数，即调用platform_match进行匹配</span><br>                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))                            <br><br><span class="hljs-comment">// 平台总线                            </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;platform&quot;</span>,<br>	.dev_groups	= platform_dev_groups,<br>	.match		= platform_match,<br>	.uevent		= platform_uevent,<br>	.dma_configure	= platform_dma_configure,<br>	.pm		= &amp;platform_dev_pm_ops,<br>&#125;;<br>EXPORT_SYMBOL_GPL(platform_bus_type);             <br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);<br><br>	<span class="hljs-comment">/* When driver_override is set, only bind to the matching driver */</span><br>	<span class="hljs-keyword">if</span> (pdev-&gt;driver_override)<br>		<span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);<br><br>	<span class="hljs-comment">/* Attempt an OF style match first */</span><br>	<span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/* Then try ACPI style match */</span><br>	<span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/* Then try to match against the id table */</span><br>	<span class="hljs-keyword">if</span> (pdrv-&gt;id_table)<br>		<span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">/* fall-back to driver name match */</span><br>	<span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// ohci 设备   name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>	.id		= <span class="hljs-number">-1</span>,<br>	.num_resources	= ARRAY_SIZE(s3c_usb_resource),<br>	.resource	= s3c_usb_resource,<br>	.dev		= &#123;<br>		.dma_mask		= &amp;samsung_device_dma_mask,<br>		.coherent_dma_mask	= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// ohci 驱动 name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>	.probe		= ohci_hcd_s3c2410_probe,<br>	.remove		= ohci_hcd_s3c2410_remove,<br>	.shutdown	= usb_hcd_platform_shutdown,<br>	.driver		= &#123;<br>		.name	= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>		.pm	= &amp;ohci_hcd_s3c2410_pm_ops,<br>		.of_match_table	= ohci_hcd_s3c2410_dt_ids,<br>	&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>匹配成功调用驱动的probe函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>    really_probe-&gt;<br>        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure>

<h3 id="USB主机控制器驱动的probe函数"><a href="#USB主机控制器驱动的probe函数" class="headerlink" title="USB主机控制器驱动的probe函数"></a>USB主机控制器驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ohci_hcd_s3c2410_drv_probe -&gt; <br>    usb_hcd_s3c2410_probe -&gt;<br>        usb_add_hcd -&gt; <br>            rhdev = usb_alloc_dev<br>            hcd-&gt;self.root_hub = rhdev<br>            register_root_hub -&gt; <br>                usb_new_device -&gt;<br>                    device_add -&gt;     <br>                        bus_attach_device -&gt;<br>                            device_attach -&gt; <br>                                bus_for_each_drv -&gt; <span class="hljs-comment">// 从usb总线的的驱动链表中，取出每一项驱动进行匹配</span><br>                                    __device_attach -&gt;<br>                                        driver_probe_device -&gt;<br>                                            <span class="hljs-comment">// 此总线类型为USB总线，其存在match函数，即调用usb_device_match进行匹配</span><br>                                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv)) <br>                                                driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>                                                    really_probe-&gt;<br>                                                        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure>

<h3 id="usb-device-match"><a href="#usb-device-match" class="headerlink" title="usb_device_match"></a>usb_device_match</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> dev-&gt;type == &amp;usb_device_type;<br>&#125;<br><br><span class="hljs-comment">/* Do the same for device drivers and interface drivers. */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// struct device_driver 中 struct usbdrv_wrap 中的for_devices变量为1，则为USB设备驱动</span><br>    <span class="hljs-comment">// 上节USB Core中向USB总线注册的USB设备驱动中有将该变量设置为1（new_udriver-&gt;drvwrap.for_devices = 1;）</span><br>    <span class="hljs-keyword">return</span> container_of(drv, <span class="hljs-keyword">struct</span> usbdrv_wrap, driver)-&gt;<br>            for_devices;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// USB设备 和 USB接口“设备”分开处理 </span><br>    <span class="hljs-comment">/* devices and interfaces are handled separately */</span><br>    <span class="hljs-keyword">if</span> (is_usb_device(dev)) &#123;<br>        <span class="hljs-comment">// 处理USB设备</span><br>        <span class="hljs-comment">/* interface drivers never match devices */</span><br>        <span class="hljs-keyword">if</span> (!is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Add real matching code */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理USB接口设备</span><br>        <span class="hljs-keyword">struct</span> usb_interface *intf;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> *<span class="hljs-title">usb_drv</span>;</span><br>        <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> *<span class="hljs-title">id</span>;</span><br><br>        <span class="hljs-comment">/* device drivers never match interfaces */</span><br>        <span class="hljs-keyword">if</span> (is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        intf = to_usb_interface(dev);<br>        usb_drv = to_usb_driver(drv);<br><br>        id = usb_match_id(intf, usb_drv-&gt;id_table);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        id = usb_match_dynamic_id(intf, usb_drv);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>probe 向USB总线注册一个root hub 设备，从usb总线的的驱动链表中，取出每一项驱动进行匹配。在USB Core中已经向总线注册了三个驱动（USB设备驱动、USB接口驱动、USB hub驱动），根据条件匹配到USB设备驱动，则去调用USB设备驱动的probe函数。</p>
<h3 id="USB设备驱动的probe函数"><a href="#USB设备驱动的probe函数" class="headerlink" title="USB设备驱动的probe函数"></a>USB设备驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">generic_probe(<span class="hljs-keyword">struct</span> usb_device *udev) -&gt; <span class="hljs-comment">// 从上分析流程知udev为USB root hub设备 </span><br>    usb_set_configuration -&gt;<br>        device_add -&gt;  <span class="hljs-comment">// 创建USB接口设备，USB root hub接口设备被创建</span><br></code></pre></td></tr></table></figure>

<p>之后匹配到USB Core中注册的USB hub驱动，执行USB hub驱动的probe函数，该probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件（插入、拔出）。至此，系统启动初始化时关于USB的内容分析完成。USB Core和USB HCD的成功建立联系，为之后的USB设备驱动提供API。</p>
<h2 id="USB设备驱动-–USB鼠标"><a href="#USB设备驱动-–USB鼠标" class="headerlink" title="USB设备驱动 –USB鼠标"></a>USB设备驱动 –USB鼠标</h2><p>用于和枚举到的USB设备进行绑定，完成特定的功能。 比如USB鼠标设备，驱动开发主要是这一块代码的coding。</p>
<h3 id="注册一个USB接口驱动"><a href="#注册一个USB接口驱动" class="headerlink" title="注册一个USB接口驱动"></a>注册一个USB接口驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usb_mouse_driver</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;usbmouse&quot;</span>,<br>	.probe		= usb_mouse_probe,<br>	.disconnect	= usb_mouse_disconnect,<br>	.id_table	= usb_mouse_id_table,<br>&#125;;<br><br>module_usb_driver(usb_mouse_driver);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * module_usb_driver() - Helper macro for registering a USB driver</span><br><span class="hljs-comment"> * @__usb_driver: usb_driver struct</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Helper macro for USB drivers which do not do anything special in module</span><br><span class="hljs-comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span><br><span class="hljs-comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> module_usb_driver(__usb_driver) \</span><br><span class="hljs-meta">	module_driver(__usb_driver, usb_register, \</span><br><span class="hljs-meta">		       usb_deregister)</span><br></code></pre></td></tr></table></figure>

<h3 id="USB接口设备的创建"><a href="#USB接口设备的创建" class="headerlink" title="USB接口设备的创建"></a>USB接口设备的创建</h3><p>当一个USB 鼠标设备插入后，主机USB控制器检测到后，触发USB设备集线器中的”中断”处理函数hub_irq。在hub_irq中会获取USB鼠标设备的设备描述符，根据设备描述符创建USB接口设备，从而和这边的USB接口驱动匹配，调用其probe函数，通过USB总线驱动程序（USB Core和USB HCD）和USB鼠标设备建立联系，进而操作（读写控制）该设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">hub_irq<br>    kick_khubd <span class="hljs-comment">// 唤醒hub_thread线程</span><br>        hub_thread<br>            hub_events <span class="hljs-comment">// 处理USB设备插入事件</span><br>                hub_port_connect_change<br><br>                    udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);<br>                                dev-&gt;dev.bus = &amp;usb_bus_type;<br><br>                    choose_address(udev); <span class="hljs-comment">// 给新设备分配编号(地址)                                       </span><br>                    hub_port_init   <span class="hljs-comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 3</span><br><br>                        hub_set_address  <span class="hljs-comment">// 把编号(地址)告诉USB设备</span><br><br>                        usb_get_device_descriptor(udev, <span class="hljs-number">8</span>); <span class="hljs-comment">// 获取设备描述符</span><br>                        retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);<br><br>                        usb_new_device(udev)   <br>                            err = usb_get_configuration(udev); <span class="hljs-comment">// 把所有的描述符都读出来，并解析</span><br>                            usb_parse_configuration<br><br>                            device_add  <span class="hljs-comment">// 把device放入usb_bus_type的dev链表, </span><br>                                        <span class="hljs-comment">// 从usb_bus_type的driver链表里取出usb_driver，</span><br>                                        <span class="hljs-comment">// 把usb_interface和usb_driver的id_table比较</span><br>                                        <span class="hljs-comment">// 如果能匹配，调用usb_driver的probe</span><br></code></pre></td></tr></table></figure>

<h3 id="USB接口驱动和USB接口设备的匹配"><a href="#USB接口驱动和USB接口设备的匹配" class="headerlink" title="USB接口驱动和USB接口设备的匹配"></a>USB接口驱动和USB接口设备的匹配</h3><p>USB设备插入后根据获取到的设备描述符所创建的USB 接口设备和开发的USB接口驱动匹配： 对于设备： 将获取到的USB设备描述符信息保存在其id_table中。 对于驱动： 驱动的id_table中存放期望该驱动适用的USB设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> <span class="hljs-title">usb_mouse_id_table</span>[] =</span> &#123;<br>	&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,<br>		USB_INTERFACE_PROTOCOL_MOUSE) &#125;,<br>	&#123; &#125;	<span class="hljs-comment">/* Terminating entry */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>匹配成功后调用该驱动的probe函数，具体的过程和前面分析的差不多。接下来就是在probe函数中，和USB总线驱动程序建立联系，以达到操作USB 鼠标设备的目的。</p>
<h3 id="创建数据传输管道"><a href="#创建数据传输管道" class="headerlink" title="创建数据传输管道"></a>创建数据传输管道</h3><p>根据数据传输类型，有几个接口可供调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create various pipes... */</span><br><span class="hljs-comment">// 控制传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndctrlpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvctrlpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 实时传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndisocpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvisocpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 批量传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndbulkpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvbulkpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 中断传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndintpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvintpipe(dev, endpoint)	\</span><br><span class="hljs-meta">	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br></code></pre></td></tr></table></figure>

<p>对于USB 鼠标设备，使用中断传输方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">dev</span> =</span> interface_to_usbdev(intf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">interface</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> *<span class="hljs-title">endpoint</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input_dev</span>;</span><br><span class="hljs-type">int</span> pipe, maxp;<br><span class="hljs-type">int</span> error = -ENOMEM;<br><br>interface = intf-&gt;cur_altsetting;<br><br><span class="hljs-keyword">if</span> (interface-&gt;desc.bNumEndpoints != <span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">return</span> -ENODEV;<br><br>endpoint = &amp;interface-&gt;endpoint[<span class="hljs-number">0</span>].desc;<br><span class="hljs-keyword">if</span> (!usb_endpoint_is_int_in(endpoint))<br>	<span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 端点是USB设备数据传输对象</span><br>pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);<br>maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));<br></code></pre></td></tr></table></figure>

<h3 id="分配urb"><a href="#分配urb" class="headerlink" title="分配urb"></a>分配urb</h3><p>urb（USB Request Block）是Linux内核中USB驱动实现上的一个数据结构，用于组织每一次的USB设备驱动的数据传输请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mouse-&gt;irq = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!mouse-&gt;irq)<br>	<span class="hljs-keyword">goto</span> fail2;<br></code></pre></td></tr></table></figure>

<h3 id="urb数据结构初始化"><a href="#urb数据结构初始化" class="headerlink" title="urb数据结构初始化"></a>urb数据结构初始化</h3><p>根据传输类型，有几个接口可供调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 控制</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_control_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">					<span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">					<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">					<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *setup_packet,</span><br><span class="hljs-params">					<span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">					<span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">					<span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">					<span class="hljs-type">void</span> *context)</span><br><span class="hljs-comment">// 批量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_bulk_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">				     <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">				     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">				     <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">				     <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">				     <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">				     <span class="hljs-type">void</span> *context)</span><br><br><span class="hljs-comment">// 中断</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_int_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">				    <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">				    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">				    <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">				    <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">				    <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">				    <span class="hljs-type">void</span> *context,</span><br><span class="hljs-params">				    <span class="hljs-type">int</span> interval)</span><br><span class="hljs-comment">// 实时   </span><br><span class="hljs-comment">// 实时urb 没有和中断、控制、批量urb 类似的初始化函数，因此它们在提交到USB核心之前，需要在驱动程序中手动的初始化</span><br></code></pre></td></tr></table></figure>

<p>对于USB鼠标设备，采用中断传输方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,<br>		 (maxp &gt; <span class="hljs-number">8</span> ? <span class="hljs-number">8</span> : maxp),<br>		 usb_mouse_irq, mouse, endpoint-&gt;bInterval);<br>mouse-&gt;irq-&gt;transfer_dma = mouse-&gt;data_dma;<br>mouse-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br></code></pre></td></tr></table></figure>

<h3 id="提交USB请求块"><a href="#提交USB请求块" class="headerlink" title="提交USB请求块"></a>提交USB请求块</h3><p>调用usb_submit_urb接口以获取USB设备数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_mouse_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span> =</span> input_get_drvdata(dev);<br><br>	mouse-&gt;irq-&gt;dev = mouse-&gt;usbdev;<br>	<span class="hljs-keyword">if</span> (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))<br>		<span class="hljs-keyword">return</span> -EIO;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>USB驱动开发，针对某一个USB设备的某个功能（接口）构建的驱动程序。USB驱动并不直接和USB设备进行数据交互，而是通过USB总线驱动程序（USB Core和USB HCD）来操作USB设备的。一般构建USB设备驱动的流程为：</p>
<ul>
<li>根据期望适用的USB设备信息构建一个id_table。</li>
<li>根据需要的数据传输类型，调用相应的接口创建数据传输管道。</li>
<li>分配一个urb(USB请求块)。</li>
<li>根据需要的数据传输类型，调用相应的接口进行urb数据结构初始化。</li>
<li>提交urb</li>
</ul>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.yuanzige.com/">www.yuanzige.com</a></li>
<li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/usb/" class="category-chain-item">usb</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/usb/" class="print-no-link">#usb</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>USB</div>
      <div>https://tomwithkernel.github.io/usb/usb/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tom</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月18日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年6月6日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/script/README/" title="linux工具">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">linux工具</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/debug/crash/" title="crash">
                        <span class="hidden-mobile">crash</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","appKey":"jxVWH2hG2DLvf0KjiGZ93acw","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://tomwithkernel.github.io/" target="_blank" rel="nofollow noopener"><span>Tom</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/TomWithKernel/kernel" target="_blank" rel="nofollow noopener"><span>repository</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
