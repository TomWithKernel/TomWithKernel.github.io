

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/tom.png">
  <link rel="icon" href="/img/tom.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tom">
  <meta name="keywords" content="">
  
    <meta name="description" content="字符设备驱动简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图 4">
<meta property="og:type" content="article">
<meta property="og:title" content="字符设备驱动">
<meta property="og:url" content="https://tomwithkernel.github.io/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="TomWithKernel&#39;s Blog">
<meta property="og:description" content="字符设备驱动简介字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图 4">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-09T01:46:07.000Z">
<meta property="article:modified_time" content="2024-12-26T01:47:56.761Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="字符设备驱动">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>字符设备驱动 - TomWithKernel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/cloudedGlass.css">
<link rel="stylesheet" href="/css/selection.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tomwithkernel.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","app_key":"jxVWH2hG2DLvf0KjiGZ93acw","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TomWithKernel&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="字符设备驱动"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-09 09:46" pubdate>
          2024年12月9日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          322 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">字符设备驱动</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。<br>在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图 40.1.1 所示：</p>


<p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。比如现在有个叫做&#x2F;dev&#x2F;led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件&#x2F;dev&#x2F;led，使用完成以后使用 close 函数关闭&#x2F;dev&#x2F;led 这个文件。open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。</p>
<p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如图 40.1.2 所示：</p>


<p>其中关于 C 库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include&#x2F;linux&#x2F;fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.1</span><span class="hljs-number">.1</span> file_operations 结构体<br><span class="hljs-number">1588</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-number">1589</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-number">1590</span>    <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-number">1591</span>    <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-number">1592</span>    <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-number">1593</span>    <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-number">1594</span>    <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-number">1595</span>    <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-number">1596</span>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br><span class="hljs-number">1597</span>    <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-number">1598</span>    <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-number">1599</span>    <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-number">1600</span>    <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-number">1601</span>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1602</span>    <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-number">1603</span>    <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1604</span>    <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-number">1605</span>    <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br><span class="hljs-number">1606</span>    <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br><span class="hljs-number">1607</span>    <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-number">1608</span>    <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-number">1609</span>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-number">1610</span>    <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-number">1611</span>    <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-number">1612</span>    <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-number">1613</span>    <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-number">1614</span>    <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-number">1615</span>    <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br><span class="hljs-number">1616</span>    <span class="hljs-type">loff_t</span> len);<br><span class="hljs-number">1617</span>    <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-number">1618</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-number">1619</span>    <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1620</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">1621</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：</p>
<p>第 1589 行，owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。</p>
<p>第 1590 行，llseek 函数用于修改文件当前的读写位置。</p>
<p>第 1591 行，read 函数用于读取设备文件。</p>
<p>第 1592 行，write 函数用于向设备文件写入(发送)数据。</p>
<p>第 1596 行，poll 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。</p>
<p>第 1597 行，unlocked_ioctl 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。</p>
<p>第 1598 行，compat_ioctl 函数与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。</p>
<p>第 1599 行，mmap 函数用于将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。</p>
<p>第 1601 行，open 函数用于打开设备文件。</p>
<p>第 1603 行，release 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。</p>
<p>第 1604 行，fasync 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。</p>
<p>第 1605 行，aio_fsync 函数与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p>
<p>在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、release、write、read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。</p>
<h3 id="字符设备驱动开发步骤"><a href="#字符设备驱动开发步骤" class="headerlink" title="字符设备驱动开发步骤"></a>字符设备驱动开发步骤</h3><h4 id="驱动模块的加载和卸载"><a href="#驱动模块的加载和卸载" class="headerlink" title="驱动模块的加载和卸载"></a>驱动模块的加载和卸载</h4><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。总之，将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p>
<p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">module_init(xxx_init); <br><span class="hljs-comment">//注册模块加载函数</span><br>module_exit(xxx_exit); <br><span class="hljs-comment">//注册模块卸载函数</span><br></code></pre></td></tr></table></figure>

<p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。字符设备驱动模块加载和卸载模板如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.2</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> 字符设备驱动模块加载和卸载函数模板<br><span class="hljs-number">1</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>3 &#123;<br><span class="hljs-number">4</span> 		<span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>10 &#123;<br><span class="hljs-number">11</span> 		<span class="hljs-comment">/* 出口函数具体内容 */</span><br><span class="hljs-number">12</span> &#125;<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">15</span> module_init(xxx_init);<br><span class="hljs-number">16</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure>

<p>第 2 行，定义了个名为 xxx_init 的驱动入口函数，并且使用了“__init”来修饰。</p>
<p>第 9 行，定义了个名为 xxx_exit 的驱动出口函数，并且使用了“__exit”来修饰。</p>
<p>第 15 行，调用函数 module_init 来声明 xxx_init 为驱动入口函数，当加载驱动的时候 xxx_init函数就会被调用。</p>
<p>第16行，调用函数module_exit来声明xxx_exit为驱动出口函数，当卸载驱动的时候xxx_exit函数就会被调用。</p>
<p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：insmod和modprobe，insmod是最简单的模块加载命令，此命令用于加载指定的.ko 模块，比如加载 drv.ko 这个驱动模块，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">insmod drv.ko<br></code></pre></td></tr></table></figure>

<p>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。但是 modprobe 就不会存在这个问题，modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，因此modprobe 命令相比 insmod 要智能一些。modprobe 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能，推荐使用 modprobe 命令来加载驱动。modprobe 命令默认会去&#x2F;lib&#x2F;modules&#x2F;<kernel-version>目录中查找模块，比如本书使用的 Linux kernel 的版本号为 4.1.15，因此 modprobe 命令默认会到&#x2F;lib&#x2F;modules&#x2F;4.1.15 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。</p>
<p>驱动模块的卸载使用命令“rmmod”即可，比如要卸载 drv.ko，使用如下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmmod drv.ko<br></code></pre></td></tr></table></figure>

<p>也可以使用“modprobe -r”命令卸载驱动，比如要卸载 drv.ko，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">modprobe -r drv.ko<br></code></pre></td></tr></table></figure>

<p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。所以对于模块的卸载，还是推荐使用 rmmod 命令。</p>
<h4 id="字符设备的注册与注销"><a href="#字符设备的注册与注销" class="headerlink" title="字符设备的注册与注销"></a>字符设备的注册与注销</h4><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure>

<p>register_chrdev 函数用于注册字符设备，此函数一共有三个参数，这三个参数的含义如下：</p>
<p><strong>major</strong>：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。</p>
<p><strong>name</strong>：设备名字，指向一串字符串。</p>
<p><strong>fops</strong>：结构体 file_operations 类型指针，指向设备的操作函数集合变量。</p>
<p>unregister_chrdev 函数用户注销字符设备，此函数有两个参数，这两个参数含义如下：</p>
<p><strong>major</strong>：要注销的设备对应的主设备号。</p>
<p><strong>name</strong>：要注销的设备对应的设备名。</p>
<p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块的出口函数 xxx_exit 中进行。在示例代码 40.2.2.1 中字符设备的注册和注销，内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.2</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span> 加入字符设备注册和注销<br><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>5 &#123;<br><span class="hljs-number">6</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">7</span> <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">10</span> retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br><span class="hljs-number">11</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-number">12</span> <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">15</span> &#125;<br><span class="hljs-number">16</span><br><span class="hljs-number">17</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">18</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>19 &#123;<br><span class="hljs-number">20</span> <span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-number">21</span> unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br><span class="hljs-number">22</span> &#125;<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">25</span> module_init(xxx_init);<br><span class="hljs-number">26</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure>

<p>第 1 行，定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集合，只是此时我们还没有初始化 test_fops 中的 open、release 等这些成员变量，所以这个操作函数集合还是空的。</p>
<p>第 10 行，调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”，设备操作函数集合就是第 1 行定义的 test_fops。要注意的一点就是，选择没有被使用的主设备号，输入命令“cat &#x2F;proc&#x2F;devices”可以查看当前已经被使用掉的设备号，如图所示(限于篇幅原因，只展示一部分)：</p>


<p>在图中可以列出当前系统中所有的字符设备和块设备，其中第 1 列就是设备对应的主设备号。200 这个主设备号在我的开发板中并没有被使用，所以我这里就用了 200 这个主设备号。</p>
<p>第 21 行，调用函数 unregister_chrdev 注销主设备号为 200 的这个设备。</p>
<h4 id="实现设备的具体操作函数"><a href="#实现设备的具体操作函数" class="headerlink" title="实现设备的具体操作函数"></a>实现设备的具体操作函数</h4><p>file_operations 结构体就是设备的具体操作函数，在示例代码 40.2.2.1 中我们定义了file_operations结构体类型的变量test_fops，但是还没对其进行初始化，也就是初始化其中的open、release、read 和 write 等具体的设备操作函数。本小节我们就完成变量 test_fops 的初始化，设置好针对 chrtest 设备的操作函数。在初始化 test_fops 之前我们要分析一下需求，也就是要对 chrtest这个设备进行哪些操作，只有确定了需求以后才知道我们应该实现哪些操作函数。假设对 chrtest这个设备有如下两个要求：</p>
<p><strong>1、能够对 chrtest 进行打开和关闭操作</strong></p>
<p>设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此我们需要实现 file_operations 中的 open 和 release 这两个函数。</p>
<p><strong>2、对 chrtest 进行读写操作</strong></p>
<p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。</p>
<p>需求很清晰了，修改示例代码 40.2.2.1，在其中加入 test_fops 这个结构体变量的初始化操作，完成以后的内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.2.3.1 加入设备操作函数</span><br><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>3 &#123;<br><span class="hljs-number">4</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> <span class="hljs-comment">/* 从设备读取 */</span><br><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>10 &#123;<br><span class="hljs-number">11</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">12</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 向设备写数据 */</span><br><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>17 &#123;<br><span class="hljs-number">18</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">19</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span> <span class="hljs-comment">/* 关闭/释放设备 */</span><br><span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>24 &#123;<br><span class="hljs-number">25</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">26</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">27</span> &#125;<br><span class="hljs-number">28</span><br><span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">30</span> 		.owner = THIS_MODULE, <br><span class="hljs-number">31</span> 		.open = chrtest_open,<br><span class="hljs-number">32</span> 		.read = chrtest_read,<br><span class="hljs-number">33</span> 		.write = chrtest_write,<br><span class="hljs-number">34</span> 		.release = chrtest_release,<br><span class="hljs-number">35</span> &#125;;<br><span class="hljs-number">36</span><br><span class="hljs-number">37</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>39 &#123;<br><span class="hljs-number">40</span> 		<span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">41</span> 		<span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><span class="hljs-number">42</span><br><span class="hljs-number">43</span> 		<span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">44</span> 		retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br><span class="hljs-number">45</span> 		<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-number">46</span> 			<span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br><span class="hljs-number">47</span> 		&#125;<br><span class="hljs-number">48</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">49</span> &#125;<br><span class="hljs-number">50</span><br><span class="hljs-number">51</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">52</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>53 &#123;<br><span class="hljs-number">54</span> 		<span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-number">55</span> 		unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br><span class="hljs-number">56</span> &#125;<br><span class="hljs-number">57</span><br><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">59</span> module_init(xxx_init);<br><span class="hljs-number">60</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure>

<p>在示例代码 40.2.3.1 中我们一开始编写了四个函数：chrtest_open、chrtest_read、chrtest_write和 chrtest_release。这四个函数就是 chrtest 设备的 open、read、write 和 release 操作函数。第 29行~35 行初始化 test_fops 的 open、read、write 和 release 这四个成员变量。</p>
<h4 id="添加LICENSE和作者信息"><a href="#添加LICENSE和作者信息" class="headerlink" title="添加LICENSE和作者信息"></a>添加LICENSE和作者信息</h4><p>最后我们需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用如下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MODULE_LICENSE() <span class="hljs-comment">//添加模块 LICENSE 信息</span><br>MODULE_AUTHOR() <span class="hljs-comment">//添加模块作者信息</span><br></code></pre></td></tr></table></figure>

<p>最后给示例代码 40.2.3.1 加入 LICENSE 和作者信息，完成以后的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.2.4.1 字符设备驱动最终的模板</span><br><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>3 &#123;<br><span class="hljs-number">4</span> 		<span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">5</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br>......<br><span class="hljs-number">57</span><br><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">59</span> module_init(xxx_init);<br><span class="hljs-number">60</span> module_exit(xxx_exit);<br><span class="hljs-number">61</span><br><span class="hljs-number">62</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-number">63</span> MODULE_AUTHOR(<span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="Linux-设备号"><a href="#Linux-设备号" class="headerlink" title="Linux 设备号"></a>Linux 设备号</h3><h4 id="设备号的组成"><a href="#设备号的组成" class="headerlink" title="设备号的组成"></a>设备号的组成</h4><p>为了方便管理，Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。Linux 提供了一个名为 dev_t 的数据类型表示设备号，dev_t 定义在文件 include&#x2F;linux&#x2F;types.h 里面，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.1 设备号 dev_t</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">typedef</span> __u32 <span class="hljs-type">__kernel_dev_t</span>;<br>	......<br><span class="hljs-number">15</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_dev_t</span> <span class="hljs-type">dev_t</span>;<br></code></pre></td></tr></table></figure>

<p>可以看出 dev_t 是<code>__u32</code> 类型的，而 __u32 定义在文件 include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h 里面，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.2 __u32 类型</span><br><span class="hljs-number">26</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __u32;<br></code></pre></td></tr></table></figure>

<p>综上所述，dev_t 其实就是 unsigned int 类型，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号。因此 Linux系统中主设备号范围为 0~4095，所以大家在选择主设备号的时候一定不要超过这个范围。在文件 include&#x2F;linux&#x2F;kdev_t.h 中提供了几个关于设备号的操作函数(本质是宏)，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.3 设备号操作函数</span><br><span class="hljs-number">6</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORBITS 20</span><br><span class="hljs-number">7</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span><br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="hljs-number">10</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="hljs-number">11</span> 	<span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))</span><br></code></pre></td></tr></table></figure>

<p>第 6 行，宏 MINORBITS 表示次设备号位数，一共是 20 位。</p>
<p>第 7 行，宏 MINORMASK 表示次设备号掩码。</p>
<p>第 9 行，宏 MAJOR 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。</p>
<p>第 10 行，宏 MINOR 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可。</p>
<p>第 11 行，宏 MKDEV 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。</p>
<h4 id="设备号的分配"><a href="#设备号的分配" class="headerlink" title="设备号的分配"></a>设备号的分配</h4><h5 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h5><p>本小节讲的设备号分配主要是主设备号的分配。前面讲解字符设备驱动的时候说过了，注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，使用“cat &#x2F;proc&#x2F;devices”命令即可查看当前系统中所有已经使用了的设备号。</p>
<h5 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h5><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题，Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure>

<p>函数 alloc_chrdev_region 用于申请设备号，此函数有 4 个参数：</p>
<p><strong>dev：</strong>保存申请到的设备号。</p>
<p><strong>baseminor：</strong>次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。</p>
<p><strong>count：</strong>要申请的设备号数量。</p>
<p><strong>name：</strong>设备名字。</p>
<p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure>

<p>此函数有两个参数：</p>
<p><strong>from：</strong>要释放的设备号。</p>
<p><strong>count：</strong>表示从 from 开始，要释放的设备号数量。</p>
<h2 id="新字符设备驱动"><a href="#新字符设备驱动" class="headerlink" title="新字符设备驱动"></a>新字符设备驱动</h2><p>字符设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备的时候就使用unregister_chrdev 函数注销字符设备，驱动模块加载成功以后还需要手动使用 mknod 命令创建设备节点。register_chrdev 和 unregister_chrdev 这两个函数是老版本驱动使用的函数，现在新的字符设备驱动已经不再使用这两个函数，而是使用Linux内核推荐的新字符设备驱动API函数。本节我们就来学习一下如何编写新字符设备驱动，并且在驱动模块加载的时候自动创建设备节点文件。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h4><p>使用 register_chrdev 函数注册字符设备的时候只需要给定一个主设备号即可，但是这样会带来两个问题：</p>
<p>①、需要我们事先确定好哪些主设备号没有使用。</p>
<p>②、会将一个主设备号下的所有次设备号都使用掉，比如现在设置 LED 这个主设备号为200，那么 0~1048575(2^20-1)这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。</p>
<p>解决这两个问题最好的方法就是要使用设备号的时候向 Linux 内核申请，需要几个就申请几个，由 Linux 内核分配设备可以使用的设备号。这个就是我们在 40.3.2 小节讲解的设备号的分配，如果没有指定设备号的话就使用如下函数来申请设备号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure>

<p>如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure>

<p>参数 from 是要申请的起始设备号，也就是给定的设备号；参数 count 是要申请的数量，一般都是一个；参数 name 是设备名字。</p>
<p>注销字符设备之后要释放掉设备号 ， 不管是通过 alloc_chrdev_region 函数还是register_chrdev_region 函数申请的设备号，统一使用如下释放函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure>

<p>新字符设备驱动下，设备号分配示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.1.1 新字符设备驱动下设备号分配</span><br><span class="hljs-number">1</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">4</span> <br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> (major) &#123; <span class="hljs-comment">/* 定义了主设备号 */</span><br><span class="hljs-number">6</span> 		devid = MKDEV(major, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 大部分驱动次设备号都选择 0*/</span><br><span class="hljs-number">7</span> 		register_chrdev_region(devid, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-number">8</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 没有定义设备号 */</span><br><span class="hljs-number">9</span> 		alloc_chrdev_region(&amp;devid, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">/* 申请设备号 */</span><br><span class="hljs-number">10</span> 		major = MAJOR(devid); <span class="hljs-comment">/* 获取分配号的主设备号 */</span><br><span class="hljs-number">11</span> 		minor = MINOR(devid); <span class="hljs-comment">/* 获取分配号的次设备号 */</span><br><span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure>

<p>第 1-3 行，定义了主&#x2F;次设备号变量 major 和 minor，以及设备号变量 devid。</p>
<p>第 5 行，判断主设备号 major 是否有效，在 Linux 驱动中一般给出主设备号的话就表示这个设备的设备号已经确定了，因为次设备号基本上都选择 0，这算个 Linux 驱动开发中约定俗成的一种规定了。</p>
<p>第 6 行，如果 major 有效的话就使用 MKDEV 来构建设备号，次设备号选择 0。</p>
<p>第 7 行，使用 register_chrdev_region 函数来注册设备号。</p>
<p>第 9-11 行，如果 major 无效，那就表示没有给定设备号。此时就要使用 alloc_chrdev_region函数来申请设备号。设备号申请成功以后使用 MAJOR 和 MINOR 来提取出主设备号和次设备号，当然了，第 10 和 11 行提取主设备号和次设备号的代码可以不要。</p>
<p>如果要注销设备号的话，使用如下代码即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">unregister_chrdev_region(devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 注销设备号 */</span><br></code></pre></td></tr></table></figure>

<p>注销设备号的代码很简单。</p>
<h4 id="新的字符设备注册方法"><a href="#新的字符设备注册方法" class="headerlink" title="新的字符设备注册方法"></a>新的字符设备注册方法</h4><h5 id="字符设备结构"><a href="#字符设备结构" class="headerlink" title="字符设备结构"></a>字符设备结构</h5><p>在 Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.1 cdev 结构体</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><br><span class="hljs-number">2</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-number">4</span> 		<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-number">5</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-number">6</span> 		<span class="hljs-type">dev_t</span> dev;<br><span class="hljs-number">7</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;<br><span class="hljs-number">8</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>在 cdev 中有两个重要的成员变量：ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">test_cdev</span>;</span><br></code></pre></td></tr></table></figure>

<h5 id="cdev-init-函数"><a href="#cdev-init-函数" class="headerlink" title="cdev_init 函数"></a>cdev_init 函数</h5><p>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *cdev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><br></code></pre></td></tr></table></figure>

<p>参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。使用 cdev_init 函数初始化 cdev 变量的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.2 cdev_init 函数使用示例代码</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">5</span> 		.owner = THIS_MODULE,<br><span class="hljs-number">6</span> 		<span class="hljs-comment">/* 其他具体的初始项 */</span><br><span class="hljs-number">7</span> &#125;;<br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<br><span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量 */</span><br></code></pre></td></tr></table></figure>

<h5 id="cdev-add-函数"><a href="#cdev-add-函数" class="headerlink" title="cdev_add 函数"></a>cdev_add 函数</h5><p>cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。cdev_add 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cdev_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">dev_t</span> dev, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure>

<p>参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。完善示例代码 42.1.2.2，加入 cdev_add 函数，内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.2 cdev_add 函数使用示例</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">5</span> 		.owner = THIS_MODULE,<br><span class="hljs-number">6</span> 		<span class="hljs-comment">/* 其他具体的初始项 */</span><br><span class="hljs-number">7</span> &#125;;<br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<br><span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量 */</span><br><span class="hljs-number">11</span> cdev_add(&amp;testcdev, devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 添加字符设备 */</span><br></code></pre></td></tr></table></figure>

<p>示例代码 42.1.2.2 就是新的注册字符设备代码段，Linux 内核中大量的字符设备驱动都是采用这种方法向 Linux 内核添加字符设备。如果在加上示例代码 42.1.1.1 中分配设备号的程序，那么就它们一起实现的就是函数 register_chrdev 的功能。</p>
<h5 id="cdev-del-函数"><a href="#cdev-del-函数" class="headerlink" title="cdev_del 函数"></a>cdev_del 函数</h5><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备，cdev_del函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p)</span><br></code></pre></td></tr></table></figure>

<p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.3 cdev_del 函数使用示例</span><br><span class="hljs-number">1</span> cdev_del(&amp;testcdev); <span class="hljs-comment">/* 删除 cdev */</span><br></code></pre></td></tr></table></figure>

<p>cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。</p>
<h3 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h3><p>在前面的 Linux 驱动实验中，当我们使用 modprobe 加载驱动程序以后还需要使用命令“mknod”手动创建设备节点。本节就来讲解一下如何实现自动创建设备节点，在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在&#x2F;dev 目录下创建对应的设备文件。</p>
<h4 id="mdev-机制"><a href="#mdev-机制" class="headerlink" title="mdev 机制"></a>mdev 机制</h4><p>udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除，udev 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在&#x2F;dev 目录下创建对应的设备节点文件,使用rmmod 命令卸载驱动模块以后就删除掉&#x2F;dev 目录下的设备节点文件。使用 busybox 构建根文件系统的时候，busybox 会创建一个 udev 的简化版本—mdev，所以在嵌入式 Linux 中我们使用mdev 来实现设备节点文件的自动创建与删除，Linux 系统中的热插拔事件也由 mdev 管理，在&#x2F;etc&#x2F;init.d&#x2F;rcS 文件中如下语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug<br></code></pre></td></tr></table></figure>

<p>上述命令设置热插拔事件由 mdev 来管理，关于 udev 或 mdev 更加详细的工作原理这里就不详细探讨了，我们重点来学习一下如何通过 mdev 来实现设备文件节点的自动创建与删除。</p>
<h4 id="创建和删除类"><a href="#创建和删除类" class="headerlink" title="创建和删除类"></a>创建和删除类</h4><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类，class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。class_create 是类创建函数，class_create 是个宏定义，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.2.1.1 class_create 函数</span><br><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> class_create(owner, name) \</span><br><span class="hljs-meta">2 (&#123; \</span><br><span class="hljs-meta">3 		static struct lock_class_key __key; \</span><br><span class="hljs-meta">4 		__class_create(owner, name, &amp;__key); \</span><br><span class="hljs-meta">5 &#125;)</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *__<span class="hljs-title">class_create</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *<span class="hljs-title">name</span>, <span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> *<span class="hljs-title">key</span>)</span><br></code></pre></td></tr></table></figure>

<p>根据上述代码，将宏 class_create 展开以后内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> class *<span class="hljs-title function_">class_create</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure>

<p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。返回值是个指向结构体 class 的指针，也就是创建的类。</p>
<p>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">class_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *cls)</span>;<br></code></pre></td></tr></table></figure>

<p>参数 cls 就是要删除的类。</p>
<h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>上一小节创建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设备。使用 device_create 函数在类下面创建设备，device_create 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device *<span class="hljs-title function_">device_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> device *parent,<span class="hljs-type">dev_t</span> devt, <span class="hljs-type">void</span> *drvdata, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br></code></pre></td></tr></table></figure>

<p>device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。返回值就是创建好的设备。</p>
<p>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">device_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-type">dev_t</span> devt)</span><br></code></pre></td></tr></table></figure>

<p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p>
<h4 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h4><p>在驱动入口函数里面创建类和设备，在驱动出口函数里面删除类和设备，参考示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码 42.2.3.1 创建/删除类/设备参考代码</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> 			<span class="hljs-comment">/* 类 */</span> <br><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> 		<span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; 					<span class="hljs-comment">/* 设备号 */</span> <br><span class="hljs-number">4</span> <br><span class="hljs-number">5</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>7 &#123;<br><span class="hljs-number">8</span> 		<span class="hljs-comment">/* 创建类 */</span><br><span class="hljs-number">9</span> 		<span class="hljs-class"><span class="hljs-keyword">class</span> =</span> class_create(THIS_MODULE, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">10</span> 		<span class="hljs-comment">/* 创建设备 */</span><br><span class="hljs-number">11</span> 		device = device_create(class, <span class="hljs-literal">NULL</span>, devid, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">12</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>17 &#123;<br><span class="hljs-number">18</span> 		<span class="hljs-comment">/* 删除设备 */</span><br><span class="hljs-number">19</span> 		device_destroy(newchrled.class, newchrled.devid);<br><span class="hljs-number">20</span> 		<span class="hljs-comment">/* 删除类 */</span><br><span class="hljs-number">21</span> 		class_destroy(newchrled.class);<br><span class="hljs-number">22</span> &#125;<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span> module_init(led_init);<br><span class="hljs-number">25</span> module_exit(led_exit);<br></code></pre></td></tr></table></figure>

<h3 id="设置文件私有数据"><a href="#设置文件私有数据" class="headerlink" title="设置文件私有数据"></a>设置文件私有数据</h3><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.3.1 变量形式的设备属性</span><br><span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br></code></pre></td></tr></table></figure>

<p>这样写肯定没有问题，但是这样写不专业！对于一个设备的所有属性信息我们最好将其做成一个结构体。编写驱动 open 函数的时候将设备结构体作为私有数据添加到设备文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.3.2 设备结构体作为私有数据</span><br><span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span>&#123;</span><br><span class="hljs-number">2</span> 		<span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">3</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-number">4</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-number">5</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">6</span> 		<span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">7</span> 		<span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">8</span> &#125;;<br><span class="hljs-number">9</span> <br><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span> <span class="hljs-title">testdev</span>;</span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> <span class="hljs-comment">/* open 函数 */</span><br><span class="hljs-number">13</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>14 &#123;<br><span class="hljs-number">15</span> 		filp-&gt;private_data = &amp;testdev; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-number">16</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">17</span> &#125;<br></code></pre></td></tr></table></figure>

<p>在 open 函数里面设置好私有数据以后，在 write、read、close 等函数中直接读取 private_data即可得到设备结构体。</p>
<h3 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码 42.5.1.1 newchrled.c 文件</span><br><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><span class="hljs-number">14</span> <br><span class="hljs-number">25</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_CNT 1 <span class="hljs-comment">/* 设备号个数 */</span></span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_NAME <span class="hljs-string">&quot;newchrled&quot;</span> <span class="hljs-comment">/* 名字 */</span></span><br><span class="hljs-number">27</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0 <span class="hljs-comment">/* 关灯 */</span></span><br><span class="hljs-number">28</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1 <span class="hljs-comment">/* 开灯 */</span></span><br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span> <span class="hljs-comment">/* 寄存器物理地址 */</span><br><span class="hljs-number">31</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE (0X020C406C) </span><br><span class="hljs-number">32</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span><br><span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE (0X020E02F4)</span><br><span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE (0X0209C000)</span><br><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE (0X0209C004)</span><br><span class="hljs-number">36</span> <br><span class="hljs-number">37</span> <span class="hljs-comment">/* 映射后的寄存器虚拟地址指针 */</span><br><span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<br><span class="hljs-number">39</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<br><span class="hljs-number">40</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<br><span class="hljs-number">41</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<br><span class="hljs-number">42</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<br><span class="hljs-number">43</span> <br><span class="hljs-number">44</span> <span class="hljs-comment">/* newchrled 设备结构体 */</span><br><span class="hljs-number">45</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span>&#123;</span><br><span class="hljs-number">46</span> 		<span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">47</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-number">48</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-number">49</span> 		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">50</span> 		<span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">51</span> 		<span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">52</span> &#125;;<br><span class="hljs-number">53</span> <br><span class="hljs-number">54</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span> <span class="hljs-title">newchrled</span>;</span> <span class="hljs-comment">/* led 设备 */</span><br><span class="hljs-number">55</span> <br><span class="hljs-number">56</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">57 * @description : LED 打开/关闭</span><br><span class="hljs-comment">58 * @param - sta : LEDON(0) 打开 LED，LEDOFF(1) 关闭 LED</span><br><span class="hljs-comment">59 * @return : 无</span><br><span class="hljs-comment">60 */</span><br><span class="hljs-number">61</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(u8 sta)</span><br>62 &#123;<br><span class="hljs-number">63</span> 		u32 val = <span class="hljs-number">0</span>;<br><span class="hljs-number">64</span> 		<span class="hljs-keyword">if</span> (sta == LEDON) &#123;<br><span class="hljs-number">65</span> 			val = readl(GPIO1_DR);<br><span class="hljs-number">66</span> 			val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <br><span class="hljs-number">67</span> 			writel(val, GPIO1_DR);<br><span class="hljs-number">68</span> 		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF) &#123;<br><span class="hljs-number">69</span> 			val = readl(GPIO1_DR);<br><span class="hljs-number">70</span> 			val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);<br><span class="hljs-number">71</span> 			writel(val, GPIO1_DR);<br><span class="hljs-number">72</span> 		&#125; <br><span class="hljs-number">73</span> &#125;<br><span class="hljs-number">74</span> <br><span class="hljs-number">75</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">76 * @description : 打开设备</span><br><span class="hljs-comment">77 * @param – inode : 传递给驱动的 inode</span><br><span class="hljs-comment">78 * @param - filp : 设备文件，file 结构体有个叫做 private_data 的成员变量</span><br><span class="hljs-comment">79 * 一般在 open 的时候将 private_data 指向设备结构体。</span><br><span class="hljs-comment">80 * @return : 0 成功;其他 失败</span><br><span class="hljs-comment">81 */</span><br><span class="hljs-number">82</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>83 &#123;<br><span class="hljs-number">84</span> 		filp-&gt;private_data = &amp;newchrled; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-number">85</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">86</span> &#125;<br><span class="hljs-number">87</span> <br><span class="hljs-number">88</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">89 * @description : 从设备读取数据</span><br><span class="hljs-comment">90 * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment">91 * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment">92 * @param - cnt : 要读取的数据长度</span><br><span class="hljs-comment">93 * @param – offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment">94 * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment">95 */</span><br><span class="hljs-number">96</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>97 &#123;<br><span class="hljs-number">98</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">99</span> &#125;<br><span class="hljs-number">100</span><br><span class="hljs-number">101</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">102 * @description : 向设备写数据</span><br><span class="hljs-comment">103 * @param – filp : 设备文件，表示打开的文件描述符</span><br><span class="hljs-comment">104 * @param - buf : 要写给设备写入的数据</span><br><span class="hljs-comment">105 * @param - cnt : 要写入的数据长度</span><br><span class="hljs-comment">106 * @param – offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment">107 * @return : 写入的字节数，如果为负值，表示写入失败</span><br><span class="hljs-comment">108 */</span><br><span class="hljs-number">109</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>110 &#123;<br><span class="hljs-number">111</span> 		<span class="hljs-type">int</span> retvalue;<br><span class="hljs-number">112</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<br><span class="hljs-number">113</span> 		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><span class="hljs-number">114</span>		<br><span class="hljs-number">115</span> 		retvalue = copy_from_user(databuf, buf, cnt);<br><span class="hljs-number">116</span> 		<span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">117</span> 			printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<br><span class="hljs-number">118</span> 			<span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">119</span> 		&#125;<br><span class="hljs-number">120</span><br><span class="hljs-number">121</span> 		ledstat = databuf[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* 获取状态值 */</span><br><span class="hljs-number">122</span>		<br><span class="hljs-number">123</span> 		<span class="hljs-keyword">if</span>(ledstat == LEDON) &#123; <br><span class="hljs-number">124</span> 			led_switch(LEDON); <span class="hljs-comment">/* 打开 LED 灯 */</span><br><span class="hljs-number">125</span> 		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;<br><span class="hljs-number">126</span> 			led_switch(LEDOFF); <span class="hljs-comment">/* 关闭 LED 灯 */</span><br><span class="hljs-number">127</span> 		&#125;<br><span class="hljs-number">128</span> 		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">129</span> &#125;<br><span class="hljs-number">130</span><br><span class="hljs-number">131</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">132 * @description : 关闭/释放设备</span><br><span class="hljs-comment">133 * @param – filp : 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment">134 * @return : 0 成功;其他 失败</span><br><span class="hljs-comment">135 */</span><br><span class="hljs-number">136</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>137 &#123;<br><span class="hljs-number">138</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">139</span> &#125;<br><span class="hljs-number">140</span><br><span class="hljs-number">141</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">142</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">newchrled_fops</span> =</span> &#123;<br><span class="hljs-number">143</span> 	.owner = THIS_MODULE,<br><span class="hljs-number">144</span> 	.open = led_open,<br><span class="hljs-number">145</span> 	.read = led_read,<br><span class="hljs-number">146</span> 	.write = led_write,<br><span class="hljs-number">147</span> 	.release = led_release,<br><span class="hljs-number">148</span> &#125;;<br><span class="hljs-number">149</span><br><span class="hljs-number">150</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">151 * @description : 驱动入口函数</span><br><span class="hljs-comment">152 * @param : 无</span><br><span class="hljs-comment">153 * @return : 无</span><br><span class="hljs-comment">154 */</span><br><span class="hljs-number">155</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>156 &#123;<br><span class="hljs-number">157</span> 	u32 val = <span class="hljs-number">0</span>;<br><span class="hljs-number">158</span>	<br><span class="hljs-number">159</span> 	<span class="hljs-comment">/* 初始化 LED */</span><br><span class="hljs-number">160</span> 	<span class="hljs-comment">/* 1、寄存器地址映射 */</span><br><span class="hljs-number">161</span> 	IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">162</span> 	SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">163</span> 	SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">164</span> 	GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">165</span> 	GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">166</span>	<br><span class="hljs-number">167</span> 	<span class="hljs-comment">/* 2、使能 GPIO1 时钟 */</span><br><span class="hljs-number">168</span> 	val = readl(IMX6U_CCM_CCGR1);<br><span class="hljs-number">169</span> 	val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>); <span class="hljs-comment">/* 清楚以前的设置 */</span><br><span class="hljs-number">170</span> 	val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>); <span class="hljs-comment">/* 设置新值 */</span><br><span class="hljs-number">171</span> 	writel(val, IMX6U_CCM_CCGR1);<br><span class="hljs-number">172</span>	<br><span class="hljs-number">173</span> 	<span class="hljs-comment">/* 3、设置 GPIO1_IO03 的复用功能，将其复用为</span><br><span class="hljs-comment">174 	* GPIO1_IO03，最后设置 IO 属性。</span><br><span class="hljs-comment">175 	*/</span><br><span class="hljs-number">176</span> 	writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);<br><span class="hljs-number">177</span> 	<br><span class="hljs-number">178</span> 	<span class="hljs-comment">/* 寄存器 SW_PAD_GPIO1_IO03 设置 IO 属性 */</span><br><span class="hljs-number">179</span> 	writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<br><span class="hljs-number">180</span>	<br><span class="hljs-number">181</span> 	<span class="hljs-comment">/* 4、设置 GPIO1_IO03 为输出功能 */</span><br><span class="hljs-number">182</span> 	val = readl(GPIO1_GDIR);<br><span class="hljs-number">183</span> 	val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <span class="hljs-comment">/* 清除以前的设置 */</span><br><span class="hljs-number">184</span> 	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <span class="hljs-comment">/* 设置为输出 */</span><br><span class="hljs-number">185</span> 	writel(val, GPIO1_GDIR);<br><span class="hljs-number">186</span>	<br><span class="hljs-number">187</span> 	<span class="hljs-comment">/* 5、默认关闭 LED */</span><br><span class="hljs-number">188</span> 	val = readl(GPIO1_DR);<br><span class="hljs-number">189</span> 	val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <br><span class="hljs-number">190</span> 	writel(val, GPIO1_DR);<br><span class="hljs-number">191</span>	<br><span class="hljs-number">192</span> 	<span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">193</span> 	<span class="hljs-comment">/* 1、创建设备号 */</span><br><span class="hljs-number">194</span> 	<span class="hljs-keyword">if</span> (newchrled.major) &#123; <span class="hljs-comment">/* 定义了设备号 */</span><br><span class="hljs-number">195</span> 		newchrled.devid = MKDEV(newchrled.major, <span class="hljs-number">0</span>);<br><span class="hljs-number">196</span> 		register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);<br><span class="hljs-number">197</span> 	&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 没有定义设备号 */</span><br><span class="hljs-number">198</span> 		alloc_chrdev_region(&amp;newchrled.devid, <span class="hljs-number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME); <span class="hljs-comment">/* 申请设备号 */</span><br><span class="hljs-number">199</span> 		newchrled.major = MAJOR(newchrled.devid); <span class="hljs-comment">/* 获取主设备号 */</span><br><span class="hljs-number">200</span> 		newchrled.minor = MINOR(newchrled.devid); <span class="hljs-comment">/* 获取次设备号 */</span><br><span class="hljs-number">201</span> 	&#125;<br><span class="hljs-number">202</span> 	printk(<span class="hljs-string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor);<br><span class="hljs-number">203</span> 	<br><span class="hljs-number">204</span> 	<span class="hljs-comment">/* 2、初始化 cdev */</span><br><span class="hljs-number">205</span> 	newchrled.cdev.owner = THIS_MODULE;<br><span class="hljs-number">206</span> 	cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);<br><span class="hljs-number">207</span> 	<br><span class="hljs-number">208</span> 	<span class="hljs-comment">/* 3、添加一个 cdev */</span><br><span class="hljs-number">209</span> 	cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);<br><span class="hljs-number">210</span>	<br><span class="hljs-number">211</span> 	<span class="hljs-comment">/* 4、创建类 */</span><br><span class="hljs-number">212</span> 	newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME);<br><span class="hljs-number">213</span> 	<span class="hljs-keyword">if</span> (IS_ERR(newchrled.class)) &#123;<br><span class="hljs-number">214</span> 		<span class="hljs-keyword">return</span> PTR_ERR(newchrled.class);<br><span class="hljs-number">215</span> 	&#125;<br><span class="hljs-number">216</span>	<br><span class="hljs-number">217</span> 	<span class="hljs-comment">/* 5、创建设备 */</span><br><span class="hljs-number">218</span> 	newchrled.device = device_create(newchrled.class, <span class="hljs-literal">NULL</span>, newchrled.devid, <span class="hljs-literal">NULL</span>, NEWCHRLED_NAME);<br><span class="hljs-number">219</span> 	<span class="hljs-keyword">if</span> (IS_ERR(newchrled.device)) &#123;<br><span class="hljs-number">220</span> 		<span class="hljs-keyword">return</span> PTR_ERR(newchrled.device);<br><span class="hljs-number">221</span> 	&#125;<br><span class="hljs-number">222</span> 	<br><span class="hljs-number">223</span> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">224</span> &#125;<br><span class="hljs-number">225</span><br><span class="hljs-number">226</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">227 * @description : 驱动出口函数</span><br><span class="hljs-comment">228 * @param : 无</span><br><span class="hljs-comment">229 * @return : 无</span><br><span class="hljs-comment">230 */</span><br><span class="hljs-number">231</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>232 &#123;<br><span class="hljs-number">233</span> 	<span class="hljs-comment">/* 取消映射 */</span><br><span class="hljs-number">234</span> 	iounmap(IMX6U_CCM_CCGR1);<br><span class="hljs-number">235</span> 	iounmap(SW_MUX_GPIO1_IO03);<br><span class="hljs-number">236</span> 	iounmap(SW_PAD_GPIO1_IO03);<br><span class="hljs-number">237</span> 	iounmap(GPIO1_DR);<br><span class="hljs-number">238</span> 	iounmap(GPIO1_GDIR);<br><span class="hljs-number">239</span>	<br><span class="hljs-number">240</span> 	<span class="hljs-comment">/* 注销字符设备 */</span><br><span class="hljs-number">241</span> 	cdev_del(&amp;newchrled.cdev);<span class="hljs-comment">/* 删除 cdev */</span><br><span class="hljs-number">242</span> 	unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT);<br><span class="hljs-number">243</span>	<br><span class="hljs-number">244</span> 	device_destroy(newchrled.class, newchrled.devid);<br><span class="hljs-number">245</span> 	class_destroy(newchrled.class);<br><span class="hljs-number">246</span> &#125;<br><span class="hljs-number">247</span><br><span class="hljs-number">248</span> module_init(led_init);<br><span class="hljs-number">249</span> module_exit(led_exit);<br><span class="hljs-number">250</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-number">251</span> MODULE_AUTHOR(<span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>第 25 行，宏 NEWCHRLED_CNT 表示设备数量，在申请设备号或者向 Linux 内核添加字符设备的时候需要设置设备数量，一般我们一个驱动一个设备，所以这个宏为 1。</p>
<p>第 26 行，宏 NEWCHRLED_NAME 表示设备名字，本实验的设备名为“newchrdev”，为了方便管理，所有使用到设备名字的地方统一使用此宏，当驱动加载成功以后就生成&#x2F;dev&#x2F;newchrled 这个设备文件。</p>
<p>第 44-52 行，创建设备结构体 newchrled_dev。</p>
<p>第 54 行，定义一个设备结构体变量 newchrdev，此变量表示 led 设备。</p>
<p>第 82-86 行，在 led_open 函数中设置文件的私有数据 private_data 指向 newchrdev。</p>
<p>第 194-221 行，根据前面讲解的方法在驱动入口函数 led_init 中申请设备号、添加字符设备、创建类和设备。本实验我们采用动态申请设备号的方法，第 202 行使用 printk 在终端上显示出申请到的主设备号和次设备号。</p>
<p>第 241-245 行，根据前面讲解的方法，在驱动出口函数 led_exit 中注销字符新设备、删除类和设备。</p>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.yuanzige.com/">www.yuanzige.com</a></li>
<li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="category-chain-item">字符设备驱动</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="print-no-link">#字符设备驱动</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>字符设备驱动</div>
      <div>https://tomwithkernel.github.io/字符设备驱动/字符设备驱动/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tom</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月9日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年12月26日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" title="内核定时器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">内核定时器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E4%B8%AD%E6%96%AD/linux%E4%B8%AD%E6%96%AD/" title="Linux中断">
                        <span class="hidden-mobile">Linux中断</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"mGugYoHICpLi8BnBygCpEblQ-MdYXbMMI","appKey":"jxVWH2hG2DLvf0KjiGZ93acw","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://tomwithkernel.github.io/" target="_blank" rel="nofollow noopener"><span>Tom</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/TomWithKernel/kernel" target="_blank" rel="nofollow noopener"><span>repository</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
