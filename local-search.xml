<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kgdb</title>
    <link href="/dbg_meth/kgdb/"/>
    <url>/dbg_meth/kgdb/</url>
    
    <content type="html"><![CDATA[<h2 id="KGDB"><a href="#KGDB" class="headerlink" title="KGDB"></a>KGDB</h2><p>kgdb是Linux内核提供的用于调试内核的源码级调试工具，支持断点设置，单步调试等源码调试常用功能，类似于在用户空间用gdb调试应用程序。kgdb从形式上来说类似于gdb server，你需要两台设备，一台主机，用于运行普通的gdb程序，一台被调试设备，需要安装所需调试的内核或者驱动，同时运行kgdb。kgdb与主机通过串口通讯，所以要在内核的启动参数里指定kgdb所需使用的串口设备号。</p><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h3><table><thead><tr><th>配置名称</th><th>作用</th></tr></thead><tbody><tr><td>CONFIG_KGDB_SERIAL_CONSOLE</td><td>使KGDB通过串口与主机通信(使用串口KGDB时必须打开)</td></tr><tr><td>CONFIG_KGDB_KDB</td><td>打开KGDB调试+KDB支持</td></tr><tr><td>CONFIG_DEBUG_INFO</td><td>使内核包含基本调试信息</td></tr><tr><td>CONFIG_DEBUG_KERNEL</td><td>包含驱动调试信息</td></tr><tr><td>CONFIG_GDB_SCRIPTS</td><td>用于支持vmlinux-gdb.py扩展</td></tr></tbody></table><h3 id="设置kgdboc参数"><a href="#设置kgdboc参数" class="headerlink" title="设置kgdboc参数"></a>设置kgdboc参数</h3><p><code>kgdboc</code> 是kgdb over consle的缩写，用来指定内核调试信息从哪里输出，这里我们使用了ttyUSB0串口输出，未来gdb便需要连接到对应串口来接收调试数据。</p><p><code>kgdbwait</code> 该参数可以让内核启动时准备好数据后等待gdb接入再继续启动内核。</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>主要用于调试内核初始化，在kernel的启动参数上添加<code>kgdboc=ttyXXX,115200 kgdbwait</code>，前者设置测试机使用的串口，后者数字设置波特率。</p><div class="note note-warning">            <p>​kgdbwait这个字符串的作用就是让内核停在刚启动的地方。</p>          </div><img src="/dbg_meth/kgdb/grub.png" class="" title="grub"><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​在系统启动后，设置进入kgdb模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置调试串口</span><br>echo &quot;kgdboc=ttyXXX,115200&quot; &gt; /sys/module/kgdboc/parameters/kgdboc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置魔术键，g就是进行KGDB模式</span><br>echo g &gt; /proc/sysrq-trigger<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>​这里设置魔术键执行完后，测试机进入kgdb模块，这时测试机按任何键都不会有任何反应，内核等待接受gdb调试请求</p>          </div><h3 id="设置主机串口"><a href="#设置主机串口" class="headerlink" title="设置主机串口"></a>设置主机串口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install minicom<br>sudo minicom -s<br></code></pre></td></tr></table></figure><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>首先，在主机上安装gdb-multiarch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gdb-multiarch<br></code></pre></td></tr></table></figure><p>进入到内核源码根目录，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gdb-multiarch vmlinux<br></code></pre></td></tr></table></figure><p>我们需要设置目标平台，串口波特率，并且通过串口连接到开发板上的kgdb上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设备目标平台</span><br>set architecture aarch64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置串口波特率</span><br>set serial baud 115200<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主机通过串口连接到开发板上的kgdb</span><br>target remote /dev/ttyUSB0<br></code></pre></td></tr></table></figure><p>设置成功后会有如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set architecture aarch64<br>The target architecture is assumed to be aarch64<br>(gdb) set serial baud 115200<br>(gdb) target remote /dev/ttyUSB0<br>Remote debugging using /dev/ttyUSB0<br>arch_kgdb_breakpoint () at ./arch/arm64/include/asm/kgdb.h:21<br>21asm (&quot;brk %0&quot; : : &quot;I&quot; (KGDB_COMPILED_DBG_BRK_IMM));<br></code></pre></td></tr></table></figure><h3 id="agent-proxy"><a href="#agent-proxy" class="headerlink" title="agent-proxy"></a>agent-proxy</h3><p>kgdb目前有一个问题，它和测试机的Linux终端共用一个串口，所以在进行信息输出的时候无法使用kgdb，因为kgdb还等着使用该串口，一般测试机只有一个串口，这就给调试带来了很大的麻烦，因为一般驱动是要应用程序调用的，也就是说我在调试时可能需要不停的在kgdb和终端之间来回切换，因为经常需要运行程序，停下程序，甚至输入一些参数。而且在实际的过程当中，切换也会有问题。</p><p>官网解释：</p><img src="/dbg_meth/kgdb/kgdb_bug.png" class="" title="kgdb"><p>也就是说官网目前已知该问题</p><p>这时我们需要一个工具agent-proxy</p><p>源码地址：<a href="https://git.kernel.org/pub/scm/utils/kernel/kgdb/agent-proxy.git/">https://git.kernel.org/pub/scm/utils/kernel/kgdb/agent-proxy.git/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://git.kernel.org/cgit/utils/kernel/kgdb/agent-proxy.git/<br></code></pre></td></tr></table></figure><p>下载源码后。在源码目录下直接<code>make</code>即可，然后创建软连接到&#x2F;bin目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /media/uos/work_kernel/agent-proxy-1.97/agent-proxy /usr/bin/agent-proxy<br></code></pre></td></tr></table></figure><h4 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h4><p>启动代理，将串口映射成两个本地网络端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">agent-proxy 5550^5551 0 /dev/ttyUSB0,115200<br></code></pre></td></tr></table></figure><p>telnet登录一个端口，充当控制台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet localhost 5550<br></code></pre></td></tr></table></figure><p>gdb连接另一个端口，充当调试通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">target remote localhost:5551<br></code></pre></td></tr></table></figure><h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><p>如果调试某个驱动我们需要打开驱动文件所在rootfs文件夹，使用<code>insmod</code>安装.ko驱动，然后输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cat /sys/module/usbhid/sections/.text<br><br>0xffffffffc014d000<br></code></pre></td></tr></table></figure><p>为什么要获取这个.text信息：</p><p>直接用.ko文件调试，可能无法设置断点，在内核模块的调试中，GDB 需要知道模块代码在内存中的实际位置，以便正确设置断点。如果内核启用了 <code>CONFIG_RANDOMIZE_BASE</code>（即启用地址随机化），模块的加载地址可能会发生变化，通过获取模块的 <code>.text</code> 段的实际地址，调试工具可以根据这些信息来调整断点的位置。</p><p>解决地址随机化问题：</p><p>在内核中启用了地址随机化（KASLR，Kernel Address Space Layout Randomization）时，内核模块的加载地址会被随机化，这使得直接在源代码中设置断点变得困难。获取模块的 <code>.text</code> 段信息有助于了解实际的加载地址，从而在调试时提供正确的断点信息。</p><p>也可以在启动参数添加<code>nokaslr kgdboc=ttyUSB0,115200 kgdbwait</code></p><p>接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo g &gt; /proc/sysrq-trigger<br></code></pre></td></tr></table></figure><p>这个指令是触发kgdb运行的，输入该指令后，内核就会停下，等待远端gdb连接。</p><p>然后在主机打开新的终端，进入驱动源码所在目录，输入如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gdb-multiarch<br>(gdb) set architecture aarch64<br>The target architecture is assumed to be aarch64<br>(gdb) set serial baud 115200<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将这个地址信息告知 GDB，以便它可以正确地设置断点</span><br>(gdb) add-symbol-file /path/to/usbhid.ko 0xffffffffc014d000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主机通过串口连接到测试机上的kgdb</span><br>(gdb) target remote localhost:5551<br></code></pre></td></tr></table></figure><h4 id="add-symbol-file"><a href="#add-symbol-file" class="headerlink" title="add-symbol-file"></a>add-symbol-file</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) add-symbol-file &#123;filename&#125; &#123;addr&#125;<br></code></pre></td></tr></table></figure><p><code>&#123;filename&#125;</code> 是你要加载的符号文件的路径，通常是一个带有调试符号的可执行文件或库文件。</p><p><code>&#123;addr&#125;</code> 是该符号文件在内存中的基地址（装载地址），告诉 GDB 这个文件的代码段被加载到哪个内存地址上。</p><p><code>add-symbol-file</code> 命令在 GDB 中用于动态加载调试符号文件，并指定该文件的装载地址。它的作用是告诉 GDB 某个特定的二进制文件在内存中的加载位置，以便调试。</p><p>如果你的系统有很多ko，这将是很麻烦的事情，所以我们进行替代使用<code>lx-symbols</code>命令，可以自动查找所有ko文件并加载符号。</p><p>首先执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) add-auto-load-safe-path ./#指定./路径为可信的路径，便于gdb执行启动的python脚本<br>(gdb) file vmlinux#指定符号文件<br>(gdb) source vmlinux-gdb.py#执行./vmlinux-gdb.py添加环境用于kgdb的命令扩展<br>(gdb) target remote localhost:5551<br></code></pre></td></tr></table></figure><h3 id="kgdb扩展命令"><a href="#kgdb扩展命令" class="headerlink" title="kgdb扩展命令"></a>kgdb扩展命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) lx-<br>lx-clk-summary        lx-device-list-class  lx-iomem              lx-ps<br>lx-cmdline            lx-device-list-tree   lx-ioports            lx-symbols<br>lx-configdump         lx-dmesg              lx-list-check         lx-timerlist<br>lx-cpus               lx-fdtdump            lx-lsmod              lx-version<br>lx-device-list-bus    lx-genpd-summary      lx-mounts  <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) apropos lx<br>function lx_clk_core_lookup -- Find struct clk_core by name<br>function lx_current -- Return current task<br>function lx_device_find_by_bus_name -- Find struct device by bus and name (both strings)<br>function lx_device_find_by_class_name -- Find struct device by class and name (both strings)<br>function lx_module -- Find module by name and return the module variable<br>function lx_per_cpu -- Return per-cpu variable<br>function lx_rb_first -- Lookup and return a node from an RBTree<br>function lx_rb_last -- Lookup and return a node from an RBTree<br>function lx_rb_next -- Lookup and return a node from an RBTree<br>function lx_rb_prev -- Lookup and return a node from an RBTree<br>function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable<br>function lx_thread_info -- Calculate Linux thread_info from task variable<br>function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid<br>lx-clk-summary -- Print clk tree summary<br>lx-cmdline --  Report the Linux Commandline used in the current kernel<br>lx-configdump -- Output kernel config to the filename specified as the command<br>lx-cpus -- List CPU status arrays<br>lx-device-list-bus -- Print devices on a bus (or all buses if not specified)<br>lx-device-list-class -- Print devices in a class (or all classes if not specified)<br>lx-device-list-tree -- Print a device and its children recursively<br>lx-dmesg -- Print Linux kernel log buffer<br>lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename<br>lx-genpd-summary -- Print genpd summary<br>lx-iomem -- Identify the IO memory resource locations defined by the kernel<br>lx-ioports -- Identify the IO port resource locations defined by the kernel<br>lx-list-check -- Verify a list consistency<br>lx-lsmod -- List currently loaded modules<br>lx-mounts -- Report the VFS mounts of the current process namespace<br>lx-ps -- Dump Linux tasks<br>lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules<br>lx-timerlist -- Print /proc/timer_list<br>lx-version --  Report the Linux Version of the current kernel<br></code></pre></td></tr></table></figure><p>对于<code>(gdb) lx-symbols</code>时出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Python Exception &lt;class &#x27;gdb.MemoryError&#x27;&gt; Cannot access memory at address<br></code></pre></td></tr></table></figure><p>修改<code>scripts/gdb/linux/symbols.py</code>中<code>_section_arguments</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_section_arguments</span>(<span class="hljs-params">self, module</span>):<br>    <span class="hljs-keyword">try</span>:<br>        sect_attrs = module[<span class="hljs-string">&#x27;sect_attrs&#x27;</span>].dereference()<br>        attrs = sect_attrs[<span class="hljs-string">&#x27;attrs&#x27;</span>]<br>        section_name_to_address = &#123;<br>            attrs[n][<span class="hljs-string">&#x27;battr&#x27;</span>][<span class="hljs-string">&#x27;attr&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>].string(): attrs[n][<span class="hljs-string">&#x27;address&#x27;</span>]<br>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(sect_attrs[<span class="hljs-string">&#x27;nsections&#x27;</span>]))&#125;<br>    <span class="hljs-keyword">except</span> gdb.error:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    args = []<br>    <span class="hljs-keyword">for</span> section_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;.data&quot;</span>, <span class="hljs-string">&quot;.data..read_mostly&quot;</span>, <span class="hljs-string">&quot;.rodata&quot;</span>, <span class="hljs-string">&quot;.bss&quot;</span>,<br>                        <span class="hljs-string">&quot;.text&quot;</span>, <span class="hljs-string">&quot;.text.hot&quot;</span>, <span class="hljs-string">&quot;.text.unlikely&quot;</span>]:<br>        address = section_name_to_address.get(section_name)<br>        <span class="hljs-keyword">if</span> address:<br>            args.append(<span class="hljs-string">&quot; -s &#123;name&#125; &#123;addr&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                name=section_name, addr=<span class="hljs-built_in">str</span>(address)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(args)<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在用gdb来调试内核的时候，由于内核在初始化的时候，会创建很多子线程。而默认gdb会接管所有的线程，如果你从一个线程切换到另外一个线程，gdb会马上把原先的线程暂停。但是这样很容易导致kernel死掉，所以需要设置一下gdb。<br>一般用gdb进行多线程调试，需要注意两个参数：<code>follow-fork-mode</code>和<code>detach-on-fork</code></p><p><code>detach-on-fork</code>：</p><ul><li><code>on</code>：在 <code>fork</code> 之后，GDB 会断开对子进程的调试，仅继续调试父进程。</li><li><code>off</code>：GDB 将继续调试父进程和子进程。需要注意，这可能会导致调试会话变得非常复杂，因为 GDB 会同时控制多个进程。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set detach-on-fork on<br></code></pre></td></tr></table></figure><p><code>follow-fork-mode</code>：</p><ul><li><code>parent</code>：在 <code>fork</code> 之后，GDB 继续调试父进程，而子进程将处于暂停状态。</li><li><code>child</code>：在 <code>fork</code> 之后，GDB 继续调试子进程，而父进程将处于暂停状态。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set follow-fork-mode child<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ALSA</title>
    <link href="/snd/ALSA/"/>
    <url>/snd/ALSA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ftrace</title>
    <link href="/dbg_meth/ftrace/"/>
    <url>/dbg_meth/ftrace/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是ftrace"><a href="#什么是ftrace" class="headerlink" title="什么是ftrace"></a>什么是ftrace</h3><p>​ftrace是 Linux 内核中一个功能强大的跟踪框架，用于跟踪和分析内核及其模块的执行情况。它提供了一系列工具和功能，帮助开发者调试内核、分析性能瓶颈、查看系统调用、函数调用、上下文切换等信息。</p><p>​<code>ftrace</code> 的主要功能：</p><ol><li><strong>函数跟踪</strong> (<code>function tracing</code>):<ul><li>可以跟踪内核中每个函数的调用情况，包括函数进入、退出的时间和执行时间。</li><li>例如，可以跟踪某个特定函数的调用频率及其调用者。</li></ul></li><li><strong>函数调用图</strong> (<code>function graph tracing</code>):<ul><li>记录函数调用的完整调用栈。与简单的函数跟踪不同，函数调用图会显示函数的调用关系以及调用链中的每个函数的执行时间。</li></ul></li><li><strong>系统调用跟踪</strong>:<ul><li>可以跟踪所有的系统调用或特定的系统调用，从而了解用户空间程序如何与内核交互。</li></ul></li><li><strong>调度器跟踪</strong>:<ul><li><code>ftrace</code> 可以记录和分析调度器行为，比如任务切换、任务调度延迟等，帮助分析多任务系统中的调度性能。</li></ul></li><li><strong>事件跟踪</strong>:<ul><li><code>ftrace</code> 支持各种内核事件的跟踪（例如，IRQ 处理、中断、软中断等），并允许用户定义和过滤感兴趣的事件。</li></ul></li></ol><p>传统的ftrace操作较为繁琐，需要向多个文件写入信息，当前我们紧介绍ftrace前端工具：trace-cmd</p><h3 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h3><ul><li><p>trace-cmd record：记录实时跟踪数据并将其写入trace.dat 文件</p></li><li><p>trace-cmd report：读取 trace.dat 文件并将二进制数据转换为可读的 ASCII 文本格式。</p></li><li><p>trace-cmd start：开始跟踪但不记录到 trace.dat 文件。</p></li><li><p>trace-cmd stop：停止跟踪。</p></li><li><p>trace-cmd extract：从内核缓冲区提取数据并创建 trace.dat 文件。</p></li><li><p>trace-cmd reset：禁用所有跟踪并恢复系统性能。</p></li><li><p>查看可用追踪器</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd list -t<br>hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop<br></code></pre></td></tr></table></figure><ul><li>查看可跟踪的函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~/tom-blog] ➜  sudo trace-cmd list -f | grep mmap<br><br>xen_hvm_exit_mmap<br>xen_dup_mmap<br>xen_exit_mmap<br>ldt_arch_exit_mmap<br>__ia32_compat_sys_ia32_mmap<br>...<br></code></pre></td></tr></table></figure><ul><li>查看可跟踪的事件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~/tom-blog] ➜  sudo trace-cmd list -e | grep snd<br><br>asoc:snd_soc_bias_level_start<br>asoc:snd_soc_bias_level_done<br>asoc:snd_soc_dapm_start<br>asoc:snd_soc_dapm_done<br>...<br></code></pre></td></tr></table></figure><ul><li>查看函数调用栈</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd record -p function -l do_mmap --func-stack<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 ctrl-c 退出trace-cmd时，会在当前目录生成 trace.dat文件,使用report读取trace.dat</span><br>uos@uos-PC [~] ➜  trace-cmd report | head -20<br><br>CPU 0 is empty<br>cpus=16<br>    explorer.exe-14504 [008] 1274475.231218: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231223: kernel_stack:         &lt;stack trace&gt;<br>=&gt; ftrace_trampoline (ffffffffc0d6106a)<br>=&gt; do_mmap (ffffffff94891c45)<br>=&gt; vm_mmap_pgoff (ffffffff94869ee4)<br>=&gt; ksys_mmap_pgoff (ffffffff9488f472)<br>=&gt; do_syscall_64 (ffffffff951e9690)<br>=&gt; entry_SYSCALL_64_after_hwframe (ffffffff952000ea)<br>    explorer.exe-14504 [008] 1274475.231269: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231271: kernel_stack:         &lt;stack trace&gt;<br>=&gt; ftrace_trampoline (ffffffffc0d6106a)<br>=&gt; do_mmap (ffffffff94891c45)<br>=&gt; vm_mmap_pgoff (ffffffff94869ee4)<br>=&gt; ksys_mmap_pgoff (ffffffff9488f472)<br>=&gt; do_syscall_64 (ffffffff951e9690)<br>=&gt; entry_SYSCALL_64_after_hwframe (ffffffff952000ea)<br>    explorer.exe-14504 [008] 1274475.231285: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231286: kernel_stack:         &lt;stack trace&gt;<br><br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><p><code>-p</code>：指定当前的 tracer，类似 <code>echo function &gt; current_tracer</code>，可以是支持的 tracer 中的任意一个</p></li><li><p><code>-l</code>：指定跟踪的函数，可以设置多个，类似 <code>echo function_name &gt; set_ftrace_filter</code></p></li><li><p><code>--func-stack</code>：记录被跟踪函数的调用栈</p></li><li><p>-n 指定不跟踪的函数</p><ul><li>比如：<code>trace-cmd record -p function -l &#39;dev*&#39; -n dev_attr_show</code></li><li>设置跟踪所有 dev 开头的函数，但是不跟踪 <code>dev_attr_show</code></li></ul></li><li><p><code>-g</code>：指定 function_graph tracer 跟踪的 函数，类似 <code>echo function_name &gt; set_graph_function</code></p></li><li><p><code>-O</code>：设置 options，比如设置 <code>options/func_stack_trace</code> 可以用 <code>-O func_stack_trace</code>，在 optoin 名称前加上 <code>no</code> 就是将 option 清 0</p></li><li><p><code>-P</code>：设置跟踪的进程</p></li></ul><p>注意，function_graph tracer 同时支持 <code>-l/-g</code> 参数，但是两者是有区别的，他们区别的本质还是 <code>set_ftrace_filter</code> 与 <code>set_graph_function</code> 的区别。</p><ul><li><code>-l</code> 表示被跟踪的函数是叶子函数，不会跟踪其内部的调用子函数。</li><li><code>-g</code> 会跟踪函数内部调用的子函数。</li></ul><p>​默认情况下，<code>trace-cmd</code> 的 <code>function_graph</code> 会记录所有嵌套的函数调用。可以通过设置 <code>--max-graph-depth</code> 来限制跟踪深度。例如要将深度设置为 2，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd record -p function_graph --max-graph-depth 2 -P 1656<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存调试工具</title>
    <link href="/dbg_meth/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/dbg_meth/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="内存调试工具"><a href="#内存调试工具" class="headerlink" title="内存调试工具"></a>内存调试工具</h2><h3 id="busybox-devmem"><a href="#busybox-devmem" class="headerlink" title="busybox  devmem"></a>busybox  devmem</h3><p>在Linux系统，如果我们想要访问某个寄存器，就需要写一个驱动程序，在驱动中映射寄存器地址，转为虚拟地址后就可以访问。<br>但有时候，我们只是单纯想知道某个寄存器的值，不想这么麻烦，怎么办呢？<br>Linux早就想到这一点了，于是提供了一个工具devmem，通过devmem就可以直接读写寄存器，<br>devmem是一个命令，在shell中输入devmem命令就可以非常方便的读写寄存器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">BusyBox v1.30.1 (Uos 1:1.30.1.5-1+dde) multi-call binary.<br><br>Usage: devmem ADDRESS [WIDTH [VALUE]]<br><br>Read/write from physical address<br><br>        ADDRESS Address to act upon#物理地址<br>        WIDTH   Width (8/16/...)#位宽<br>        VALUE   Data to be written#写入<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo busybox devmem 0x28007000 8     #读取物理地址0x28007000处一个字节的数据<br>0x63<br><br>sudo busybox devmem 0x280070ac 8<br>0x01<br><br>sudo busybox devmem 0x28007000 8 0x63#将0x63写入物理地址0x28007000<br><br>sudo busybox devmem 0x280070ac 8 0x01#将0x01写入物理地址0x280070ac<br></code></pre></td></tr></table></figure><h3 id="i2c-tools"><a href="#i2c-tools" class="headerlink" title="i2c-tools"></a>i2c-tools</h3><p>应用层访问硬件肯定是需要驱动程序的。对于I2C设备，Linux内核已经提供驱动程序**<code>drivers/i2c/i2c-dev.c</code>**，通过它可以直接使用下面的I2C控制器驱动程序来访问I2C设备，而i2c-tools正是基于该驱动开发的一套示例代码，也是一套好用的调试工具。框架如下：</p><img src="/dbg_meth/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/i2c-tools.png" class="" title="i2c-tools"><p>i2c-tools 包括 ： <strong>i2cdetect</strong>（检测I2C器件工具） 、<strong>i2cdump</strong>（查看寄存器值工具） 、<strong>i2cget</strong>（读取寄存器值工具）、 <strong>i2cset</strong>（设置寄存器值工具）</p><h4 id="i2cdetect"><a href="#i2cdetect" class="headerlink" title="i2cdetect"></a>i2cdetect</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]<br>       i2cdetect -F I2CBUS<br>       i2cdetect -l<br>  I2CBUS is an integer or an I2C bus name<br>  If provided, FIRST and LAST limit the probing range.<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-f强制访问设备</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-y禁用交互模式</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-a扫描总显示所有设备</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-l列出已知的I2C适配器</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">I2CBUSi2c总线编号</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">FIRST LAST扫描地址范围</span><br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">返回值</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">– ：表示该地址被检测，但没有芯片应答；</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">UU ：表示该地址当前由内核驱动程序使用。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">** ：表示以十六进制表示的设备地址编号，如 “2d”或“4e”。</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cdetect -y  0<br><br>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f<br>00:          -- -- -- -- -- 08 -- -- -- -- -- -- -- <br>10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>30: 30 -- -- -- -- 35 UU UU -- -- -- -- -- -- -- -- <br>40: -- -- -- -- 44 -- -- -- -- -- -- -- -- -- -- -- <br>50: UU -- -- -- -- -- -- 57 -- -- -- -- -- -- -- -- <br>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>70: -- -- -- -- -- -- -- -- <br><br>uos@uos-PC [~] ➜  sudo i2cdetect -l<br><br>i2c-3   i2c             i915 gmbus dpc                          I2C adapter<br>i2c-1   i2c             Synopsys DesignWare I2C adapter         I2C adapter<br>i2c-6   i2c             AUX C/port C                            I2C adapter<br>i2c-4   i2c             i915 gmbus dpb                          I2C adapter<br>i2c-2   i2c             Synopsys DesignWare I2C adapter         I2C adapter<br>i2c-0   smbus           SMBus I801 adapter at efa0              SMBus adapter<br>i2c-7   i2c             AUX D/port D                            I2C adapter<br>i2c-5   i2c             i915 gmbus dpd                          I2C adapter<br><br><br>uos@uos-PC [~] ➜  sudo i2cdetect -F 0<br><br>Functionalities implemented by /dev/i2c-0:<br>I2C                              no<br>SMBus Quick Command              yes<br>SMBus Send Byte                  yes<br>SMBus Receive Byte               yes<br>SMBus Write Byte                 yes<br>SMBus Read Byte                  yes<br>SMBus Write Word                 yes<br>SMBus Read Word                  yes<br>SMBus Process Call               no<br>SMBus Block Write                yes<br>SMBus Block Read                 yes<br>SMBus Block Process Call         yes<br>SMBus PEC                        yes<br>I2C Block Write                  yes<br>I2C Block Read                   yes<br></code></pre></td></tr></table></figure><h4 id="i2cget"><a href="#i2cget" class="headerlink" title="i2cget"></a>i2cget</h4><p>读取指定IIC设备的某个寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cget [-f] [-y] [-a] I2CBUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    b (read byte data, default)<br>    w (read word data)<br>    c (write byte/read byte)<br>    Append p for SMBus PEC<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cget -y 0 0x57 0x00       #读地址0x57设备的0x00处寄存器的值<br>0xff<br></code></pre></td></tr></table></figure><h4 id="i2cset"><a href="#i2cset" class="headerlink" title="i2cset"></a>i2cset</h4><p>写入指定IIC设备的某个寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cset [-f] [-y] [-m MASK] [-r] [-a] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    c (byte, no value)<br>    b (byte data, default)<br>    w (word data)<br>    i (I2C block data)<br>    s (SMBus block data)<br>    Append p for SMBus PEC<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cset -y 0 0x57 0x00 0x01      #设置地址0x57设备的0x00处寄存器的值为0x01<br></code></pre></td></tr></table></figure><h4 id="i2cdump"><a href="#i2cdump" class="headerlink" title="i2cdump"></a>i2cdump</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cdump [-f] [-y] [-r first-last] [-a] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    b (byte, default)<br>    w (word)<br>    W (word on even register addresses)<br>    s (SMBus block)<br>    i (I2C block)<br>    c (consecutive byte)<br>    Append p for SMBus PEC<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cdump -y 0 0x57   #读取总线0  0x57处设备的所有寄存器<br><br>No size specified (using byte-data access)<br>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef<br>00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>10: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>20: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>30: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>40: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>50: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>60: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>70: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>90: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>a0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>b0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>c0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>d0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>e0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>f0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ioctl</title>
    <link href="/kernel/ioctl/ioctl/"/>
    <url>/kernel/ioctl/ioctl/</url>
    
    <content type="html"><![CDATA[<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>在驱动程序的ioctl函数体中，实现了一个switch-case结构，每一个case对应一个命令码，case内部是驱动程序实现该命令的相关操作。</p><p>ioctl的实现函数要传递给file_operations结构体中对应的函数指针，函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ioctl.h&gt;</span></span><br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file * fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file * fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br></code></pre></td></tr></table></figure><p>unlocked_ioctl在无大内核锁（BKL）的情况下调用。64位用户程序运行在64位的kernel，或32位的用户程序运行在32位的kernel上，都是调用unlocked_ioctl函数。</p><p>compat_ioctl是64位系统提供32位ioctl的兼容方法，也在无大内核锁的情况下调用。即如果是32位的用户程序调用64位的kernel，则会调用compat_ioctl。如果驱动程序没有实现compat_ioctl，则用户程序在执行ioctl时会返回错误Not a typewriter。</p><p>另外，如果32位用户态和64位内核态发生交互时，第三个参数的长度需要保持一致，否则交互协议会出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br></code></pre></td></tr></table></figure><p>在2.6.35.7及以前的内核版本中，file_operations还定义了ioctl()接口，与unlocked_ioctl是等价的。但是在2.6.36以后就不再支持这个接口，全部使用unlocked_ioctl了</p><p>以上函数参数的含义如下。<br>1）inode和fp用来确定被操作的设备。<br>2）request就是用户程序下发的命令。<br>3）args就是用户程序在必要时传递的参数。</p><p>返回值：可以在函数体中随意定义返回值，这个返回值也会被直接返回到用户程序中。通常使用非负数表示正确的返回，而返回一个负数系统会判定为ioctl调用失败。</p><p>三、用户与驱动之间的ioctl协议构成<br>也就是request或cmd，本质上就是一个32位数字，理论上可以是任何一个数，但为了保证命令码的唯一性，linux定义了一套严格的规定，通过计算得到这个命令吗数字。linux将32位划分为四段</p><img src="/kernel/ioctl/ioctl/ioctl.png" class="" title="ioctl"><ul><li>dir，即direction，表示ioctl命令的访问模式，分为无数据(_IO)、读数据(_IOR)、写数据(_IOW)、读写数据(_IOWR)四种模式。</li><li>type，即device type，表示设备类型，也可翻译成“幻数”或“魔数”，可以是任意一个char型字符，如’a’、‘b’、‘c’等，其主要作用是使ioctl命令具有唯一的设备标识。不过在内核中’w’、‘y’、’z’三个字符已经被使用了。</li><li>nr，即number，命令编号&#x2F;序数，取值范围0~255，在定义了多个ioctl命令的时候，通常从0开始顺次往下编号。</li><li>size，涉及到ioctl的参数arg，占据13bit或14bit，这个与体系有关，arm使用14bit。用来传递arg的数据类型的长度，比如如果arg是int型，我们就将这个参数填入int，系统会检查数据类型和长度的正确性。</li></ul><p>在上面的四个参数都需要用户自己定义，linux系统提供了宏可以使程序员方便的定义ioctl命令码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">include/uapi/<span class="hljs-keyword">asm</span>-generic/ioctl.h<br><span class="hljs-comment">/* used to create numbers */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><br>分别对应了四个dir：<br>_IO(type, nr)：用来定义不带参数的ioctl命令。<br>_IOR(type,nr,size)：用来定义用户程序向驱动程序写参数的ioctl命令。<br>_IOW(type,nr,size)：用来定义用户程序从驱动程序读参数的ioctl命令。<br>_IOWR(type,nr,size)：用来定义带读写参数的驱动命令。<br></code></pre></td></tr></table></figure><p>当然了，系统也定义反向解析ioctl命令的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include/uapi/<span class="hljs-keyword">asm</span>-generic/ioctl.h<br><span class="hljs-comment">/* used to decode ioctl numbers */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_DIR(nr)        (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_TYPE(nr)       (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_NR(nr)     (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_SIZE(nr)       (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>S3 问题根因分析技术文档</title>
    <link href="/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="S3-问题根因分析技术文档"><a href="#S3-问题根因分析技术文档" class="headerlink" title="S3 问题根因分析技术文档"></a>S3 问题根因分析技术文档</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><ul><li>x8610705.10</li><li>联想昭阳k4e-iml 待机自动唤醒</li></ul><p>首先我们看一下日志</p><img src="/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/k4e-iml.png" class="" title="log"><p>我们可以看到在准备Disabling non-boot CPUs 的时候检测到wakeup事件了（wake up pending），abort CPU freeze</p><p>一般这个wakeup事件产生可能是某些设备下电的时候出现异常，或者此时外部设备来了一个中断，打断S3的操作导致S3停止</p><h3 id="S3-待机流程"><a href="#S3-待机流程" class="headerlink" title="S3 待机流程"></a>S3 待机流程</h3><p>我们先来了解一下S3的流程是怎么样的</p><img src="/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/S3%E5%BE%85%E6%9C%BA.png" class="" title="S3待机流程"><p>如上图所示，这是S3待机过程的流程图，简单介绍一下：</p><ul><li>state_store：处理系统进入不同的电源状态</li><li>pm_suspend：suspend入口</li><li>suspend_prepare：suspend前的一些准备工作</li><li>suspend_freeze_processes：冻结用户进程以及内核线程</li><li>suspend_devices_and_enter：开始进行挂起设备</li><li>suspend_enter：关闭设备中断，关闭辅助cpu，检查irq事件，CPU进入suspend</li></ul><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><p>问题是它唤醒了，在知道了S3的流程以后，他在哪里检测唤醒事件呢？pm_wakeup_pending，没错就是这里，我们查看此部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">pm_wakeup_pending</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><br>raw_spin_lock_irqsave(&amp;events_lock, flags);<br><span class="hljs-keyword">if</span> (events_check_enabled) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cnt, inpr;<br><br>split_counters(&amp;cnt, &amp;inpr);<br>ret = (cnt != saved_count || inpr &gt; <span class="hljs-number">0</span>);<br>events_check_enabled = !ret;<br>&#125;<br>raw_spin_unlock_irqrestore(&amp;events_lock, flags);<br><br><span class="hljs-keyword">if</span> (ret) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Wakeup pending, aborting suspend\n&quot;</span>);<br>pm_print_active_wakeup_sources();<br>&#125;<br><br><span class="hljs-keyword">return</span> ret || <span class="hljs-type">atomic_read</span>(&amp;pm_abort_suspend) &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现他在检测到中断事件的时候就会return  false，暂停S3的操作</p><p>具体检测irq函数为pm_system_irq_wakeup</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">pm_system_irq_wakeup</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq_number)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>raw_spin_lock_irqsave(&amp;wakeup_irq_lock, flags);<br><br><span class="hljs-keyword">if</span> (wakeup_irq[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>wakeup_irq[<span class="hljs-number">0</span>] = irq_number;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wakeup_irq[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>wakeup_irq[<span class="hljs-number">1</span>] = irq_number;<br><span class="hljs-keyword">else</span><br>irq_number = <span class="hljs-number">0</span>;<br><br>raw_spin_unlock_irqrestore(&amp;wakeup_irq_lock, flags);<br><br><span class="hljs-keyword">if</span> (irq_number)<br>pm_system_wakeup();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数里面我们可以添加printk打印出中断号，或者可以使用bpftrace工具进行打印，kprobe:pm_system_irq_wakeup</p><img src="/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/k4e-iml1.png" class="" title="int"><p>此时发现中断号为122，接下来通过cat &#x2F;proc&#x2F;interrupts 查看这个中断相应的中断处理程序</p><img src="/kernel/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/122-irq.png" class="" title="irq"><p>此中断所挂载的相关中断处理程序是aerdrv和pcie-dpc，这2个中断处理程序主要负责处理pcie上面的错误信号的</p><p>通过lspci -tv查看到这个pcie总线上挂载了一张amd的显卡，此时基本可以判断问题出在显卡驱动上面</p><h3 id="AER和DPC"><a href="#AER和DPC" class="headerlink" title="AER和DPC"></a>AER和DPC</h3><ul><li>AER：是一种用于检测和报告PCIe设备中发生的错误的机制。它允许PCIe设备检测到并报告各种类型的错误，如非致命的、可恢复的以及严重的错误。AER在PCIe设备上实现了一组寄存器和相应的错误通知机制，可以通过读取这些寄存器来获取关于错误的信息。使用AER，系统能够更好地监控和处理PCIe设备的错误情况，以提高数据完整性和可靠性。</li><li>DPC：是一种用于处理PCIe链路中错误情况的机制。当PCIe链路上的一个设备发送错误信号时，DPC机制允许系统针对该错误进行处理，以避免错误的传播和影响其他设备。具体而言，DPC机制会隔离出故障设备，从而限制错误的影响范围，确保其他设备继续正常工作。</li></ul><div class="note note-warning">            <p>DPC机制依赖于AER提供的错误信息来进行错误处理</p>          </div><p>由于后期任务较多，该问题当时并未深究amdgpu驱动为何报错，不过知道了中断处理程序上报的错误，最后采用pcie_ports&#x3D;compat进行规避。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">pcie_ports</span>=[<span class="hljs-type">PCIE</span>] <span class="hljs-type">PCIe</span> <span class="hljs-keyword">port</span> services handling:<br>nativeUse native PCIe services (<span class="hljs-type">PME</span>, <span class="hljs-type">AER</span>, <span class="hljs-type">DPC</span>, <span class="hljs-type">PCIe</span> hotplug)<br>even if the platform doesn&#x27;t give the OS permission to<br>use them.  This may cause conflicts if the platform<br>also tries to use these services.<br>dpc-nativeUse native PCIe service for DPC only.  May<br>cause conflicts if firmware uses AER or DPC.<br>compatDisable native PCIe services (<span class="hljs-type">PME</span>, <span class="hljs-type">AER</span>, <span class="hljs-type">DPC</span>, <span class="hljs-type">PCIe</span><br>hotplug).<br></code></pre></td></tr></table></figure><p>compat参数用于禁用原生的 PCIe 服务，包括 PME、AER、DPC 和 PCIe 热插拔功能，忽略该错误进行规避。</p>]]></content>
    
    
    <categories>
      
      <category>PM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/kernel/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/kernel/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h3><p>​逻辑地址：用来指定一个操作数或一条指令的地址，段（segment）+偏移量（offset | displacement），偏移量指明了从段开始的地方到实际地址之间的距离</p><p>​线性地址：也称作虚拟地址，32位无符号整数，通常用十六位进制数表示，值的范围从0x00000000~0xffffffff</p><p>​物理地址：内存芯片级内存单元寻址</p><p>​在内存寻址中，我们通常以字节为单位</p><h3 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h3><p>​逻辑地址：段标识符+段内相对地址偏移量</p><p>​<strong>段标识符</strong>是一个16位长的字段，成为<strong>段选择符</strong></p><p>​段寄存器：快速查找段选择符，cs，ss，ds，es，fs，gs，程序可以把同一个段寄存器用于不同的目的，先将其值保存在内存中，用完后再恢复</p><p>​cs：代码段寄存器，指向包含程序指令的段，它含有一个两位的字段，指明CPU当前的特权级（CPL），0内核态，3用户态</p><p>​ss：栈段寄存器，指向包含当前程序栈的段</p><p>​ds：数据段寄存器，指向包含静态数据或全局数据段</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>​每个段由一个8字节的段描述符表示，它描述段的特征。放在全局描述符表（GDT）或局部描述符表（LDT）中。</p><p>​通常只定义一个GDT，而每个进程除了存放在GDT的段以外如果还需创建附加段就可以有自己的LDT。GDT在主存中的地址和大小放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中</p><p>​段描述符字段</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>Base</td><td>段首地址的线性地址</td></tr><tr><td>G</td><td>粒度标志：如果该位清0，则段大小以字节为单位，否则以4096字节的倍数计</td></tr><tr><td>Limit</td><td>存放段中最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化</td></tr><tr><td>S</td><td>系统标志：如果它被清0，则这是一个系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段</td></tr><tr><td>Type</td><td>描述了段的类型特征和它的存取权限（请看表下面的描述）</td></tr><tr><td>DPL</td><td>描述符特权级（Descriptor Privilege Level）字段：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。因此，DPL设为0的段只能当CPL为0时（即在内核态）才是可访问的，而DPL设为3的段对任何CPL值都是可访问的</td></tr><tr><td>P</td><td>Segment-Present标志：等于0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去</td></tr><tr><td>D或B</td><td>称为D或B的标志，取决于是代码段还是数据段。D或B的含义在两种情况下稍微有所区别，但是如果段偏移量的地址是32位长，就基本上把它置为1，如果这个偏移量是16位长，它被清0（更详细的描述参见Intel使用手册）</td></tr><tr><td>AVL标志</td><td>可以由操作系统使用，但是被Linux忽略</td></tr></tbody></table><h3 id="段选择符字段"><a href="#段选择符字段" class="headerlink" title="段选择符字段"></a>段选择符字段</h3><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>指定了放在GDT或LDT中的相应段描述符的入口</td></tr><tr><td>TI</td><td>（Table Indicator）标志，指明段描述符是在GDT中（TI&#x3D;0）或在LDT中（TI&#x3D;1）</td></tr><tr><td>RPL</td><td>请求者特权级：当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td></tr></tbody></table><h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>​逻辑地址—-&gt;线性地址</p><p>​从段选择符的index字段计算段描述符的地址，index字段乘以8（一个段描述符大小），结果与gdtr或ldtr相加</p><p>​逻辑地址偏移量+段描述符地址—&gt;线性地址</p><h3 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h3><p>​分段可以给每一个进程分配不同的线性地址空间</p><p>​分页可以把同一线性地址空间映射到不同的物理空间（Linux多用这个）</p><h3 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h3><p>​分页单元把线性地址转换为物理地址</p><p>​其中一个关键任务，把请求访问的类型和线性地址的访问权限相比较，如果这次内存访问无效，就产生一个缺页异常</p><p>​线性地址被分为以固定长度位单位的组，称为<strong>页</strong>。页内部连续的线性地址被映射到连续的物理地址中</p><p>​分页单元把所有RAM分成固定长度的<strong>页框（page frame）</strong>（有时叫做物理页）。每一个页框包含一个页（page），也就是说一个页框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。页只是一个数据块，可以存放在任何页框或磁盘中。</p><p>​把线性地址映射到物理地址的数据结构称为<strong>页表（page table）</strong>。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化</p><p>​正在使用的页目录的物理地址存放在控制寄存器cr3中。线性地址内的Directory字段决定页目录中的目录项，而目录项指向适当的页表。地址的Table字段依次又决定页表中的表项，而表项含有页所在页框的物理地址。Offset字段决定页框内的相对位置。由于它是12位长，故每一页含有4096字节的数据</p><img src="/kernel/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page.png" class="" title="page"><h3 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h3><p>​四级分页模型</p><ul><li>页全局目录</li><li>页上级目录</li><li>页中级目录</li><li>页表</li></ul><img src="/kernel/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/linux_page.png" class="" title="linux_page"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​进程是程序执行时的一个实例，从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体</p><p>​当一个进程创建时，它几乎与父进程相同。它接受父进程地址空间的一个（逻辑）拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。尽管父子进程可以共享含有程序代码（正文）的页，但是它们各自有独立的数据拷贝（栈和堆），因此子进程对一个内存单元的修改对父进程是不可见的（反之亦然）</p><p>​Linux使用轻量级进程（lightweight process）对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。只要其中一个修改共享资源，另一个就立即查看这种修改。当然，当两个线程访问共享资源时就必须同步它们自己。</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><img src="/kernel/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/process1.png" class="" title="process1"><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>state字段描述了进程当前所处的状态</p><p>可运行状态（TASK_RUNNING)<br>        进程要么在CPU上执行，要么准备执行。</p><p>可中断的等待状态（TASK_INTERRUPTIBLE)<br>        进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING).</p><p>不可中断的等待状态（TASK_UNINTERRUPTIBLE)<br>        与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</p><p>暂停状态（TASK_STOPPED)<br>        进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。</p><p>跟踪状态（TASK_TRACED)<br>        进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时（例如debugger执行ptrace（）系统调用监控一个测试程序），任何信号都可以把这个进程置于TASK_TRACED状态。</p><p>还有两个进程状态是既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段的名称可以看出，只有当进程的执行被终止时，进程的状态才会变为这两种状态中的一种：</p><p>僵死状态（EXIT_ZOMBIE）<br>        进程的执行被终止，但是，父进程还没有发布wait4（）或waitpid（）系统调用来返回有关死亡进程的信息。发布wait（）类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它</p><p>僵死撤消状态（EXIT_DEAD)<br>        最终状态：由于父进程刚发出 wait4（）或waitpid（）系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait（）类系统调用（这是一种竞争条件），而把进程的状态由優死（EXIT_ZOMBIE）状态改为死撤消状态(EXIT-DEAD）参见第五）。</p><h3 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h3><p>​进程恢复执行前必须装入寄存器的一组数据称为硬件上下文。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核态堆栈中。</p><h3 id="任务状态段（TSS）"><a href="#任务状态段（TSS）" class="headerlink" title="任务状态段（TSS）"></a>任务状态段（TSS）</h3><p>​存放硬件上下文</p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断（interrupt）通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。<br>中断通常分为同步（synchronous）中断和异步（asynchronous）中断：</p><ul><li>同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li><li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li></ul><p>在Intel微处理器手册中，把同步和异步中断分别称为<strong>异常</strong>（exception）和<strong>中断</strong>（interrupt）。我们也采用这种分类，当然有时我们也用术语“中断信号”指这两种类型（同步及异步）。</p><p>中断是由间隔定时器和I&#x2F;O设备产生的，例如，用户的一次按键会引起一个中断。另一方面，异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个每个Unix程序员都熟悉的信号来处理异常。第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页，或对内核服务的一个请求（通过一条int或sysenter指令）。</p><h3 id="中断和异常-1"><a href="#中断和异常-1" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul><li><p>中断：</p><ul><li><p>可屏蔽中断</p><p>I&#x2F;O设备发出的所有中断请求（IRQ)都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的（masked）或非屏蔽的（unmasked）：一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</p></li><li><p>非屏蔽中断</p><p>只有几个危急事件（如硬件故障）才引起非屏蔽中断，非屏蔽中断总是由CPU辨认</p></li></ul></li><li><p>异常</p><ul><li><p>处理器探测异常</p><p>当CPU执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于CPU控制单元产生异常时保存在内核态堆栈eip寄存器（在 x86 指令集中，EIP 寄存器存储着 CPU 将要执行的下一条指令的内存地址）中的值。</p><ul><li><p>故障</p><p>通常可以纠正；一且纠正，程序就可以在不失连贯性的情况下重新开始。保存在eip中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行。我们将在“缺页异常处理程序”一节中看到，只要处理程序能纠正引起异常的反常条件，重新执行同一指令就是必要的。</p></li><li><p>陷阱</p><p>在陷指令执行后立即报告：内核把控制权返回给程序后就可以继续它的执行而不失连贯性。保存在eip中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱。陷阱的主要用途是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一旦用户检查到调试程序所提供的数据，她就可能要求被调试程序从下一条指令重新开始执行。</p></li><li><p>异常终止</p><p>发生一个严重的错误：控制单元出了问题，不能在eip寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</p></li><li><p>编程异常</p><p>在编程者发出请求时发生。是由int或int3指令触发的：当into（检查溢出）和bound（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷来处理。编程异常通常也叫做软中断（software interrupt）。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</p></li></ul></li></ul></li></ul><p>每个中断和异常是由0~255之间的一个数来标识。因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量（vector）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><h3 id="IRQ和中断"><a href="#IRQ和中断" class="headerlink" title="IRQ和中断"></a>IRQ和中断</h3><p>​每个能够发出中断请求的硬件设备控制器都有一条名为IRQ（Interrupt ReQuest）的输出线（复杂一些的设备有几条IRQ线，例知，PCI卡可能使用多达4条IRQ线）。所有现有的IRQ线（IRQ line）都与一个名为可编程中断控制器（Programmable Interrupt Controller，PIC)的硬件电路的输入引脚相连，可编程中断控制器执行下列动作：</p><pre><code class="hljs"> 1. 监视IRQ线，检查产生的信号（raised signal）。如果有条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线 2. 如果一个引发信号出现在IRQ线上：  - 把接收到的引发信号转换成对应的向量  - 把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读取此向量  - 把引发信号发送到处理器的INTR引脚，即产生一个中断  - 等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认他；当这种情况发生时，清INTR线 3. 返回到第一步</code></pre><p>​IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示成IRQ0。与IRQn关联的Intel的缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>​可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断是丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ</p><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>​中断描述符表（Interrupt Descriptor Table.IDT）是一个系统表，它与每一个中断或异常向量（异常向量是一组预定义的内存地址，用于存储处理器在发生异常时应该跳转到的位置）相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。内核在允许中断发生前，必须适当地初始化IDT.</p><p>​IDT包含三种类型的描述符：</p><p>​任务门：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p><p>​中断门：包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</p><p>​陷阱门：与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志。</p><p>​Linux利用中断门处理中断，利用陷阱门处理异常</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Suspend (kernel 5.10)</title>
    <link href="/kernel/pm/Suspend/"/>
    <url>/kernel/pm/Suspend/</url>
    
    <content type="html"><![CDATA[<h2 id="Suspend-kernel-5-10"><a href="#Suspend-kernel-5-10" class="headerlink" title="Suspend (kernel 5.10)"></a>Suspend (kernel 5.10)</h2><ul><li><p><a href="#state_sotre">state_store</a></p><ul><li><p><a href="#pm_suspend">pm_suspend</a></p><ul><li><p><a href="#enter_state">enter_state</a></p><ul><li><p><a href="#valid_state">valid_state</a></p></li><li><p><a href="#suspend_prepare">suspend_prepare</a></p></li><li><p><a href="#sleep_state_supported">sleep_state_supported</a></p><ul><li><p><a href="#pm_notifier_call_chain_robust">pm_notifier_call_chain_robust</a></p></li><li><p><a href="#suspend_freeze_processes">suspend_freeze_processes</a></p><ul><li><a href="#freeze_processes">freeze_processes</a></li></ul></li><li><p><a href="#freeze_kernel_threads">freeze_kernel_threads</a></p></li><li><p><a href="#suspend_devices_and_enter">suspend_devices_and_enter</a></p><ul><li><a href="#dpm_suspend_start">dpm_suspend_start</a><ul><li><a href="#dpm_prepare">dpm_prepare</a></li><li><a href="#dpm_suspend">dpm_suspend</a><ul><li><a href="#device_suspend">device_suspend</a></li></ul></li></ul></li><li><a href="#suspend_enter">suspend_enter</a><ul><li><a href="#dpm_suspend_noirq">dpm_supsend_noirq</a><ul><li><a href="#device_wakeup_arm_wake_irqs">device_wakeup_arm_wake_irqs</a></li><li><a href="#suspend_device_irqs">suspend_device_irqs</a><ul><li><a href="#suspend_device_irq">suspend_device_irq</a></li></ul></li><li><a href="#dpm_noirq_suspend_devices">dpm_noirq_suspend_devices</a><ul><li><a href="#device_suspend_noirq">device_suspend_noirq</a></li></ul></li></ul></li><li><a href="#suspend_disable_secondary_cpus">suspend_disable_secondary_cpus</a><ul><li><a href="#freeze_secondary_cpus">freeze_secondary_cpus</a></li></ul></li><li><a href="#arch_suspend_disable_irqs">arch_suspend_disable_irqs</a><ul><li><a href="#local_irq_disable">local_irq_disable</a></li></ul></li><li><a href="#syscore_suspend">syscore_suspend</a></li><li><a href="#suspend_ops-%3Eenter">suspend_ops-&gt;enter</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="state-store"><a href="#state-store" class="headerlink" title="state_store"></a>state_store</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">state_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-keyword">struct</span> kobj_attribute *attr,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br><span class="hljs-type">suspend_state_t</span> state;<br><span class="hljs-type">int</span> error;<br><br>error = pm_autosleep_lock();<span class="hljs-comment">//获取autosleep锁</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br><span class="hljs-keyword">if</span> (pm_autosleep_state() &gt; PM_SUSPEND_ON) &#123;<span class="hljs-comment">//判断当前autosleep状态</span><br>error = -EBUSY;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>    <span class="hljs-comment">/*关于suspend状态如下：</span><br><span class="hljs-comment">    #define PM_SUSPEND_ON((__force suspend_state_t) 0)</span><br><span class="hljs-comment">#define PM_SUSPEND_TO_IDLE((__force suspend_state_t) 1)</span><br><span class="hljs-comment">#define PM_SUSPEND_STANDBY((__force suspend_state_t) 2)</span><br><span class="hljs-comment">#define PM_SUSPEND_MEM((__force suspend_state_t) 3)</span><br><span class="hljs-comment">#define PM_SUSPEND_MINPM_SUSPEND_TO_IDLE</span><br><span class="hljs-comment">#define PM_SUSPEND_MAX((__force suspend_state_t) 4)*/</span><br><br>state = decode_state(buf, n);<span class="hljs-comment">//解析传入的state状态值</span><br><span class="hljs-keyword">if</span> (state &lt; PM_SUSPEND_MAX) &#123;<br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_MEM)<br>state = mem_sleep_current;<br><br>error = pm_suspend(state);<span class="hljs-comment">//S3</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == PM_SUSPEND_MAX) &#123;<br>error = hibernate();<span class="hljs-comment">//S4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>error = -EINVAL;<br>&#125;<br><br> out:<br>pm_autosleep_unlock();<br><span class="hljs-keyword">return</span> error ? error : n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pm-suspend"><a href="#pm-suspend" class="headerlink" title="pm_suspend"></a>pm_suspend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pm_suspend - Externally visible function for suspending the system.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Check if the value of @state represents one of the supported states,</span><br><span class="hljs-comment"> * execute enter_state() and update system suspend statistics.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pm_suspend</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (state &lt;= PM_SUSPEND_ON || state &gt;= PM_SUSPEND_MAX)<span class="hljs-comment">//再次判断state</span><br><span class="hljs-keyword">return</span> -EINVAL;<br><br>pr_info(<span class="hljs-string">&quot;suspend entry (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>error = enter_state(state);<br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.fail++;<br>dpm_save_failed_errno(error);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>suspend_stats.success++;<br>&#125;<br>pr_info(<span class="hljs-string">&quot;suspend exit\n&quot;</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="enter-state"><a href="#enter-state" class="headerlink" title="enter_state"></a>enter_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * enter_state - Do common work needed to enter system sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Make sure that no one else is trying to put the system into a sleep state.</span><br><span class="hljs-comment"> * Fail if that&#x27;s not the case.  Otherwise, prepare for system suspend, make the</span><br><span class="hljs-comment"> * system enter the given sleep state and clean up after wakeup.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enter_state</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;suspend_enter&quot;</span>), state, <span class="hljs-literal">true</span>);<span class="hljs-comment">//记录挂起过程的跟踪信息</span><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM_DEBUG</span><br><span class="hljs-keyword">if</span> (pm_test_level != TEST_NONE &amp;&amp; pm_test_level &lt;= TEST_CPUS) &#123;<br>pr_warn(<span class="hljs-string">&quot;Unsupported test mode for suspend to idle, please choose none/freezer/devices/platform.\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!valid_state(state)) &#123;<span class="hljs-comment">//判断平台是否支持该睡眠状态</span><br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><span class="hljs-keyword">if</span> (!mutex_trylock(&amp;system_transition_mutex))<br><span class="hljs-keyword">return</span> -EBUSY;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE)<br>s2idle_begin();<br><br><span class="hljs-keyword">if</span> (sync_on_suspend_enabled) &#123;<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;sync_filesystems&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>ksys_sync_helper();<span class="hljs-comment">//同步文件系统</span><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;sync_filesystems&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br>pm_pr_dbg(<span class="hljs-string">&quot;Preparing system for sleep (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>pm_suspend_clear_flags();<br>error = suspend_prepare(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Unlock;<br><br><span class="hljs-keyword">if</span> (suspend_test(TEST_FREEZER))<br><span class="hljs-keyword">goto</span> Finish;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;suspend_enter&quot;</span>), state, <span class="hljs-literal">false</span>);<br>pm_pr_dbg(<span class="hljs-string">&quot;Suspending system (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>pm_restrict_gfp_mask();<br>error = suspend_devices_and_enter(state);<span class="hljs-comment">//挂起设备</span><br>pm_restore_gfp_mask();<br><br> Finish:<br>events_check_enabled = <span class="hljs-literal">false</span>;<br>pm_pr_dbg(<span class="hljs-string">&quot;Finishing wakeup.\n&quot;</span>);<br>suspend_finish();<br> Unlock:<br>mutex_unlock(&amp;system_transition_mutex);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="valid-state"><a href="#valid-state" class="headerlink" title="valid_state"></a>valid_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">valid_state</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><span class="hljs-comment">//判断该平台是否支持该状态睡眠</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * PM_SUSPEND_STANDBY and PM_SUSPEND_MEM states need low level</span><br><span class="hljs-comment"> * support and need to be valid to the low level</span><br><span class="hljs-comment"> * implementation, no valid callback implies that none are valid.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> suspend_ops &amp;&amp; suspend_ops-&gt;valid &amp;&amp; suspend_ops-&gt;valid(state);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-prepare"><a href="#suspend-prepare" class="headerlink" title="suspend_prepare"></a>suspend_prepare</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_prepare - Prepare for entering system sleep state.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Common code run for every system sleep state that can be entered (except for</span><br><span class="hljs-comment"> * hibernation).  Run suspend notifiers, allocate the &quot;suspend&quot; console and</span><br><span class="hljs-comment"> * freeze processes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_prepare</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (!sleep_state_supported(state))<span class="hljs-comment">//检查指定的睡眠状态是否受支持</span><br><span class="hljs-keyword">return</span> -EPERM;<br><br>pm_prepare_console();<span class="hljs-comment">//切换控制台，将内核消息重定向到指定的控制台。这样做可以确保在睡眠过程中，内核消息能够正确地输出到指定的控制台,重定向kmsg</span><br><br>error = pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND);<span class="hljs-comment">//运行挂起通知器链。这些通知器允许设备驱动程序和其他子系统在系统挂起之前和之后执行必要的操作</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Restore;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;freeze_processes&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>error = suspend_freeze_processes();<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;freeze_processes&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!error)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>suspend_stats.failed_freeze++;<br>dpm_save_failed_step(SUSPEND_FREEZE);<br>pm_notifier_call_chain(PM_POST_SUSPEND);<br> Restore:<br>pm_restore_console();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sleep-state-supported"><a href="#sleep-state-supported" class="headerlink" title="sleep_state_supported"></a>sleep_state_supported</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">sleep_state_supported</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-keyword">return</span> state == PM_SUSPEND_TO_IDLE || (suspend_ops &amp;&amp; suspend_ops-&gt;enter);<br>    <span class="hljs-comment">// 检查 suspend_ops 结构体和其中的 enter 成员是否存在。如果 suspend_ops 结构体存在且其中的 enter 成员不为 NULL，则返回 true。这表示系统支持进入指定的睡眠状态</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pm-notifier-call-chain-robust"><a href="#pm-notifier-call-chain-robust" class="headerlink" title="pm_notifier_call_chain_robust"></a>pm_notifier_call_chain_robust</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pm_notifier_call_chain_robust</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val_up, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val_down)</span><br>&#123;<span class="hljs-comment">//用于调用睡眠相关的通知链</span><br><span class="hljs-type">int</span> ret;<br>ret = blocking_notifier_call_chain_robust(&amp;pm_chain_head, val_up, val_down, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> notifier_to_errno(ret);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-freeze-processes"><a href="#suspend-freeze-processes" class="headerlink" title="suspend_freeze_processes"></a>suspend_freeze_processes</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_freeze_processes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br>error = freeze_processes();<span class="hljs-comment">//冻结所有用户进程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freeze_processes() automatically thaws every task if freezing</span><br><span class="hljs-comment"> * fails. So we need not do anything extra upon error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br>error = freeze_kernel_threads();<span class="hljs-comment">//冻结内核线程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freeze_kernel_threads() thaws only kernel threads upon freezing</span><br><span class="hljs-comment"> * failure. So we have to thaw the userspace tasks ourselves.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error)<br>thaw_processes();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="freeze-processes"><a href="#freeze-processes" class="headerlink" title="freeze_processes"></a>freeze_processes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * freeze_processes - Signal user space processes to enter the refrigerator.</span><br><span class="hljs-comment"> * The current thread will not be frozen.  The same process that calls</span><br><span class="hljs-comment"> * freeze_processes must later call thaw_processes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On success, returns 0.  On failure, -errno and system is fully thawed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_processes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>error = __usermodehelper_disable(UMH_FREEZING);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br><span class="hljs-comment">/* Make sure this task doesn&#x27;t get frozen */</span><br>current-&gt;flags |= PF_SUSPEND_TASK;<br><br><span class="hljs-keyword">if</span> (!pm_freezing)<br><span class="hljs-type">atomic_inc</span>(&amp;system_freezing_cnt);<br><br>pm_wakeup_clear(<span class="hljs-number">0</span>);<br>pr_info(<span class="hljs-string">&quot;Freezing user space processes ... &quot;</span>);<br>pm_freezing = <span class="hljs-literal">true</span>;<br>error = try_to_freeze_tasks(<span class="hljs-literal">true</span>);<span class="hljs-comment">//冻结所有用户空间进程</span><br><span class="hljs-keyword">if</span> (!error) &#123;<br>__usermodehelper_set_disable_depth(UMH_DISABLED);<br>pr_cont(<span class="hljs-string">&quot;done.&quot;</span>);<br>&#125;<br>pr_cont(<span class="hljs-string">&quot;\n&quot;</span>);<br>BUG_ON(in_atomic());<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now that the whole userspace is frozen we need to disable</span><br><span class="hljs-comment"> * the OOM killer to disallow any further interference with</span><br><span class="hljs-comment"> * killable tasks. There is no guarantee oom victims will</span><br><span class="hljs-comment"> * ever reach a point they go away we have to wait with a timeout.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!error &amp;&amp; !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))<br>error = -EBUSY;<br><br><span class="hljs-keyword">if</span> (error)<br>thaw_processes();<span class="hljs-comment">//解冻所有进程</span><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="freeze-kernel-threads"><a href="#freeze-kernel-threads" class="headerlink" title="freeze_kernel_threads"></a>freeze_kernel_threads</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * freeze_kernel_threads - Make freezable kernel threads go to the refrigerator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On success, returns 0.  On failure, -errno and only the kernel threads are</span><br><span class="hljs-comment"> * thawed, so as to give a chance to the caller to do additional cleanups</span><br><span class="hljs-comment"> * (if any) before thawing the userspace tasks. So, it is the responsibility</span><br><span class="hljs-comment"> * of the caller to thaw the userspace tasks, when the time is right.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_kernel_threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br>pr_info(<span class="hljs-string">&quot;Freezing remaining freezable tasks ... &quot;</span>);<br>pm_nosig_freezing = <span class="hljs-literal">true</span>;<br>error = try_to_freeze_tasks(<span class="hljs-literal">false</span>);<span class="hljs-comment">//冻结内核线程通过true和false来区别冻结用户进程还是内核线程</span><br><span class="hljs-keyword">if</span> (!error)<br>pr_cont(<span class="hljs-string">&quot;done.&quot;</span>);<br>pr_cont(<span class="hljs-string">&quot;\n&quot;</span>);<br>BUG_ON(in_atomic());<br><span class="hljs-keyword">if</span> (error)<br>thaw_kernel_threads();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-devices-and-enter"><a href="#suspend-devices-and-enter" class="headerlink" title="suspend_devices_and_enter"></a>suspend_devices_and_enter</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_devices_and_enter - Suspend devices and enter system sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">suspend_devices_and_enter</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><span class="hljs-type">bool</span> wakeup = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (!sleep_state_supported(state))<span class="hljs-comment">//判断当前平台是否实现了suspend_ops-&gt;enter</span><br><span class="hljs-keyword">return</span> -ENOSYS;<br><br>pm_suspend_target_state = state;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE)<br>pm_set_suspend_no_platform();<br><br>error = platform_suspend_begin(state);<span class="hljs-comment">//平台挂起</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Close;<br><br>suspend_console();<span class="hljs-comment">//挂起控制台</span><br>suspend_test_start();<br>error = dpm_suspend_start(PMSG_SUSPEND);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;Some devices failed to suspend, or early wake event detected\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Recover_platform;<br>&#125;<br>suspend_test_finish(<span class="hljs-string">&quot;suspend devices&quot;</span>);<br><span class="hljs-keyword">if</span> (suspend_test(TEST_DEVICES))<br><span class="hljs-keyword">goto</span> Recover_platform;<br><br><span class="hljs-keyword">do</span> &#123;<br>error = suspend_enter(state, &amp;wakeup);<br>&#125; <span class="hljs-keyword">while</span> (!error &amp;&amp; !wakeup &amp;&amp; platform_suspend_again(state));<br><br> Resume_devices:<br>suspend_test_start();<br>dpm_resume_end(PMSG_RESUME);<br>suspend_test_finish(<span class="hljs-string">&quot;resume devices&quot;</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;resume_console&quot;</span>), state, <span class="hljs-literal">true</span>);<br>resume_console();<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;resume_console&quot;</span>), state, <span class="hljs-literal">false</span>);<br><br> Close:<br>platform_resume_end(state);<br>pm_suspend_target_state = PM_SUSPEND_ON;<br><span class="hljs-keyword">return</span> error;<br><br> Recover_platform:<br>platform_recover(state);<br><span class="hljs-keyword">goto</span> Resume_devices;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dpm-suspend-start"><a href="#dpm-suspend-start" class="headerlink" title="dpm_suspend_start"></a>dpm_suspend_start</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend_start - Prepare devices for PM transition and suspend them.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Prepare all non-sysdev devices for system PM transition and execute &quot;suspend&quot;</span><br><span class="hljs-comment"> * callbacks for them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend_start</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><span class="hljs-comment">//挂起设备</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error;<br><br>error = dpm_prepare(state);<span class="hljs-comment">//执行所有设备的prepare回调函数</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_prepare++;<br>dpm_save_failed_step(SUSPEND_PREPARE);<br>&#125; <span class="hljs-keyword">else</span><br>error = dpm_suspend(state);<span class="hljs-comment">//执行所有设备的suspend回调函数</span><br>dpm_show_time(starttime, state, error, <span class="hljs-string">&quot;start&quot;</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-prepare"><a href="#dpm-prepare" class="headerlink" title="dpm_prepare"></a>dpm_prepare</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_prepare - Prepare all non-sysdev devices for a system PM transition.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Execute the -&gt;prepare() callback(s) for all devices.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_prepare</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_prepare&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>might_sleep();<span class="hljs-comment">//在可能会导致进程睡眠的上下文中检查睡眠情况</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Give a chance for the known devices to complete their probes, before</span><br><span class="hljs-comment"> * disable probing of devices. This sync point is important at least</span><br><span class="hljs-comment"> * at boot time + hibernation restore.</span><br><span class="hljs-comment"> */</span><br>wait_for_device_probe();<span class="hljs-comment">//等待所有设备的探测完成。在系统启动或从休眠状态恢复时，设备可能正在被探测，这个函数确保在进行电源管理转换之前，所有设备的探测都已完成</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * It is unsafe if probing of devices will happen during suspend or</span><br><span class="hljs-comment"> * hibernation and system behavior will be unpredictable in this case.</span><br><span class="hljs-comment"> * So, let&#x27;s prohibit device&#x27;s probing here and defer their probes</span><br><span class="hljs-comment"> * instead. The normal behavior will be restored in dpm_complete().</span><br><span class="hljs-comment"> */</span><br>device_block_probing();<span class="hljs-comment">//禁止设备探测,在执行系统挂起或休眠操作期间，新的设备探测可能会导致不确定的系统行为，因此需要禁止设备探测。这个函数会暂时禁止设备探测，并推迟设备的探测直到稍后的时间点</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_list.next);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>trace_device_pm_callback_start(dev, <span class="hljs-string">&quot;&quot;</span>, state.event);<br>error = device_prepare(dev, state);<span class="hljs-comment">//准备设备进行电源管理转换。调用设备的 prepare() 回调函数来执行准备工作，以确保设备在进行电源管理转换之前处于正确的状态</span><br>trace_device_pm_callback_end(dev, error);<br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-keyword">if</span> (error == -EAGAIN) &#123;<br>put_device(dev);<br>error = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>pr_info(<span class="hljs-string">&quot;Device %s not prepared for power transition: code %d\n&quot;</span>,<br>dev_name(dev), error);<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dev-&gt;power.is_prepared = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move_tail(&amp;dev-&gt;power.entry, &amp;dpm_prepared_list);<span class="hljs-comment">//用于将准备好的设备移到已准备列表中</span><br>put_device(dev);<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_prepare&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-suspend"><a href="#dpm-suspend" class="headerlink" title="dpm_suspend"></a>dpm_suspend</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend - Execute &quot;suspend&quot; callbacks for all non-sysdev devices.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><span class="hljs-comment">//执行所有非系统设备的 &quot;suspend&quot; 回调函数</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>might_sleep();<br><br>devfreq_suspend();<span class="hljs-comment">//暂时挂起设备频率调节器</span><br>cpufreq_suspend();<span class="hljs-comment">//暂时挂起 CPU 频率调节器</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br>pm_transition = state;<br>async_error = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_prepared_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_prepared_list.prev);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>error = device_suspend(dev);<span class="hljs-comment">//调用设备的挂起回调函数，执行设备的挂起操作</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pm_dev_err(dev, state, <span class="hljs-string">&quot;&quot;</span>, error);<br>dpm_save_failed_dev(dev_name(dev));<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move(&amp;dev-&gt;power.entry, &amp;dpm_suspended_list);<span class="hljs-comment">//将已挂起的设备从准备好的设备列表移到已挂起的设备列表中</span><br>put_device(dev);<br><span class="hljs-keyword">if</span> (async_error)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>async_synchronize_full();<br><span class="hljs-keyword">if</span> (!error)<br>error = async_error;<br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_suspend++;<br>dpm_save_failed_step(SUSPEND_SUSPEND);<br>&#125;<br>dpm_show_time(starttime, state, error, <span class="hljs-literal">NULL</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-suspend"><a href="#device-suspend" class="headerlink" title="device_suspend"></a>device_suspend</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_suspend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dpm_async_fn(dev, async_suspend))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> __device_suspend(dev, pm_transition, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="suspend-enter"><a href="#suspend-enter" class="headerlink" title="suspend_enter"></a>suspend_enter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_enter - Make the system enter the given sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> * @wakeup: Returns information that the sleep state should not be re-entered.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function should be called after devices have been suspended.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_enter</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state, <span class="hljs-type">bool</span> *wakeup)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>error = platform_suspend_prepare(state);<span class="hljs-comment">//调用平台相关的prepare回调函数</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Platform_finish;<br><br>error = dpm_suspend_late(PMSG_SUSPEND);<span class="hljs-comment">//对所有设备执行“suspend late”回调</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;late suspend of devices failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Platform_finish;<br>&#125;<br>error = platform_suspend_prepare_late(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Devices_early_resume;<br><br>error = dpm_suspend_noirq(PMSG_SUSPEND);<span class="hljs-comment">//执行系统挂起过程中的&quot;noirq挂起&quot;回调函数。这些回调函数会在设备驱动程序的中断处理程序被调用之前执行</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;noirq suspend of devices failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Platform_early_resume;<br>&#125;<br>error = platform_suspend_prepare_noirq(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Platform_wake;<br><br><span class="hljs-keyword">if</span> (suspend_test(TEST_PLATFORM))<br><span class="hljs-keyword">goto</span> Platform_wake;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE) &#123;<br>s2idle_loop();<br><span class="hljs-keyword">goto</span> Platform_wake;<br>&#125;<br><br>error = suspend_disable_secondary_cpus();<br><span class="hljs-keyword">if</span> (error || suspend_test(TEST_CPUS))<br><span class="hljs-keyword">goto</span> Enable_cpus;<br><br>arch_suspend_disable_irqs();<span class="hljs-comment">//禁用本地 CPU 上的中断</span><br>BUG_ON(!irqs_disabled());<br><br>system_state = SYSTEM_SUSPEND;<br><br>error = syscore_suspend();<br><span class="hljs-keyword">if</span> (!error) &#123;<br>*wakeup = pm_wakeup_pending();<br><span class="hljs-keyword">if</span> (!(suspend_test(TEST_CORE) || *wakeup)) &#123;<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;machine_suspend&quot;</span>),<br>state, <span class="hljs-literal">true</span>);<br>error = suspend_ops-&gt;enter(state);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;machine_suspend&quot;</span>),<br>state, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*wakeup) &#123;<br>error = -EBUSY;<br>&#125;<br>syscore_resume();<br>&#125;<br><br>system_state = SYSTEM_RUNNING;<br><br>arch_suspend_enable_irqs();<br>BUG_ON(irqs_disabled());<br><br> Enable_cpus:<br>suspend_enable_secondary_cpus();<br><br> Platform_wake:<br>platform_resume_noirq(state);<br>dpm_resume_noirq(PMSG_RESUME);<br><br> Platform_early_resume:<br>platform_resume_early(state);<br><br> Devices_early_resume:<br>dpm_resume_early(PMSG_RESUME);<br><br> Platform_finish:<br>platform_resume_finish(state);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-suspend-noirq"><a href="#dpm-suspend-noirq" class="headerlink" title="dpm_suspend_noirq"></a>dpm_suspend_noirq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend_noirq - Execute &quot;noirq suspend&quot; callbacks for all devices.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Prevent device drivers&#x27; interrupt handlers from being called and invoke</span><br><span class="hljs-comment"> * &quot;noirq&quot; suspend callbacks for all non-sysdev devices.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend_noirq</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>cpuidle_pause();<span class="hljs-comment">//暂停CPU空闲状态管理器，以确保CPU不会在挂起过程中进入空闲状态</span><br><br>device_wakeup_arm_wake_irqs();<span class="hljs-comment">//激活设备唤醒的唤醒中断</span><br>suspend_device_irqs();<span class="hljs-comment">//暂停设备的中断处理程序，防止在挂起过程中中断被处理</span><br><br>ret = dpm_noirq_suspend_devices(state);<span class="hljs-comment">//执行所有设备的&quot;noirq挂起&quot;回调函数。这些回调函数是在设备的中断处理程序被禁用后执行的</span><br><span class="hljs-keyword">if</span> (ret)<br>dpm_resume_noirq(resume_event(state));<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-wakeup-arm-wake-irqs"><a href="#device-wakeup-arm-wake-irqs" class="headerlink" title="device_wakeup_arm_wake_irqs"></a>device_wakeup_arm_wake_irqs</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * device_wakeup_arm_wake_irqs(void)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Itereates over the list of device wakeirqs to arm them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">device_wakeup_arm_wake_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//迭代设备的唤醒中断列表，以启用它们的唤醒状态</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wakeup_source</span> *<span class="hljs-title">ws</span>;</span><br><span class="hljs-type">int</span> srcuidx;<br><br>srcuidx = srcu_read_lock(&amp;wakeup_srcu);<br>list_for_each_entry_rcu_locked(ws, &amp;wakeup_sources, entry)<br>dev_pm_arm_wake_irq(ws-&gt;wakeirq);<br>srcu_read_unlock(&amp;wakeup_srcu, srcuidx);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="suspend-device-irqs"><a href="#suspend-device-irqs" class="headerlink" title="suspend_device_irqs"></a>suspend_device_irqs</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_device_irqs - disable all currently enabled interrupt lines</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * During system-wide suspend or hibernation device drivers need to be</span><br><span class="hljs-comment"> * prevented from receiving interrupts and this function is provided</span><br><span class="hljs-comment"> * for this purpose.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * So we disable all interrupts and mark them IRQS_SUSPENDED except</span><br><span class="hljs-comment"> * for those which are unused, those which are marked as not</span><br><span class="hljs-comment"> * suspendable via an interrupt request with the flag IRQF_NO_SUSPEND</span><br><span class="hljs-comment"> * set and those which are marked as active wakeup sources.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The active wakeup sources are handled by the flow handler entry</span><br><span class="hljs-comment"> * code which checks for the IRQD_WAKEUP_ARMED flag, suspends the</span><br><span class="hljs-comment"> * interrupt and notifies the pm core about the wakeup.</span><br><span class="hljs-comment"> * 在系统全局挂起或休眠期间，防止设备驱动程序接收中断。在挂起期间，函数将禁用所有中断，并将它们标记为 IRQS_SUSPENDED，除非中断未使用、被标记为不可挂起（通过设置 IRQF_NO_SUSPEND 标志），或者被标记为活动唤醒源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">suspend_device_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//在系统挂起或休眠期间禁用所有当前已启用的中断线</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> *<span class="hljs-title">desc</span>;</span><br><span class="hljs-type">int</span> irq;<br><br>for_each_irq_desc(irq, desc) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">bool</span> sync;<br><br><span class="hljs-keyword">if</span> (irq_settings_is_nested_thread(desc))<br><span class="hljs-keyword">continue</span>;<br>raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<br>sync = suspend_device_irq(desc);<br>raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<br><br><span class="hljs-keyword">if</span> (sync)<br>synchronize_irq(irq);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="suspend-device-irq"><a href="#suspend-device-irq" class="headerlink" title="suspend_device_irq"></a>suspend_device_irq</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">suspend_device_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> chipflags = irq_desc_get_chip(desc)-&gt;flags;<span class="hljs-comment">//获取与中断描述符相关联的中断控制器的标志</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> *<span class="hljs-title">irqd</span> =</span> &amp;desc-&gt;irq_data;<br><br><span class="hljs-keyword">if</span> (!desc-&gt;action || irq_desc_is_chained(desc) ||<br>    desc-&gt;no_suspend_depth)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (irqd_is_wakeup_set(irqd)) &#123;<span class="hljs-comment">//检查中断是否设置为唤醒中断</span><br>irqd_set(irqd, IRQD_WAKEUP_ARMED);<span class="hljs-comment">//设置中断数据结构的 IRQD_WAKEUP_ARMED 标志，表示该中断已被设置为唤醒中断</span><br><br><span class="hljs-keyword">if</span> ((chipflags &amp; IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &amp;&amp;<br>     irqd_irq_disabled(irqd)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupt marked for wakeup is in disabled state.</span><br><span class="hljs-comment"> * Enable interrupt here to unmask/enable in irqchip</span><br><span class="hljs-comment"> * to be able to resume with such interrupts.</span><br><span class="hljs-comment"> */</span><br>__enable_irq(desc);<span class="hljs-comment">//启用该中断，以便在中断控制器中取消屏蔽该中断</span><br>irqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);<span class="hljs-comment">//设置中断数据结构的 IRQD_IRQ_ENABLED_ON_SUSPEND 标志，表示该中断在挂起期间已被启用</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We return true here to force the caller to issue</span><br><span class="hljs-comment"> * synchronize_irq(). We need to make sure that the</span><br><span class="hljs-comment"> * IRQD_WAKEUP_ARMED is visible before we return from</span><br><span class="hljs-comment"> * suspend_device_irqs().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>desc-&gt;istate |= IRQS_SUSPENDED;<span class="hljs-comment">//将中断描述符的 istate 字段的 IRQS_SUSPENDED 标志设置为1，表示该中断已被挂起</span><br>__disable_irq(desc);<span class="hljs-comment">//禁用该中断</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Hardware which has no wakeup source configuration facility</span><br><span class="hljs-comment"> * requires that the non wakeup interrupts are masked at the</span><br><span class="hljs-comment"> * chip level. The chip implementation indicates that with</span><br><span class="hljs-comment"> * IRQCHIP_MASK_ON_SUSPEND.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (chipflags &amp; IRQCHIP_MASK_ON_SUSPEND)<span class="hljs-comment">//检查中断控制器标志是否设置了 IRQCHIP_MASK_ON_SUSPEND 标志，如果设置了，表示硬件没有唤醒源配置功能，需要在芯片级别屏蔽非唤醒中断</span><br>mask_irq(desc);<span class="hljs-comment">//在硬件层面屏蔽非唤醒中断，调用中断控制器芯片中的特定函数来实现这一操作</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="dpm-noirq-suspend-devices"><a href="#dpm-noirq-suspend-devices" class="headerlink" title="dpm_noirq_suspend_devices"></a>dpm_noirq_suspend_devices</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dpm_noirq_suspend_devices</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend_noirq&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>mutex_lock(&amp;dpm_list_mtx);<br>pm_transition = state;<br>async_error = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_late_early_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_late_early_list.prev);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>error = device_suspend_noirq(dev);<br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pm_dev_err(dev, state, <span class="hljs-string">&quot; noirq&quot;</span>, error);<br>dpm_save_failed_dev(dev_name(dev));<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move(&amp;dev-&gt;power.entry, &amp;dpm_noirq_list);<br>put_device(dev);<br><br><span class="hljs-keyword">if</span> (async_error)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>async_synchronize_full();<br><span class="hljs-keyword">if</span> (!error)<br>error = async_error;<br><br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_suspend_noirq++;<br>dpm_save_failed_step(SUSPEND_SUSPEND_NOIRQ);<br>&#125;<br>dpm_show_time(starttime, state, error, <span class="hljs-string">&quot;noirq&quot;</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend_noirq&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-suspend-noirq"><a href="#device-suspend-noirq" class="headerlink" title="device_suspend_noirq"></a>device_suspend_noirq</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_suspend_noirq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dpm_async_fn(dev, async_suspend_noirq))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> __device_suspend_noirq(dev, pm_transition, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="suspend-disable-secondary-cpus"><a href="#suspend-disable-secondary-cpus" class="headerlink" title="suspend_disable_secondary_cpus"></a>suspend_disable_secondary_cpus</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_disable_secondary_cpus</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> cpu = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU))<span class="hljs-comment">//如果启用了这个配置选项，将 cpu 的值设置为-1，表示要禁用所有辅助 CPU</span><br>cpu = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">return</span> freeze_secondary_cpus(cpu);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="freeze-secondary-cpus"><a href="#freeze-secondary-cpus" class="headerlink" title="freeze_secondary_cpus"></a>freeze_secondary_cpus</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_secondary_cpus</span><span class="hljs-params">(<span class="hljs-type">int</span> primary)</span><br>&#123;<br><span class="hljs-type">int</span> cpu, error = <span class="hljs-number">0</span>;<br><br>cpu_maps_update_begin();<br><span class="hljs-keyword">if</span> (primary == <span class="hljs-number">-1</span>) &#123;<br>primary = cpumask_first(cpu_online_mask);<br><span class="hljs-keyword">if</span> (!housekeeping_cpu(primary, HK_FLAG_TIMER))<br>primary = housekeeping_any_cpu(HK_FLAG_TIMER);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (!cpu_online(primary))<br>primary = cpumask_first(cpu_online_mask);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We take down all of the non-boot CPUs in one shot to avoid races</span><br><span class="hljs-comment"> * with the userspace trying to use the CPU hotplug at the same time</span><br><span class="hljs-comment"> */</span><br>cpumask_clear(frozen_cpus);<br><br>pr_info(<span class="hljs-string">&quot;Disabling non-boot CPUs ...\n&quot;</span>);<br>for_each_online_cpu(cpu) &#123;<br><span class="hljs-keyword">if</span> (cpu == primary)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (pm_wakeup_pending()) &#123;<br>pr_info(<span class="hljs-string">&quot;Wakeup pending. Abort CPU freeze\n&quot;</span>);<br>error = -EBUSY;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;CPU_OFF&quot;</span>), cpu, <span class="hljs-literal">true</span>);<br>error = _cpu_down(cpu, <span class="hljs-number">1</span>, CPUHP_OFFLINE);<span class="hljs-comment">//禁用指定的 CPU</span><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;CPU_OFF&quot;</span>), cpu, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!error)<br>cpumask_set_cpu(cpu, frozen_cpus);<br><span class="hljs-keyword">else</span> &#123;<br>pr_err(<span class="hljs-string">&quot;Error taking CPU%d down: %d\n&quot;</span>, cpu, error);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!error)<br>BUG_ON(num_online_cpus() &gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>pr_err(<span class="hljs-string">&quot;Non-boot CPUs are not disabled\n&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Make sure the CPUs won&#x27;t be enabled by someone else. We need to do</span><br><span class="hljs-comment"> * this even in case of failure as all freeze_secondary_cpus() users are</span><br><span class="hljs-comment"> * supposed to do thaw_secondary_cpus() on the failure path.</span><br><span class="hljs-comment"> */</span><br>cpu_hotplug_disabled++;<br><br>cpu_maps_update_done();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="arch-suspend-disable-irqs"><a href="#arch-suspend-disable-irqs" class="headerlink" title="arch_suspend_disable_irqs"></a>arch_suspend_disable_irqs</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* default implementation */</span><br><span class="hljs-type">void</span> __weak <span class="hljs-title function_">arch_suspend_disable_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>local_irq_disable();<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="local-irq-disable"><a href="#local-irq-disable" class="headerlink" title="local_irq_disable"></a>local_irq_disable</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> local_irq_disable()\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">bool was_disabled = raw_irqs_disabled();\<span class="hljs-comment">//检查中断是否已经被禁用</span></span><br>raw_local_irq_disable();\<span class="hljs-comment">//禁用本地 CPU 上的中断，这是一个底层函数，用于将中断掩码设置为禁用状态</span><br><span class="hljs-keyword">if</span> (!was_disabled)\<br>trace_hardirqs_off();\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="syscore-suspend"><a href="#syscore-suspend" class="headerlink" title="syscore_suspend"></a>syscore_suspend</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * syscore_suspend - Execute all the registered system core suspend callbacks.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is executed with one CPU on-line and disabled interrupts.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">syscore_suspend</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">syscore_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;syscore_suspend&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>pm_pr_dbg(<span class="hljs-string">&quot;Checking wakeup interrupts\n&quot;</span>);<br><br><span class="hljs-comment">/* Return error code if there are any wakeup interrupts pending. */</span><br><span class="hljs-keyword">if</span> (pm_wakeup_pending())<br><span class="hljs-keyword">return</span> -EBUSY;<br><br>WARN_ONCE(!irqs_disabled(),<br><span class="hljs-string">&quot;Interrupts enabled before system core suspend.\n&quot;</span>);<br><br>list_for_each_entry_reverse(ops, &amp;syscore_ops_list, node)<br><span class="hljs-keyword">if</span> (ops-&gt;suspend) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Calling %pS\n&quot;</span>, ops-&gt;suspend);<br>ret = ops-&gt;suspend();<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> err_out;<br>WARN_ONCE(!irqs_disabled(),<br><span class="hljs-string">&quot;Interrupts enabled after %pS\n&quot;</span>, ops-&gt;suspend);<br>&#125;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;syscore_suspend&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err_out:<br>pr_err(<span class="hljs-string">&quot;PM: System core suspend callback %pS failed.\n&quot;</span>, ops-&gt;suspend);<br><br>list_for_each_entry_continue(ops, &amp;syscore_ops_list, node)<br><span class="hljs-keyword">if</span> (ops-&gt;resume)<br>ops-&gt;resume();<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="suspend-ops-enter"><a href="#suspend-ops-enter" class="headerlink" title="suspend_ops-&gt;enter"></a>suspend_ops-&gt;enter</h4><p>执行挂起操作等待唤醒信号</p>]]></content>
    
    
    <categories>
      
      <category>PM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用脚本</title>
    <link href="/script/README/"/>
    <url>/script/README/</url>
    
    <content type="html"><![CDATA[<h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><p><code>cat_usb_device_power_wakeup.sh</code>查看USB设备是否支持电源唤醒</p>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>USB子系统</title>
    <link href="/kernel/usb/usb%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/kernel/usb/usb%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="USB子系统"><a href="#USB子系统" class="headerlink" title="USB子系统"></a>USB子系统</h2><h3 id="USB子系统框架"><a href="#USB子系统框架" class="headerlink" title="USB子系统框架"></a>USB子系统框架</h3><img src="/kernel/usb/usb%E5%AD%90%E7%B3%BB%E7%BB%9F/usb.png" class="" title="usb"> <ul><li>USB设备驱动：用于和枚举到的USB设备进行绑定，完成特定的功能</li><li>USB Core：用于内核USB总线的初始化及USB相关API，为设备驱动和HCD的交互提供桥梁</li><li>USB主机控制器HCD：完成主机控制器的初始化以及数据的传输，并监测外部设备插入，完成设备枚举</li></ul><h3 id="USB传输类型"><a href="#USB传输类型" class="headerlink" title="USB传输类型"></a>USB传输类型</h3><ul><li>控制传输：控制传输是双向传输，数据量通常比较小，主要指由USB总线驱动程序用来进行查询、配置以及给USB设备发送通用的命令。控制传输典型地用在主计算机和USB外设之间的端点0(Endpoint 0)之间的传输，但是指定供应商的控制传输可能用到其它的端点。比如：USB设备的识别过程。</li><li>批量传输：主要应用在数据大量传输，同时又没有带宽和间隔时间要求的情况下，进行可靠传输。比如：U盘拷贝数据。</li><li>中断传输：中断传输主要用于定时查询设备是否有中断数据要传输，设备的端点模式器的结构决定了它的查询频率，从1到255ms之间。这种传输方式典型的应用在少量的、分散的、不可预测数据的传输，比如，键盘和鼠标就属于这一类型。中断传输是单向的并且对于host来说只有输入的方式。</li><li>实时传输：实时传输提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传输率的即时应用中。比如：USB摄像头。</li></ul><h3 id="USB设备描述符"><a href="#USB设备描述符" class="headerlink" title="USB设备描述符"></a>USB设备描述符</h3><img src="/kernel/usb/usb%E5%AD%90%E7%B3%BB%E7%BB%9F/usb_intf_image.png" class="" title="usb_intf">  <ul><li>一个USB设备描述符中可以有多个配置描述符，即USB设备可以有多种配置；一个配置描述符中可以有多个接口描述符，即USB设备可以支持多种功能（接口）；一个接口描述符中可以有多个端点描述符。</li><li>一设备至少要包含设备描述符、配置描述符和接口描述符，如果USB设备没有端点描述符，则它仅仅用默认管道与主机进行数据传输。</li><li>接口，表示逻辑上的设备，比如USB声卡可以分为接口1-录音设备，接口2-播放设备。</li><li>访问设备时，即访问某个接口，接口表示逻辑设备。</li><li>传输数据时，即读写某个端口，端口是数据通道。</li></ul><h4 id="设备描述符"><a href="#设备描述符" class="headerlink" title="设备描述符"></a>设备描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_DEVICE: Device descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType; <span class="hljs-comment">//描述符类型 （此处应为0x01，即设备描述符）</span><br><br>    __le16 bcdUSB; <span class="hljs-comment">//usb版本号 200 -&gt; USB2.0</span><br>    __u8  bDeviceClass; <span class="hljs-comment">//设备类 </span><br>    __u8  bDeviceSubClass; <span class="hljs-comment">//设备类子类</span><br>    __u8  bDeviceProtocol; <span class="hljs-comment">//设备协议，以上三点都是USB官方定义</span><br>    __u8  bMaxPacketSize0; <span class="hljs-comment">//端点0最大包大小 （只能为8,16,32,64）</span><br>    __le16 idVendor; <span class="hljs-comment">//厂家id</span><br>    __le16 idProduct; <span class="hljs-comment">//产品id</span><br>    __le16 bcdDevice; <span class="hljs-comment">//设备出厂编号</span><br>    __u8  iManufacturer; <span class="hljs-comment">//描述厂商信息的字符串描述符的索引值</span><br>    __u8  iProduct; <span class="hljs-comment">//描述产品信息的字串描述符的索引值</span><br>    __u8  iSerialNumber; <span class="hljs-comment">//描述设备序列号信息的字串描述符的索引值 </span><br>    __u8  bNumConfigurations; <span class="hljs-comment">//可能的配置描述符的数目</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><p> USB设备描述符位于USB设备结构体usb_device中的成员descriptor中。同样地,配置、接口、端点描述符也是位于USB配置、接口、端点结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_device - kernel&#x27;s representation of a USB device</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> &#123;</span><br><span class="hljs-type">int</span>devnum;                    <span class="hljs-comment">// 设备编号；在USB总线上的地址</span><br><span class="hljs-type">char</span>devpath[<span class="hljs-number">16</span>];              <span class="hljs-comment">// 设备ID字符串，用于消息（例如，/port/...）</span><br>u32route;                    <span class="hljs-comment">// 树拓扑的十六进制字符串，用于xHCI</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_state</span><span class="hljs-title">state</span>;</span>                <span class="hljs-comment">// 设备状态：配置、未连接等</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">speed</span>;</span>                <span class="hljs-comment">// 设备速度：高/全/低（或错误）</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>rx_lanes;              <span class="hljs-comment">// 使用中的接收通道数量，USB 3.2添加了双通道支持</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>tx_lanes;              <span class="hljs-comment">// 使用中的传输通道数量，USB 3.2添加了双通道支持</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_tt</span>*<span class="hljs-title">tt</span>;</span>                    <span class="hljs-comment">// 事务转换器信息；用于低/全速设备、高速集线器</span><br><span class="hljs-type">int</span>ttport;                   <span class="hljs-comment">// 在事务转换器集线器上的设备端口</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> toggle[<span class="hljs-number">2</span>];                   <span class="hljs-comment">// 每个端点一个位，([0] = 输入， [1] = 输出) 端点</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">parent</span>;</span>                <span class="hljs-comment">// 我们的集线器，除非我们是根</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_bus</span> *<span class="hljs-title">bus</span>;</span>                      <span class="hljs-comment">// 我们所属的总线</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> <span class="hljs-title">ep0</span>;</span>             <span class="hljs-comment">// 端点0数据（默认控制管道）</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                        <span class="hljs-comment">// 通用设备接口</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> <span class="hljs-title">descriptor</span>;</span>  <span class="hljs-comment">// USB设备描述符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_bos</span> *<span class="hljs-title">bos</span>;</span>                 <span class="hljs-comment">// USB设备BOS描述符集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">config</span>;</span>           <span class="hljs-comment">// 设备的所有配置</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">actconfig</span>;</span>        <span class="hljs-comment">// 活动配置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_in</span>[16];</span>      <span class="hljs-comment">// 输入端点数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_out</span>[16];</span>     <span class="hljs-comment">// 输出端点数组</span><br><br><span class="hljs-type">char</span> **rawdescriptors;                    <span class="hljs-comment">// 每个配置的原始描述符</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bus_mA;                    <span class="hljs-comment">// 总线可用电流</span><br>u8 portnum;                               <span class="hljs-comment">// 父端口号（起始值为1）</span><br>u8 level;                                 <span class="hljs-comment">// USB集线器祖先的数量</span><br>u8 devaddr;                               <span class="hljs-comment">// 设备地址，XHCI：由硬件分配，其他：与devnum相同</span><br><br><span class="hljs-type">unsigned</span> can_submit:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 可以提交URB</span><br><span class="hljs-type">unsigned</span> persist_enabled:<span class="hljs-number">1</span>;               <span class="hljs-comment">// 启用USB_PERSIST</span><br><span class="hljs-type">unsigned</span> reset_in_progress:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 设备正在复位</span><br><span class="hljs-type">unsigned</span> have_langid:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// string_langid是否有效</span><br><span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 策略已允许我们使用它</span><br><span class="hljs-type">unsigned</span> authenticated:<span class="hljs-number">1</span>;                 <span class="hljs-comment">// 通过加密认证</span><br><span class="hljs-type">unsigned</span> wusb:<span class="hljs-number">1</span>;                          <span class="hljs-comment">// 设备是无线USB</span><br><span class="hljs-type">unsigned</span> lpm_capable:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// 设备支持LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_capable:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 设备可以执行USB2硬件LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_besl_capable:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 设备可以执行USB2硬件BESL LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB2硬件LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_allowed:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 用户空间允许启用USB 2.0 LPM</span><br><span class="hljs-type">unsigned</span> usb3_lpm_u1_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U1 LPM</span><br><span class="hljs-type">unsigned</span> usb3_lpm_u2_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U2 LPM</span><br><span class="hljs-type">int</span> string_langid;                        <span class="hljs-comment">// 字符串的语言ID</span><br><br><span class="hljs-comment">/* static strings from the device */</span><br><span class="hljs-type">char</span> *product;                            <span class="hljs-comment">// 如果存在，iProduct字符串（静态）</span><br><span class="hljs-type">char</span> *manufacturer;                       <span class="hljs-comment">// 如果存在，iManufacturer字符串（静态）</span><br><span class="hljs-type">char</span> *serial;                             <span class="hljs-comment">// 如果存在，iSerialNumber字符串（静态）</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">filelist</span>;</span>                <span class="hljs-comment">// 此设备打开的usbfs文件</span><br><br><span class="hljs-type">int</span> maxchild;                             <span class="hljs-comment">// 如果是集线器，端口数量</span><br><br>u32 quirks;                               <span class="hljs-comment">// 设备的怪癖</span><br><span class="hljs-type">atomic_t</span> urbnum;                          <span class="hljs-comment">// 提交的URB数量</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> active_duration;            <span class="hljs-comment">// 设备未挂起的总时间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> connect_time;               <span class="hljs-comment">// 设备首次连接时间</span><br><br><span class="hljs-type">unsigned</span> do_remote_wakeup:<span class="hljs-number">1</span>;              <span class="hljs-comment">// 启用远程唤醒</span><br><span class="hljs-type">unsigned</span> reset_resume:<span class="hljs-number">1</span>;                  <span class="hljs-comment">// 需要复位而不是恢复</span><br><span class="hljs-type">unsigned</span> port_is_suspended:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 上游端口被挂起（L2或U3）</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wusb_dev</span> *<span class="hljs-title">wusb_dev</span>;</span>                <span class="hljs-comment">// 如果这是无线USB设备，则链接到设备的WUSB特定数据</span><br><span class="hljs-type">int</span> slot_id;                              <span class="hljs-comment">// xHCI分配的插槽ID</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_removable</span> <span class="hljs-title">removable</span>;</span>      <span class="hljs-comment">// 设备可以从此端口物理移除</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb2_lpm_parameters</span> <span class="hljs-title">l1_params</span>;</span>     <span class="hljs-comment">// USB2 L1 LPM状态的最佳努力服务延迟和L1超时</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u1_params</span>;</span>     <span class="hljs-comment">// USB3 U1 LPM状态的退出延迟和集线器启动的超时</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u2_params</span>;</span>     <span class="hljs-comment">// USB3 U2 LPM状态的退出延迟和集线器启动的超时</span><br><span class="hljs-type">unsigned</span> lpm_disable_count;               <span class="hljs-comment">// Ref计数用于usb_disable_lpm()和usb_enable_lpm()跟踪需要禁用USB 3.0链路电源管理的函数数量。该计数应仅由这些函数在持有带宽互斥锁时操作。</span><br><br>u16 hub_delay;                            <span class="hljs-comment">// 缓存值，包括：</span><br>                                          <span class="hljs-comment">// parent-&gt;hub_delay + wHubDelay + tTPTransmissionDelay (40ns)</span><br>                                          <span class="hljs-comment">// 将用作SetIsochDelay请求的wValue。</span><br><span class="hljs-type">unsigned</span> use_generic_driver:<span class="hljs-number">1</span>;            <span class="hljs-comment">// 请求驱动程序核心使用通用驱动程序重新探测。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="配置描述符"><a href="#配置描述符" class="headerlink" title="配置描述符"></a>配置描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_config_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//描述符类型（本结构体中固定为0x02)  </span><br><br>    __le16 wTotalLength; <span class="hljs-comment">//该配置下，信息的总长度（包括配置，接口，端点和设备类及厂商定义的描述符）</span><br>    __u8  bNumInterfaces; <span class="hljs-comment">//接口的个数</span><br>    __u8  bConfigurationValue; <span class="hljs-comment">//Set_Configuration命令所需要的参数值，用来选定此配置</span><br>    __u8  iConfiguration; <span class="hljs-comment">//描述该配置的字符串描述的索引值 </span><br>    __u8  bmAttributes;<span class="hljs-comment">//供电模式的选择  </span><br>    __u8  bMaxPower;<span class="hljs-comment">//设备从总线提取的最大电流</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="接口描述符"><a href="#接口描述符" class="headerlink" title="接口描述符"></a>接口描述符</h4><p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为“功能”更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> &#123;</span><br>    __u8  bLength;      <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//接口描述符的类型编号(0x04）</span><br><br>    __u8  bInterfaceNumber;  <span class="hljs-comment">//该接口的编号  </span><br>    __u8  bAlternateSetting; <span class="hljs-comment">//备用的接口描述符编号  </span><br>    __u8  bNumEndpoints; <span class="hljs-comment">//该接口使用的端点数，不包括端点0  </span><br>    __u8  bInterfaceClass; <span class="hljs-comment">//接口类</span><br>    __u8  bInterfaceSubClass; <span class="hljs-comment">//子类</span><br>    __u8  bInterfaceProtocol; <span class="hljs-comment">//协议</span><br>    __u8  iInterface;<span class="hljs-comment">//描述此接口的字串描述表的索引值  </span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><p>它位于usb_interface-&gt;cur_altsetting-&gt;desc 这个成员结构体里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_interface - what usb device drivers talk to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface</span> &#123;</span><br><span class="hljs-comment">/* array of alternate settings for this interface,</span><br><span class="hljs-comment"> * stored in no particular order */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">altsetting</span>;</span>              <span class="hljs-comment">// 备用设置的数组，无特定顺序</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">cur_altsetting</span>;</span>          <span class="hljs-comment">// 当前活动的备用设置</span><br><span class="hljs-type">unsigned</span> num_altsetting;                            <span class="hljs-comment">// 定义的备用设置数量</span><br><br><span class="hljs-comment">/* If there is an interface association descriptor then it will list</span><br><span class="hljs-comment"> * the associated interfaces */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_assoc_descriptor</span> *<span class="hljs-title">intf_assoc</span>;</span>  <span class="hljs-comment">// 接口关联描述符</span><br><br><span class="hljs-type">int</span> minor;                                          <span class="hljs-comment">// 分配给此接口的次设备号</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_interface_condition</span> <span class="hljs-title">condition</span>;</span>             <span class="hljs-comment">// 绑定状态</span><br><span class="hljs-type">unsigned</span> sysfs_files_created:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// sysfs属性存在</span><br><span class="hljs-type">unsigned</span> ep_devs_created:<span class="hljs-number">1</span>;                         <span class="hljs-comment">// 端点伪设备存在</span><br><span class="hljs-type">unsigned</span> unregistering:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 注销中</span><br><span class="hljs-type">unsigned</span> needs_remote_wakeup:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// 驱动程序需要远程唤醒</span><br><span class="hljs-type">unsigned</span> needs_altsetting0:<span class="hljs-number">1</span>;                       <span class="hljs-comment">// 切换到备用设置0待处理</span><br><span class="hljs-type">unsigned</span> needs_binding:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 需要延迟解除绑定/重新绑定</span><br><span class="hljs-type">unsigned</span> resetting_device:<span class="hljs-number">1</span>;                        <span class="hljs-comment">// 复位后需要带宽分配</span><br><span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                              <span class="hljs-comment">// 接口授权</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                                  <span class="hljs-comment">// 接口特定的设备信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">usb_dev</span>;</span>                             <span class="hljs-comment">// 如果接口绑定到USB主设备号，则指向该设备的sysfs表示</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">reset_ws</span>;</span>                        <span class="hljs-comment">// 用于在原子上下文中复位的工作结构</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* host-side wrapper for one interface setting&#x27;s parsed descriptors */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> <span class="hljs-title">desc</span>;</span>  <span class="hljs-comment">// 接口描述符</span><br><br><span class="hljs-type">int</span> extralen;                          <span class="hljs-comment">// 额外描述符的长度</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *extra;                  <span class="hljs-comment">// 额外描述符</span><br><br><span class="hljs-comment">/* array of desc.bNumEndpoints endpoints associated with this</span><br><span class="hljs-comment"> * interface setting.  these will be in no particular order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">endpoint</span>;</span>    <span class="hljs-comment">// 该接口设置关联的端点数组，无特定顺序</span><br><br><span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>;                          <span class="hljs-comment">// iInterface字符串，如果存在</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="端点描述符"><a href="#端点描述符" class="headerlink" title="端点描述符"></a>端点描述符</h4><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。<br>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_ENDPOINT: Endpoint descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> &#123;</span><br>    __u8  bLength;        <span class="hljs-comment">//端点描述符字节数大小（7个字节）</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//端点描述符类型编号（0x05) </span><br><br>    __u8  bEndpointAddress; <span class="hljs-comment">//此描述表所描述的端点的地址、方向 : </span><br>                            <span class="hljs-comment">// bit3~bit0:端点号，bit6~bit4:保留，</span><br>                            <span class="hljs-comment">// bit7:方向，如果是控制端点则忽略，0-输出端点（主机到设备）1-输入端点（设备到主机）</span><br>    __u8  bmAttributes; <span class="hljs-comment">// 端点特性，bit1~bit0 表示传输类型，其他位保留</span><br>                        <span class="hljs-comment">// 00-控制传输  01-实时传输   10-批量传输 11-中断传输</span><br>    __le16 wMaxPacketSize;  <span class="hljs-comment">//端点收、发的最大包大小</span><br>    __u8  bInterval; <span class="hljs-comment">// 中断传输模式中主机查询端点的时间间隔。</span><br>                     <span class="hljs-comment">// 对于实时传输的端点此域必需为1，表示周期为1ms。对于中断传输的端点此域值的范围为1ms到255ms</span><br><br>    <span class="hljs-comment">/* <span class="hljs-doctag">NOTE:</span>  these two are _only_ in audio endpoints. */</span><br>    <span class="hljs-comment">/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */</span><br>    __u8  bRefresh;<br>    __u8  bSynchAddress;<br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="字符串描述符"><a href="#字符串描述符" class="headerlink" title="字符串描述符"></a>字符串描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_string_descriptor</span> &#123;</span><br>    __u8  bLength;  <span class="hljs-comment">// 此描述表的字节数（bString域的数值N＋2）</span><br>    __u8  bDescriptorType; <span class="hljs-comment">// 字串描述表类型（此处应为0x03）</span><br><br>    __le16 wData[<span class="hljs-number">1</span>];        <span class="hljs-comment">/* UTF-16LE encoded */</span>  <br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="人机接口描述符"><a href="#人机接口描述符" class="headerlink" title="人机接口描述符"></a>人机接口描述符</h4><p>USB 设备中有一大类就是 HID 设备，即 Human Interface Devices，人机接口设备。这类设备包括鼠标、键盘等，主要用于人与计算机进行交互。 它是 USB 协议最早支持的一种设备类。 HID 设备可以作为低速、全速、高速设备用。由于 HID 设备要求用户输入能得到及时响应，故其传输方式通常采用中断方式。 在 USB 协议中， HID 设备的定义放置在接口描述符中， USB 的设备描述符和配置描述符中不包含 HID 设备的信息。因此，对于某些特定的 HID 设备，可以定义多个接口，只有其中一个接口为 HID 设备类即可。</p><h4 id="USB描述符类型值"><a href="#USB描述符类型值" class="headerlink" title="USB描述符类型值"></a>USB描述符类型值</h4><table><thead><tr><th>类型</th><th>描述符</th><th>类型值</th></tr></thead><tbody><tr><td>标准描述符</td><td>设备描述符</td><td>0x01</td></tr><tr><td></td><td>配置描述符</td><td>0x02</td></tr><tr><td></td><td>字符串描述符</td><td>0x03</td></tr><tr><td></td><td>接口描述符</td><td>0x04</td></tr><tr><td></td><td>端点描述符</td><td>0x05</td></tr><tr><td>类描述符</td><td>集线器类描述符</td><td>0x29</td></tr><tr><td></td><td>人机接口类描述符</td><td>0x21</td></tr><tr><td>厂商定义的描述符</td><td></td><td>0xff</td></tr></tbody></table><h3 id="USB的数据传输对象"><a href="#USB的数据传输对象" class="headerlink" title="USB的数据传输对象"></a>USB的数据传输对象</h3><p>端点，一个USB设备可以有多个端点，和主机间的数据传输称为到设备端点的数据传输。比如说，对于一个U盘，可以细分为两个端点，把数据写到U盘的端点1、从U盘的端点2读取数据。</p><h2 id="USB总线驱动框架"><a href="#USB总线驱动框架" class="headerlink" title="USB总线驱动框架"></a>USB总线驱动框架</h2><h3 id="USB-Core"><a href="#USB-Core" class="headerlink" title="USB Core"></a>USB Core</h3><p>初始化内核USB总线提供USB相关API，为设备驱动和HCD的交互提供桥梁。</p><blockquote><p>Linux启动阶段，通过<strong>subsys_initcall</strong>会完成USB Core的加载</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">subsys_initcall(usb_init);<br></code></pre></td></tr></table></figure><h4 id="usb-init"><a href="#usb-init" class="headerlink" title="usb_init"></a>usb_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">usb_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> retval;<br><span class="hljs-keyword">if</span> (usb_disabled()) &#123;<br>pr_info(<span class="hljs-string">&quot;%s: USB support disabled\n&quot;</span>, usbcore_name);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>usb_init_pool_max();<br><br>usb_debugfs_init();<br><br>usb_acpi_register();<br>retval = bus_register(&amp;usb_bus_type);<span class="hljs-comment">//USB总线的创建</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_register_failed;<br>retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_notifier_failed;<br>retval = usb_major_init();<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> major_init_failed;<br>retval = usb_register(&amp;usbfs_driver);<span class="hljs-comment">//注册USB接口驱动</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> driver_register_failed;<br>retval = usb_devio_init();<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> usb_devio_init_failed;<br>retval = usb_hub_init();<span class="hljs-comment">//初始化一个USB设备集线器，用来检测USB设备的连接和断开。</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> hub_init_failed;<br>retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<span class="hljs-comment">//注册USB设备驱动</span><br><span class="hljs-keyword">if</span> (!retval)<br><span class="hljs-keyword">goto</span> out;<br><br>usb_hub_cleanup();<br>hub_init_failed:<br>usb_devio_cleanup();<br>usb_devio_init_failed:<br>usb_deregister(&amp;usbfs_driver);<br>driver_register_failed:<br>usb_major_cleanup();<br>major_init_failed:<br>bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br>bus_notifier_failed:<br>bus_unregister(&amp;usb_bus_type);<br>bus_register_failed:<br>usb_acpi_unregister();<br>usb_debugfs_cleanup();<br>out:<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册USB总线"><a href="#注册USB总线" class="headerlink" title="注册USB总线"></a>注册USB总线</h4><p>USB是基于总线-驱动-设备模型的框架，其初始化阶段一个重点任务就是完成USB总线的创建。usb_bus_type提供了驱动和设备匹配的匹配函数，后面注册设备和驱动时会调用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = bus_register(&amp;usb_bus_type);<br><span class="hljs-keyword">if</span> (retval) <br>    <span class="hljs-keyword">goto</span> bus_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">usb_bus_type</span> =</span> &#123;<br>.name =<span class="hljs-string">&quot;usb&quot;</span>,<br>.match =usb_device_match,<br>.uevent =usb_uevent,<br>.need_parent_lock =<span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用bus_register接口注册USB总线，会创建出两条链表用来分别存放向USB总线注册的设备和驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);<br>klist_init(&amp;priv-&gt;klist_drivers, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h4 id="注册USB接口驱动"><a href="#注册USB接口驱动" class="headerlink" title="注册USB接口驱动"></a>注册USB接口驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB接口驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register(&amp;usbfs_driver);<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> driver_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usbfs_driver</span> =</span> &#123;<br>    .name =     <span class="hljs-string">&quot;usbfs&quot;</span>,<br>    .probe =    driver_probe,<br>    .disconnect =   driver_disconnect,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="初始化USB-Hub"><a href="#初始化USB-Hub" class="headerlink" title="初始化USB Hub"></a>初始化USB Hub</h4><p>初始化一个USB设备集线器，用来检测USB设备的连接和断开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = usb_hub_init();<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> hub_init_failed;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_hub_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 在usb总线注册一个hub驱动，该驱动被放在usb总线的驱动链表中。</span><br><span class="hljs-keyword">if</span> (usb_register(&amp;hub_driver) &lt; <span class="hljs-number">0</span>) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;%s: can&#x27;t register hub driver\n&quot;</span>,<br>usbcore_name);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The workqueue needs to be freezable to avoid interfering with</span><br><span class="hljs-comment"> * USB-PERSIST port handover. Otherwise it might see that a full-speed</span><br><span class="hljs-comment"> * device was gone before the EHCI controller had handed its port</span><br><span class="hljs-comment"> * over to the companion full-speed controller.</span><br><span class="hljs-comment"> * 工作队列需要可冻结以避免干扰 USB-PERSIST 端口切换。 </span><br><span class="hljs-comment"> * 否则，在 EHCI 控制器将其端口移交给配套的全速控制器之前，它可能会发现全速设备已消失。</span><br><span class="hljs-comment"> */</span><br>hub_wq = alloc_workqueue(<span class="hljs-string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (hub_wq)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Fall through if kernel_thread failed */</span><br>usb_deregister(&amp;hub_driver);<br>pr_err(<span class="hljs-string">&quot;%s: can&#x27;t allocate workqueue for usb hub\n&quot;</span>, usbcore_name);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">hub_driver</span> =</span> &#123;<br>.name =<span class="hljs-string">&quot;hub&quot;</span>,<br>.probe =hub_probe,<br>.disconnect =hub_disconnect,<br>.suspend =hub_suspend,<br>.resume =hub_resume,<br>.reset_resume =hub_reset_resume,<br>.pre_reset =hub_pre_reset,<br>.post_reset =hub_post_reset,<br>.unlocked_ioctl = hub_ioctl,<br>.id_table =hub_id_table,<br>.supports_autosuspend =<span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="注册USB设备驱动"><a href="#注册USB设备驱动" class="headerlink" title="注册USB设备驱动"></a>注册USB设备驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB设备驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<br><span class="hljs-keyword">if</span> (!retval)<br>    <span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_driver</span> <span class="hljs-title">usb_generic_driver</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;usb&quot;</span>,<br>    .probe = generic_probe,<br>    .disconnect = generic_disconnect,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  CONFIG_PM</span><br>    .suspend = generic_suspend,<br>    .resume = generic_resume,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    .supports_autosuspend = <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="usb-register-和-usb-register-device-driver"><a href="#usb-register-和-usb-register-device-driver" class="headerlink" title="usb_register 和 usb_register_device_driver"></a>usb_register 和 usb_register_device_driver</h3><p>usb_register 注册一个USB接口驱动，一个设备可以有多个接口，一个接口表示一种功能。比如USB声卡设备，有两个接口，一个播放接口，一个录音接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_register(driver) \</span><br><span class="hljs-meta">usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_driver - register a USB interface driver</span><br><span class="hljs-comment"> * @new_driver: USB operations for the interface driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> * @mod_name: module name string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB interface driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached interfaces will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized interfaces.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> if you want your driver to use the USB major number, you must call</span><br><span class="hljs-comment"> * usb_register_dev() to enable that functionality.  This function no longer</span><br><span class="hljs-comment"> * takes care of that.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_driver *new_driver, <span class="hljs-keyword">struct</span> module *owner,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>new_driver-&gt;drvwrap.for_devices = <span class="hljs-number">0</span>;<br>new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;<br>new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb接口“设备”被匹配时，首先会调用usb_probe_interface，然后在该接口中调用driver的probe</span><br>new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;<br>new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;<br>new_driver-&gt;drvwrap.driver.owner = owner;<br>new_driver-&gt;drvwrap.driver.mod_name = mod_name;<br>new_driver-&gt;drvwrap.driver.dev_groups = new_driver-&gt;dev_groups;<br>spin_lock_init(&amp;new_driver-&gt;dynids.lock);<br>INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="hljs-built_in">list</span>);<br><br>retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><br>retval = usb_create_newid_files(new_driver);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out_newid;<br><br>pr_info(<span class="hljs-string">&quot;%s: registered new interface driver %s\n&quot;</span>,<br>usbcore_name, new_driver-&gt;name);<br><br>out:<br><span class="hljs-keyword">return</span> retval;<br><br>out_newid:<br>driver_unregister(&amp;new_driver-&gt;drvwrap.driver);<br><br>pr_err(<span class="hljs-string">&quot;%s: error %d registering interface driver %s\n&quot;</span>,<br>usbcore_name, retval, new_driver-&gt;name);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_driver);<br></code></pre></td></tr></table></figure><p>usb_register_device_driver 注册一个通用USB设备驱动，而不是USB接口驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_device_driver - register a USB device (not interface) driver</span><br><span class="hljs-comment"> * @new_udriver: USB operations for the device driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB device driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached devices will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized devices.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_device_driver *new_udriver,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> module *owner)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>new_udriver-&gt;drvwrap.for_devices = <span class="hljs-number">1</span>;<br>new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;<br>new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb设备被匹配时，首先会调用usb_probe_device，然后在该接口中调用driver的probe</span><br>new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;<br>new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;<br>new_udriver-&gt;drvwrap.driver.owner = owner;<br>new_udriver-&gt;drvwrap.driver.dev_groups = new_udriver-&gt;dev_groups;<br><br>retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);<br><br><span class="hljs-keyword">if</span> (!retval) &#123;<br>pr_info(<span class="hljs-string">&quot;%s: registered new device driver %s\n&quot;</span>,<br>usbcore_name, new_udriver-&gt;name);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check whether any device could be better served with</span><br><span class="hljs-comment"> * this new driver</span><br><span class="hljs-comment"> */</span><br>bus_for_each_dev(&amp;usb_bus_type, <span class="hljs-literal">NULL</span>, new_udriver,<br> __usb_bus_reprobe_drivers);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pr_err(<span class="hljs-string">&quot;%s: error %d registering device driver %s\n&quot;</span>,<br>usbcore_name, retval, new_udriver-&gt;name);<br>&#125;<br><br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_device_driver);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>USB core注册了一个USB总线，并向USB总线中注册了三个驱动，分别是USB接口驱动、HUB驱动、USB设备驱动。其中在注册HUB驱动前创建了一个hub_thread线程，用来处理hub上USB设备事件，比如插入和拔出；在HUB驱动的probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件。</p><h2 id="USB主机控制器驱动（HCD）"><a href="#USB主机控制器驱动（HCD）" class="headerlink" title="USB主机控制器驱动（HCD）"></a>USB主机控制器驱动（HCD）</h2><p>USB HCD注册在平台总线上。用来处理主机控制器的初始化以及数据的传输，并监测外部设备插入、拔出，完成设备枚举。</p><h3 id="USB主机控制器-设备"><a href="#USB主机控制器-设备" class="headerlink" title="USB主机控制器-设备"></a>USB主机控制器-设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//5.10/arch/arm/mach-s3c/mach-smdk2440.c</span><br>MACHINE_START(S3C2440, <span class="hljs-string">&quot;SMDK2440&quot;</span>)<br><span class="hljs-comment">/* Maintainer: Ben Dooks &lt;ben-linux@fluff.org&gt; */</span><br>.atag_offset= <span class="hljs-number">0x100</span>,<br><br>.init_irq= s3c2440_init_irq,<br>.map_io= smdk2440_map_io,<br>.init_machine= smdk2440_machine_init,<br>.init_time= smdk2440_init_time,<br>MACHINE_END<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init smdk2440_machine_init(<span class="hljs-type">void</span>)<br>&#123;<br>s3c24xx_fb_set_platdata(&amp;smdk2440_fb_info);<br>s3c_i2c0_set_platdata(<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">/* Configure the I2S pins (GPE0...GPE4) in correct mode */</span><br>s3c_gpio_cfgall_range(S3C2410_GPE(<span class="hljs-number">0</span>), <span class="hljs-number">5</span>, S3C_GPIO_SFN(<span class="hljs-number">2</span>),<br>      S3C_GPIO_PULL_NONE);<br>platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));<br>smdk_machine_init();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<br>&amp;s3c_device_ohci,<br>&amp;s3c_device_lcd,<br>&amp;s3c_device_wdt,<br>&amp;s3c_device_i2c0,<br>&amp;s3c_device_iis,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.id= <span class="hljs-number">-1</span>,<br>.num_resources= ARRAY_SIZE(s3c_usb_resource),<br>.resource= s3c_usb_resource,<br>.dev= &#123;<br>.dma_mask= &amp;samsung_device_dma_mask,<br>.coherent_dma_mask= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器-驱动"><a href="#USB主机控制器-驱动" class="headerlink" title="USB主机控制器-驱动"></a>USB主机控制器-驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// linux-2.6.22.6/drivers/usb/host/ohci-hcd.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_S3C2410</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ohci-s3c2410.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLATFORM_DRIVER     ohci_hcd_s3c2410_driver</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ohci_hcd_mod_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>printk(KERN_INFO <span class="hljs-string">&quot;%s: &quot;</span> DRIVER_DESC <span class="hljs-string">&quot;\n&quot;</span>, hcd_name);<br>pr_debug (<span class="hljs-string">&quot;%s: block sizes: ed %zd td %zd\n&quot;</span>, hcd_name,<br><span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> ed), <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> td));<br>set_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br><br>ohci_debug_root = debugfs_create_dir(<span class="hljs-string">&quot;ohci&quot;</span>, usb_debug_root);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>retval = ps3_ohci_driver_register(&amp;PS3_SYSTEM_BUS_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_ps3;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>retval = platform_driver_register(&amp;OF_PLATFORM_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_of_platform;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>retval = sa1111_driver_register(&amp;SA1111_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_sa1111;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>retval = platform_driver_register(&amp;SM501_OHCI_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_sm501;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>retval = platform_driver_register(&amp;TMIO_OHCI_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_tmio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> retval;<br><br><span class="hljs-comment">/* Error path */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>platform_driver_unregister(&amp;TMIO_OHCI_DRIVER);<br> error_tmio:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>platform_driver_unregister(&amp;SM501_OHCI_DRIVER);<br> error_sm501:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>sa1111_driver_unregister(&amp;SA1111_DRIVER);<br> error_sa1111:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>platform_driver_unregister(&amp;OF_PLATFORM_DRIVER);<br> error_of_platform:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>ps3_ohci_driver_unregister(&amp;PS3_SYSTEM_BUS_DRIVER);<br> error_ps3:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>debugfs_remove(ohci_debug_root);<br>ohci_debug_root = <span class="hljs-literal">NULL</span>;<br><br>clear_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>module_init(ohci_hcd_mod_init);<br><br><span class="hljs-comment">// drivers/usb/host/ohci-s3c2410.c</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>.probe= ohci_hcd_s3c2410_probe,<br>.remove= ohci_hcd_s3c2410_remove,<br>.shutdown= usb_hcd_platform_shutdown,<br>.driver= &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.pm= &amp;ohci_hcd_s3c2410_pm_ops,<br>.of_match_table= ohci_hcd_s3c2410_dt_ids,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器设备和驱动的匹配"><a href="#USB主机控制器设备和驱动的匹配" class="headerlink" title="USB主机控制器设备和驱动的匹配"></a>USB主机控制器设备和驱动的匹配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_driver_register-&gt;<br>    driver_register-&gt;<br>        bus_add_driver-&gt;<br>            driver_attach-&gt;<br>                bus_for_each_dev-&gt; <span class="hljs-comment">// 从平台总线的的设备链表中，取出每一项设备进行匹配</span><br>                    __driver_attach-&gt;<br>                        driver_probe_device-&gt;<br>                            <span class="hljs-comment">// 此总线类型为平台总线，其存在match函数，即调用platform_match进行匹配</span><br>                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))                            <br><br><span class="hljs-comment">// 平台总线                            </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;platform&quot;</span>,<br>.dev_groups= platform_dev_groups,<br>.match= platform_match,<br>.uevent= platform_uevent,<br>.dma_configure= platform_dma_configure,<br>.pm= &amp;platform_dev_pm_ops,<br>&#125;;<br>EXPORT_SYMBOL_GPL(platform_bus_type);             <br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);<br><br><span class="hljs-comment">/* When driver_override is set, only bind to the matching driver */</span><br><span class="hljs-keyword">if</span> (pdev-&gt;driver_override)<br><span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);<br><br><span class="hljs-comment">/* Attempt an OF style match first */</span><br><span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* Then try ACPI style match */</span><br><span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* Then try to match against the id table */</span><br><span class="hljs-keyword">if</span> (pdrv-&gt;id_table)<br><span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* fall-back to driver name match */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// ohci 设备   name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.id= <span class="hljs-number">-1</span>,<br>.num_resources= ARRAY_SIZE(s3c_usb_resource),<br>.resource= s3c_usb_resource,<br>.dev= &#123;<br>.dma_mask= &amp;samsung_device_dma_mask,<br>.coherent_dma_mask= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// ohci 驱动 name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>.probe= ohci_hcd_s3c2410_probe,<br>.remove= ohci_hcd_s3c2410_remove,<br>.shutdown= usb_hcd_platform_shutdown,<br>.driver= &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.pm= &amp;ohci_hcd_s3c2410_pm_ops,<br>.of_match_table= ohci_hcd_s3c2410_dt_ids,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>匹配成功调用驱动的probe函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>    really_probe-&gt;<br>        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器驱动的probe函数"><a href="#USB主机控制器驱动的probe函数" class="headerlink" title="USB主机控制器驱动的probe函数"></a>USB主机控制器驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ohci_hcd_s3c2410_drv_probe -&gt; <br>    usb_hcd_s3c2410_probe -&gt;<br>        usb_add_hcd -&gt; <br>            rhdev = usb_alloc_dev<br>            hcd-&gt;self.root_hub = rhdev<br>            register_root_hub -&gt; <br>                usb_new_device -&gt;<br>                    device_add -&gt;     <br>                        bus_attach_device -&gt;<br>                            device_attach -&gt; <br>                                bus_for_each_drv -&gt; <span class="hljs-comment">// 从usb总线的的驱动链表中，取出每一项驱动进行匹配</span><br>                                    __device_attach -&gt;<br>                                        driver_probe_device -&gt;<br>                                            <span class="hljs-comment">// 此总线类型为USB总线，其存在match函数，即调用usb_device_match进行匹配</span><br>                                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv)) <br>                                                driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>                                                    really_probe-&gt;<br>                                                        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure><h3 id="usb-device-match"><a href="#usb-device-match" class="headerlink" title="usb_device_match"></a>usb_device_match</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> dev-&gt;type == &amp;usb_device_type;<br>&#125;<br><br><span class="hljs-comment">/* Do the same for device drivers and interface drivers. */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// struct device_driver 中 struct usbdrv_wrap 中的for_devices变量为1，则为USB设备驱动</span><br>    <span class="hljs-comment">// 上节USB Core中向USB总线注册的USB设备驱动中有将该变量设置为1（new_udriver-&gt;drvwrap.for_devices = 1;）</span><br>    <span class="hljs-keyword">return</span> container_of(drv, <span class="hljs-keyword">struct</span> usbdrv_wrap, driver)-&gt;<br>            for_devices;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// USB设备 和 USB接口“设备”分开处理 </span><br>    <span class="hljs-comment">/* devices and interfaces are handled separately */</span><br>    <span class="hljs-keyword">if</span> (is_usb_device(dev)) &#123;<br>        <span class="hljs-comment">// 处理USB设备</span><br>        <span class="hljs-comment">/* interface drivers never match devices */</span><br>        <span class="hljs-keyword">if</span> (!is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Add real matching code */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理USB接口设备</span><br>        <span class="hljs-keyword">struct</span> usb_interface *intf;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> *<span class="hljs-title">usb_drv</span>;</span><br>        <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> *<span class="hljs-title">id</span>;</span><br><br>        <span class="hljs-comment">/* device drivers never match interfaces */</span><br>        <span class="hljs-keyword">if</span> (is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        intf = to_usb_interface(dev);<br>        usb_drv = to_usb_driver(drv);<br><br>        id = usb_match_id(intf, usb_drv-&gt;id_table);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        id = usb_match_dynamic_id(intf, usb_drv);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>probe 向USB总线注册一个root hub 设备，从usb总线的的驱动链表中，取出每一项驱动进行匹配。在USB Core中已经向总线注册了三个驱动（USB设备驱动、USB接口驱动、USB hub驱动），根据条件匹配到USB设备驱动，则去调用USB设备驱动的probe函数。</p><h3 id="USB设备驱动的probe函数"><a href="#USB设备驱动的probe函数" class="headerlink" title="USB设备驱动的probe函数"></a>USB设备驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">generic_probe(<span class="hljs-keyword">struct</span> usb_device *udev) -&gt; <span class="hljs-comment">// 从上分析流程知udev为USB root hub设备 </span><br>    usb_set_configuration -&gt;<br>        device_add -&gt;  <span class="hljs-comment">// 创建USB接口设备，USB root hub接口设备被创建</span><br></code></pre></td></tr></table></figure><p>之后匹配到USB Core中注册的USB hub驱动，执行USB hub驱动的probe函数，该probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件（插入、拔出）。至此，系统启动初始化时关于USB的内容分析完成。USB Core和USB HCD的成功建立联系，为之后的USB设备驱动提供API。</p><h2 id="USB设备驱动-–USB鼠标"><a href="#USB设备驱动-–USB鼠标" class="headerlink" title="USB设备驱动 –USB鼠标"></a>USB设备驱动 –USB鼠标</h2><p>用于和枚举到的USB设备进行绑定，完成特定的功能。 比如USB鼠标设备，驱动开发主要是这一块代码的coding。</p><h3 id="注册一个USB接口驱动"><a href="#注册一个USB接口驱动" class="headerlink" title="注册一个USB接口驱动"></a>注册一个USB接口驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usb_mouse_driver</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;usbmouse&quot;</span>,<br>.probe= usb_mouse_probe,<br>.disconnect= usb_mouse_disconnect,<br>.id_table= usb_mouse_id_table,<br>&#125;;<br><br>module_usb_driver(usb_mouse_driver);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * module_usb_driver() - Helper macro for registering a USB driver</span><br><span class="hljs-comment"> * @__usb_driver: usb_driver struct</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Helper macro for USB drivers which do not do anything special in module</span><br><span class="hljs-comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span><br><span class="hljs-comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> module_usb_driver(__usb_driver) \</span><br><span class="hljs-meta">module_driver(__usb_driver, usb_register, \</span><br><span class="hljs-meta">       usb_deregister)</span><br></code></pre></td></tr></table></figure><h3 id="USB接口设备的创建"><a href="#USB接口设备的创建" class="headerlink" title="USB接口设备的创建"></a>USB接口设备的创建</h3><p>当一个USB 鼠标设备插入后，主机USB控制器检测到后，触发USB设备集线器中的”中断”处理函数hub_irq。在hub_irq中会获取USB鼠标设备的设备描述符，根据设备描述符创建USB接口设备，从而和这边的USB接口驱动匹配，调用其probe函数，通过USB总线驱动程序（USB Core和USB HCD）和USB鼠标设备建立联系，进而操作（读写控制）该设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">hub_irq<br>    kick_khubd <span class="hljs-comment">// 唤醒hub_thread线程</span><br>        hub_thread<br>            hub_events <span class="hljs-comment">// 处理USB设备插入事件</span><br>                hub_port_connect_change<br><br>                    udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);<br>                                dev-&gt;dev.bus = &amp;usb_bus_type;<br><br>                    choose_address(udev); <span class="hljs-comment">// 给新设备分配编号(地址)                                       </span><br>                    hub_port_init   <span class="hljs-comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 3</span><br><br>                        hub_set_address  <span class="hljs-comment">// 把编号(地址)告诉USB设备</span><br><br>                        usb_get_device_descriptor(udev, <span class="hljs-number">8</span>); <span class="hljs-comment">// 获取设备描述符</span><br>                        retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);<br><br>                        usb_new_device(udev)   <br>                            err = usb_get_configuration(udev); <span class="hljs-comment">// 把所有的描述符都读出来，并解析</span><br>                            usb_parse_configuration<br><br>                            device_add  <span class="hljs-comment">// 把device放入usb_bus_type的dev链表, </span><br>                                        <span class="hljs-comment">// 从usb_bus_type的driver链表里取出usb_driver，</span><br>                                        <span class="hljs-comment">// 把usb_interface和usb_driver的id_table比较</span><br>                                        <span class="hljs-comment">// 如果能匹配，调用usb_driver的probe</span><br></code></pre></td></tr></table></figure><h3 id="USB接口驱动和USB接口设备的匹配"><a href="#USB接口驱动和USB接口设备的匹配" class="headerlink" title="USB接口驱动和USB接口设备的匹配"></a>USB接口驱动和USB接口设备的匹配</h3><p>USB设备插入后根据获取到的设备描述符所创建的USB 接口设备和开发的USB接口驱动匹配： 对于设备： 将获取到的USB设备描述符信息保存在其id_table中。 对于驱动： 驱动的id_table中存放期望该驱动适用的USB设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> <span class="hljs-title">usb_mouse_id_table</span>[] =</span> &#123;<br>&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,<br>USB_INTERFACE_PROTOCOL_MOUSE) &#125;,<br>&#123; &#125;<span class="hljs-comment">/* Terminating entry */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>匹配成功后调用该驱动的probe函数，具体的过程和前面分析的差不多。接下来就是在probe函数中，和USB总线驱动程序建立联系，以达到操作USB 鼠标设备的目的。</p><h3 id="创建数据传输管道"><a href="#创建数据传输管道" class="headerlink" title="创建数据传输管道"></a>创建数据传输管道</h3><p>根据数据传输类型，有几个接口可供调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create various pipes... */</span><br><span class="hljs-comment">// 控制传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndctrlpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvctrlpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 实时传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndisocpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvisocpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 批量传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndbulkpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvbulkpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 中断传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndintpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvintpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br></code></pre></td></tr></table></figure><p>对于USB 鼠标设备，使用中断传输方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">dev</span> =</span> interface_to_usbdev(intf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">interface</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> *<span class="hljs-title">endpoint</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input_dev</span>;</span><br><span class="hljs-type">int</span> pipe, maxp;<br><span class="hljs-type">int</span> error = -ENOMEM;<br><br>interface = intf-&gt;cur_altsetting;<br><br><span class="hljs-keyword">if</span> (interface-&gt;desc.bNumEndpoints != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>endpoint = &amp;interface-&gt;endpoint[<span class="hljs-number">0</span>].desc;<br><span class="hljs-keyword">if</span> (!usb_endpoint_is_int_in(endpoint))<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 端点是USB设备数据传输对象</span><br>pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);<br>maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));<br></code></pre></td></tr></table></figure><h3 id="分配urb"><a href="#分配urb" class="headerlink" title="分配urb"></a>分配urb</h3><p>urb（USB Request Block）是Linux内核中USB驱动实现上的一个数据结构，用于组织每一次的USB设备驱动的数据传输请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mouse-&gt;irq = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!mouse-&gt;irq)<br><span class="hljs-keyword">goto</span> fail2;<br></code></pre></td></tr></table></figure><h3 id="urb数据结构初始化"><a href="#urb数据结构初始化" class="headerlink" title="urb数据结构初始化"></a>urb数据结构初始化</h3><p>根据传输类型，有几个接口可供调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 控制</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_control_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *setup_packet,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params"><span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params"><span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *context)</span><br><span class="hljs-comment">// 批量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_bulk_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">     <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">     <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">     <span class="hljs-type">void</span> *context)</span><br><br><span class="hljs-comment">// 中断</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_int_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">    <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *context,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> interval)</span><br><span class="hljs-comment">// 实时   </span><br><span class="hljs-comment">// 实时urb 没有和中断、控制、批量urb 类似的初始化函数，因此它们在提交到USB核心之前，需要在驱动程序中手动的初始化</span><br></code></pre></td></tr></table></figure><p>对于USB鼠标设备，采用中断传输方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,<br> (maxp &gt; <span class="hljs-number">8</span> ? <span class="hljs-number">8</span> : maxp),<br> usb_mouse_irq, mouse, endpoint-&gt;bInterval);<br>mouse-&gt;irq-&gt;transfer_dma = mouse-&gt;data_dma;<br>mouse-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br></code></pre></td></tr></table></figure><h3 id="提交USB请求块"><a href="#提交USB请求块" class="headerlink" title="提交USB请求块"></a>提交USB请求块</h3><p>调用usb_submit_urb接口以获取USB设备数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_mouse_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span> =</span> input_get_drvdata(dev);<br><br>mouse-&gt;irq-&gt;dev = mouse-&gt;usbdev;<br><span class="hljs-keyword">if</span> (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))<br><span class="hljs-keyword">return</span> -EIO;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>USB驱动开发，针对某一个USB设备的某个功能（接口）构建的驱动程序。USB驱动并不直接和USB设备进行数据交互，而是通过USB总线驱动程序（USB Core和USB HCD）来操作USB设备的。一般构建USB设备驱动的流程为：</p><ul><li>根据期望适用的USB设备信息构建一个id_table。</li><li>根据需要的数据传输类型，调用相应的接口创建数据传输管道。</li><li>分配一个urb(USB请求块)。</li><li>根据需要的数据传输类型，调用相应的接口进行urb数据结构初始化。</li><li>提交urb</li></ul>]]></content>
    
    
    <categories>
      
      <category>USB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>crash</title>
    <link href="/dbg_meth/crash/"/>
    <url>/dbg_meth/crash/</url>
    
    <content type="html"><![CDATA[<h1 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h1><p>一个用于分析 Linux 内核转储文件的工具。它提供了一个交互式的环境，让用户能够检查内核转储文件中的信息，包括进程栈、内核数据结构等</p><h3 id="进入crash环境"><a href="#进入crash环境" class="headerlink" title="进入crash环境"></a>进入crash环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -s<br>crash /lib/debug/vmlinux<br></code></pre></td></tr></table></figure><h3 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h3><p>backtrace打印内核栈回溯信息，bt pid 打印指定进程栈信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; bt 1942<br>PID: 1942   TASK: ffff88068c957300  CPU: 2   COMMAND: <span class="hljs-string">&quot;bash&quot;</span><br> <span class="hljs-comment">#0 [ffff88062b8f7b48] machine_kexec at ffffffff81051e9b</span><br> <span class="hljs-comment">#1 [ffff88062b8f7ba8] crash_kexec at ffffffff810f27e2</span><br> <span class="hljs-comment">#2 [ffff88062b8f7c78] oops_end at ffffffff81689948</span><br> <span class="hljs-comment">#3 [ffff88062b8f7ca0] no_context at ffffffff816793f1</span><br> <span class="hljs-comment">#4 [ffff88062b8f7cf0] __bad_area_nosemaphore at ffffffff81679487</span><br> <span class="hljs-comment">#5 [ffff88062b8f7d38] bad_area_nosemaphore at ffffffff816795f1</span><br> <span class="hljs-comment">#6 [ffff88062b8f7d48] __do_page_fault at ffffffff8168c6ce</span><br> <span class="hljs-comment">#7 [ffff88062b8f7da8] do_page_fault at ffffffff8168c863</span><br> <span class="hljs-comment">#8 [ffff88062b8f7dd0] page_fault at ffffffff81688b48</span><br>    [exception RIP: sysrq_handle_crash+22]<br>    RIP: ffffffff813baf16  RSP: ffff88062b8f7e80  RFLAGS: 00010046<br>    RAX: 000000000000000f  RBX: ffffffff81a7b180  RCX: 0000000000000000<br>    RDX: 0000000000000000  RSI: ffff88086ec8f6c8  RDI: 0000000000000063<br>    RBP: ffff88062b8f7e80   R8: 0000000000000092   R9: 0000000000000e37<br>    R10: 0000000000000e36  R11: 0000000000000003  R12: 0000000000000063<br>    R13: 0000000000000246  R14: 0000000000000004  R15: 0000000000000000<br>    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018<br> <span class="hljs-comment">#9 [ffff88062b8f7e88] __handle_sysrq at ffffffff813bb6d2</span><br><span class="hljs-comment">#10 [ffff88062b8f7ec0] write_sysrq_trigger at ffffffff813bbbaf</span><br><span class="hljs-comment">#11 [ffff88062b8f7ed8] proc_reg_write at ffffffff812494bd</span><br><span class="hljs-comment">#12 [ffff88062b8f7ef8] vfs_write at ffffffff811dee9d</span><br><span class="hljs-comment">#13 [ffff88062b8f7f38] sys_write at ffffffff811df93f</span><br><span class="hljs-comment">#14 [ffff88062b8f7f80] system_call_fastpath at ffffffff81691049</span><br>    RIP: 00007fb320bcb500  RSP: 00007ffde533c198  RFLAGS: 00000246<br>    RAX: 0000000000000001  RBX: ffffffff81691049  RCX: ffffffffffffffff<br>    RDX: 0000000000000002  RSI: 00007fb3214eb000  RDI: 0000000000000001<br>    RBP: 00007fb3214eb000   R8: 000000000000000a   R9: 00007fb3214d5740<br>    R10: 0000000000000001  R11: 0000000000000246  R12: 0000000000000001<br>    R13: 0000000000000002  R14: 00007fb320e9f400  R15: 0000000000000002<br>    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b<br></code></pre></td></tr></table></figure><p>解析：</p><p>可以看到最后几步触发了缺页异常，进入crash_kexec的流程，最后调用 machine_kexec()。这通常是一个硬件相关的函数。它会引导启动捕获内核，从而完成 kdump 的过程。<br>代码就是走到了sysrq_handle_crash函数首地址+0x22这段命令的时候，触发的缺页异常。</p><p>注意：</p><p>这里，对应x86-64汇编，应用层下来的系统调用对应的6个参数存放的寄存器依次对应：rdi、rsi、rdx、rcx、r8、r9。对于多于6个参数的，仍存储在栈上。</p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>打印vmcore所在的系统内核dmesg日志信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; <span class="hljs-built_in">log</span><br>[    0.000000] Linux version 4.19.0-amd64-desktop (uos@x86-compile-PC) (gcc version 8.3.0 (Uos 8.3.0.5-1+dde)) (c42ec32bb9fc) <span class="hljs-comment">#6300 SMP Fri Dec 15 13:53:22 CST 2023</span><br>[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.19.0-amd64-desktop root=UUID=826567d9-9352-4ab2-a268-e23345c606df ro video=efifb:nobgrt splash quiet DEEPIN_GFXMODE= ima_appraise=off libahci.ignore_sss=1<br>[    0.000000] KERNEL supported cpus:<br>[    0.000000]   Intel GenuineIntel<br>[    0.000000]   AMD AuthenticAMD<br>[    0.000000]   Hygon HygonGenuine<br>[    0.000000]   Centaur CentaurHauls<br>[    0.000000]   zhaoxin   Shanghai  <br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: <span class="hljs-string">&#x27;x87 floating point registers&#x27;</span><br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x002: <span class="hljs-string">&#x27;SSE registers&#x27;</span><br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x004: <span class="hljs-string">&#x27;AVX registers&#x27;</span><br>[    0.000000] x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256<br>[    0.000000] x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using <span class="hljs-string">&#x27;compacted&#x27;</span> format.<br>[    0.000000] BIOS-provided physical RAM map:<br>[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x0000000000086fff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000000087000-0x0000000000087fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000000088000-0x000000000009ffff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000000a0000-0x00000000000bffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x0000000009afffff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000009b00000-0x0000000009dfffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000009e00000-0x0000000009efffff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000009f00000-0x0000000009f0afff] ACPI NVS<br>[    0.000000] BIOS-e820: [mem 0x0000000009f0b000-0x00000000970f8fff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000970f9000-0x0000000097af8fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000097af9000-0x00000000add0efff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000add0f000-0x00000000aee8efff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000aee8f000-0x00000000af77efff] ACPI NVS<br>[    0.000000] BIOS-e820: [mem 0x00000000af77f000-0x00000000af7fefff] ACPI data<br>[    0.000000] BIOS-e820: [mem 0x00000000af7ff000-0x00000000af7fffff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000af800000-0x00000000afffffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000f8000000-0x00000000fbffffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fdc00000-0x00000000fec00fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fec10000-0x00000000fec10fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fed80000-0x00000000fed80fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000ff800000-0x00000000fff3ffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000040effffff] usable<br>[    0.000000] BIOS-e820: [mem 0x000000040f000000-0x000000044effffff] reserved<br>[    0.000000] NX (Execute Disable) protection: active<br>[    0.000000] e820: update [mem 0x94db8018-0x94dc5457] usable ==&gt; usable<br>[    0.000000] e820: update [mem 0x94db8018-0x94dc5457] usable ==&gt; usable<br>[    0.000000] extended physical RAM map:<br></code></pre></td></tr></table></figure><h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><p><code>dis -l (function+offset) 10</code> 反汇编出指令所在代码，10代表打印该指定位置开始的10行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; dis -l do_sys_poll 10<br>/home/uos/code/workspace/kernel/gerrit-V20-kernel-pipeline/x86-kernel/fs/select.c: 928<br>0xffffffff8f681540 &lt;do_sys_poll&gt;:       nopl   0x0(%rax,%rax,1) [FTRACE NOP]<br>0xffffffff8f681545 &lt;do_sys_poll+5&gt;:     push   %rbp<br>0xffffffff8f681546 &lt;do_sys_poll+6&gt;:     mov    %rsp,%rbp<br>0xffffffff8f681549 &lt;do_sys_poll+9&gt;:     push   %r15<br>0xffffffff8f68154b &lt;do_sys_poll+11&gt;:    push   %r14<br>0xffffffff8f68154d &lt;do_sys_poll+13&gt;:    push   %r13<br>0xffffffff8f68154f &lt;do_sys_poll+15&gt;:    mov    %esi,%r13d<br>0xffffffff8f681552 &lt;do_sys_poll+18&gt;:    push   %r12<br>0xffffffff8f681554 &lt;do_sys_poll+20&gt;:    push   %rbx<br>0xffffffff8f681555 &lt;do_sys_poll+21&gt;:    and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br></code></pre></td></tr></table></figure><h3 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h3><p>mod 查看当时内核加载的所有内核模块信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; mod<br>     MODULE       NAME                 SIZE    OBJECT        FILE<br>ffffffffc01ee200  button               20480   (not loaded)  [CONFIG_KALLSYMS]<br>ffffffffc0211f00  hid                  139264  (not loaded)  [CONFIG_KALLSYMS]<br>ffffffffc021a0c0  ecb                  16384   (not loaded)  [CONFIG_KALLSYMS]<br></code></pre></td></tr></table></figure><h3 id="sym"><a href="#sym" class="headerlink" title="sym"></a>sym</h3><p><code>sym 00007fb320bcb500 (内存地址)</code>   转换指定符号为其虚拟地址，显示系统中对应的符号表信息，并且具体到源代码的那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; sym ffffffffc07c5024<br>ffffffffc07c5024 (t) my_openat+36 [my_test_lkm] /mnt/hgfs/test_ko/lkm-test05/my_lkm.c: 25<br></code></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps 打印内核崩溃时，正常的进程信息</p><p>带 &gt; 标识代表是活跃的进程，ps pid打印某指定进程的状态信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; ps 27005<br>   PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM<br>&gt; 27005   7783   1  ffff997b388ae180  RU   0.2   91732   4124  pickup<br>&gt; <br>查看指定进程的进程树，显示进程父子关系（ps -p pid） <br>crash&gt; ps -p 85151<br>PID: 0      TASK: ffffffff818b6420  CPU: 0   COMMAND: <span class="hljs-string">&quot;swapper/0&quot;</span><br> PID: 1      TASK: ffff881f91dae040  CPU: 28  COMMAND: <span class="hljs-string">&quot;init&quot;</span><br>  PID: 14544  TASK: ffff881f8d7b05c0  CPU: 11  COMMAND: <span class="hljs-string">&quot;init.tfa&quot;</span><br>   PID: 85138  TASK: ffff880bab01a400  CPU: 8   COMMAND: <span class="hljs-string">&quot;tfactl&quot;</span><br>    PID: 85151  TASK: ffff880b7a728380  CPU: 17  COMMAND: <span class="hljs-string">&quot;perl&quot;</span><br>ps -t [pid]: 显示进程运行时间<br></code></pre></td></tr></table></figure><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>files pid 打印指定进程所打开的文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; files 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>ROOT: /    CWD: /<br> FD       FILE            DENTRY           INODE       TYPE PATH<br>  0 ffff8bac747f8900 ffff8bac7f00a000 ffff8bac7d02bad0 CHR  /dev/null<br>  1 ffff8bac747f9e00 ffff8bac7a23cd80 ffff8bac7abb5570 SOCK UNIX<br>  2 ffff8bac747f9e00 ffff8bac7a23cd80 ffff8bac7abb5570 SOCK UNIX<br>  3 ffff8bac794fdc00 ffff8bac7a0fd980 ffff8bac7ca64000 UNKN [eventfd]<br>  4 ffff8bac794fd700 ffff8bac7a0fc780 ffff8bac7a1771e0 FIFO <br>  5 ffff8bac794fde00 ffff8bac7a0fc780 ffff8bac7a1771e0 FIFO <br>  6 ffff8bac794fd400 ffff8bac66e9ecc0 ffff8bac7a1ec928 REG  /var/var/log/lightdm/lightdm.log<br>  7 ffff8bac794fc700 ffff8bac66e9e000 ffff8bac7ca64000 UNKN [eventfd]<br>  8 ffff8bac74d4d300 ffff8bac7a3ad680 ffff8bac7988d1a8 DIR  /var/var/lib/lightdm/data<br>  9 ffff8bac78f1d700 ffff8bac7a08cb40 ffff8bac7a090b30 SOCK UNIX<br> 10 ffff8bac73e40500 ffff8bac7985aa80 ffff8bac7ca64000 UNKN [eventfd]<br> 11 ffff8bac731c6b00 ffff8bac775a8000 ffff8bac7abfee30 SOCK UNIX<br> 15 ffff8bac74670900 ffff8bac7772e000 ffff8bac7aa704c0 FIFO <br> 16 ffff8bac74670e00 ffff8bac7772ef00 ffff8bac7aa72860 FIFO <br> 22 ffff8bac69130900 ffff8bac7772f500 ffff8bac7aa710a0 FIFO<br></code></pre></td></tr></table></figure><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><p>vm pid 打印某指定进程当时虚拟内存基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; vm 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>       MM               PGD          RSS    TOTAL_VM<br>ffff8bac695bf700  ffff8bac6ce42000  9504k   309268k <br>      VMA           START       END     FLAGS FILE<br>ffff8bac71486a90 563c12926000 563c1292d000 8000871 /usr/sbin/lightdm<br>ffff8bac714872b0 563c1292d000 563c12957000 8000875 /usr/sbin/lightdm<br>ffff8bac71486750 563c12957000 563c1296a000 8000871 /usr/sbin/lightdm<br>ffff8bac71487110 563c1296b000 563c1296c000 8100871 /usr/sbin/lightdm<br>ffff8bac713be340 563c1296c000 563c1296d000 8100873 /usr/sbin/lightdm<br>ffff8bac713be5b0 563c13820000 563c138ae000 8100073 <br>ffff8bac6ce94270 7fa728000000 7fa72802d000 8200073<br></code></pre></td></tr></table></figure><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>task 查看当前进程或指定进程task_struct和thread_info的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; task 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>struct task_struct &#123;<br>  thread_info = &#123;<br>    flags = 0, <br>    status = 0<br>  &#125;, <br>  state = 1, <br>  stack = 0xffffa530038c4000, <br>  usage = &#123;<br>    counter = 2<br>  &#125;, <br>  flags = 4194560, <br>  ptrace = 0, <br>  wake_entry = &#123;<br>    next = 0x0<br>  &#125;, <br>  on_cpu = 0, <br>  cpu = 0, <br>  wakee_flips = 16, <br>  wakee_flip_decay_ts = 4295264801, <br>  last_wakee = 0xffff8bac7d2c1e80, <br>.................<br></code></pre></td></tr></table></figure><h3 id="kmem"><a href="#kmem" class="headerlink" title="kmem"></a>kmem</h3><p><code>kmem -i</code> 查看内存整体使用情况</p><p><code>kmem -s</code>  查看slab使用情况</p><p><code>kmem [addr]</code> 搜索地址所属的内存结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; kmem -i<br>                 PAGES        TOTAL      PERCENTAGE<br>    TOTAL MEM  3847813      14.7 GB         ----<br>         FREE  2437856       9.3 GB   63% of TOTAL MEM<br>         USED  1409957       5.4 GB   36% of TOTAL MEM<br>       SHARED   197787     772.6 MB    5% of TOTAL MEM<br>      BUFFERS    43217     168.8 MB    1% of TOTAL MEM<br>       CACHED   984251       3.8 GB   25% of TOTAL MEM<br>         SLAB    73599     287.5 MB    1% of TOTAL MEM<br><br>   TOTAL HUGE        0            0         ----<br>    HUGE FREE        0            0    0% of TOTAL HUGE<br><br>   TOTAL SWAP  3971839      15.2 GB         ----<br>    SWAP USED        0            0    0% of TOTAL SWAP<br>    SWAP FREE  3971839      15.2 GB  100% of TOTAL SWAP<br><br> COMMIT LIMIT  5895745      22.5 GB         ----<br>    COMMITTED  1660064       6.3 GB   28% of TOTAL LIMIT<br></code></pre></td></tr></table></figure><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct [struct]              //查看结构体成员变量<br>struct -o [struct]           //显示结构体中成员的偏移<br>struct [struct] [address]    //显示对应地址结构体的值<br>[struct] [address]           //简化形式显示对应地址结构体的值<br>[struct] [address] -xo       //打印结构体定义和大小<br>[struct].member[address]     //显示某个成员的值<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct dentry<br>struct dentry &#123;<br>    unsigned int d_flags;<br>    seqcount_t d_seq;<br>    struct hlist_bl_node d_hash;<br>    struct dentry *d_parent;<br>    struct qstr d_name;<br>    struct inode *d_inode;<br>    unsigned char d_iname[32];<br>    struct lockref d_lockref;<br>    const struct dentry_operations *d_op;<br>    struct super_block *d_sb;<br>    unsigned long d_time;<br>    void *d_fsdata;<br>    union &#123;<br>        struct list_head d_lru;<br>        wait_queue_head_t *d_wait;<br>    &#125;;<br>    struct list_head d_child;<br>    struct list_head d_subdirs;<br>    union &#123;<br>        struct hlist_node d_alias;<br>        struct hlist_bl_node d_in_lookup_hash;<br>        struct callback_head d_rcu;<br>    &#125; d_u;<br>&#125;<br>SIZE: 192<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct -o dentry<br>struct dentry &#123;<br>    [0] unsigned int d_flags;<br>    [4] seqcount_t d_seq;<br>    [8] struct hlist_bl_node d_hash;<br>   [24] struct dentry *d_parent;<br>   [32] struct qstr d_name;<br>   [48] struct inode *d_inode;<br>   [56] unsigned char d_iname[32];<br>   [88] struct lockref d_lockref;<br>   [96] const struct dentry_operations *d_op;<br>  [104] struct super_block *d_sb;<br>  [112] unsigned long d_time;<br>  [120] void *d_fsdata;<br>        union &#123;<br>  [128]     struct list_head d_lru;<br>  [128]     wait_queue_head_t *d_wait;<br>        &#125;;<br>  [144] struct list_head d_child;<br>  [160] struct list_head d_subdirs;<br>        union &#123;<br>            struct hlist_node d_alias;<br>            struct hlist_bl_node d_in_lookup_hash;<br>            struct callback_head d_rcu;<br>  [176] &#125; d_u;<br>&#125;<br>SIZE: 192<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct  dentry.d_name<br>struct dentry &#123;<br>   [32] struct qstr d_name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct dentry ffffffff8fbed352<br>struct dentry &#123;<br>  d_flags = 3905390920, <br>  d_seq = &#123;<br>    sequence = 4287371206<br>  &#125;, <br>  d_hash = &#123;<br>    next = 0x9d8bf8349c78949, <br>    pprev = 0x450850f000000<br>  &#125;, <br>  d_parent = 0x334865d0458b4800, <br>  d_name = &#123;<br>    &#123;<br>      &#123;<br>        <span class="hljs-built_in">hash</span> = 2630916, <br>        len = 2232352768<br>      &#125;, <br>      hash_len = 9587882131697706244<br>    &#125;, <br>    name = 0x30c4834800000562 &lt;Address 0x30c4834800000562 out of bounds&gt;<br>  &#125;, <br>  d_inode = 0x415e415d415c415b,<br></code></pre></td></tr></table></figure><p>如果要查看二阶指针的值，可以通过rd命令需要先获取一级指针的值，然后再用struct 结构体名 + addr获取具体的值</p><h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>读取内存内容</p><p><code>rd [addr] [len]</code>                    &#x2F;&#x2F;查看指定地址，长度为len的内存<br><code>rd -S [addr][len]</code>                &#x2F;&#x2F;尝试将地址转换为对应的符号<br><code>rd [addr] -e [addr]</code>            &#x2F;&#x2F;查看指定内存区域内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; rd ffffffff8fbed352 32<br>ffffffff8fbed352:  ff8c17c6e8c78948 09d8bf8349c78949   H.......I..I....<br>ffffffff8fbed362:  000450850f000000 334865d0458b4800   .....P...H.E.eH3<br>ffffffff8fbed372:  850f000000282504 30c4834800000562   .%(.....b...H..0<br>ffffffff8fbed382:  415e415d415c415b 2140c0c748c35d5f   [A\A]A^A_].H..@!<br>ffffffff8fbed392:  1e3c050348650002 00000b8c80837042   ..eH..&lt;.Bp......<br>ffffffff8fbed3a2:  f641fffffd88e901 0f01000007412484   ......A..<span class="hljs-variable">$A</span>.....<br>ffffffff8fbed3b2:  0009bafffffdf785 df8948e6894c0000   ..........L..H..<br>ffffffff8fbed3c2:  44c741ff8c49f9e8 f641000000006c24   ..I..A.D<span class="hljs-variable">$l</span>....A.<br>ffffffff8fbed3d2:  0f02000004c82484 44f6410000032785   .$.......<span class="hljs-string">&#x27;...A.D</span><br><span class="hljs-string">ffffffff8fbed3e2:  fffdcc840f202424 8b495de8e7894cff   $$ ......L...]I.</span><br><span class="hljs-string">ffffffff8fbed3f2:  0fc08548c68949ff 3c408bfffffdb884   .I..H.........@&lt;</span><br><span class="hljs-string">ffffffff8fbed402:  4c00022140c5c749 4890509720c52c03   I..@!..L.,. .P.H</span><br><span class="hljs-string">ffffffff8fbed412:  486500022140c0c7 394970421db80503   ..@!..eH....BpI9</span><br><span class="hljs-string">ffffffff8fbed422:  6500000456850fc5 00015cc025048b48   ...V...eH..%.\..</span><br><span class="hljs-string">ffffffff8fbed432:  00044b840fc63949 0000079c868d4900   I9...K...I......</span><br><span class="hljs-string">ffffffff8fbed442:  e8b8458948c78948 3475c08500005b12   H..H.E...[....u4</span><br></code></pre></td></tr></table></figure><h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><p>p命令可以用来打印出表达式或者变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; p __schedule<br>__schedule = <span class="hljs-variable">$1</span> = <br> &#123;void (bool)&#125; 0xffffffff8fbed0b0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb</title>
    <link href="/dbg_meth/gdb/"/>
    <url>/dbg_meth/gdb/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p><strong>编译程序加参数时生成调试信息</strong></p><p>g 和 -ggdb 都是令 gcc 生成调试信息，但是它们也是有区别的</p><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>g</td><td>该选项可以利用操作系统的“原生格式（native format）”生成调试信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</td></tr><tr><td>ggdb</td><td>使 GCC为GDB 生成专用的更为丰富的调试信息，但是，此时就不能用其他的调试器来进行调试了 (如 ddx)</td></tr></tbody></table><p>g也是分级别的</p><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>g1</td><td>级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储之用。回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段</td></tr><tr><td>g2</td><td>这是默认的级别，此时产生的调试信息包括扩展的符号表、行号、局部或外部变量信息</td></tr><tr><td>g3</td><td>包含级别2中的所有调试信息，以及源代码中定义的宏</td></tr></tbody></table><h2 id="gdb调试常用命令解析"><a href="#gdb调试常用命令解析" class="headerlink" title="gdb调试常用命令解析"></a><strong>gdb调试常用命令解析</strong></h2><h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p>break 断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span> 函数名<br><span class="hljs-built_in">break</span> 行号<br><span class="hljs-built_in">break</span> 文件名：行号<br><span class="hljs-built_in">break</span> 文件名：函数名<br><span class="hljs-built_in">break</span> +偏移量<br><span class="hljs-built_in">break</span> -偏移量<br><span class="hljs-built_in">break</span> *地址<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb)b iseq_compile            在函数处加断点<br>(gdb)b compile.c:516           在文件名和行号处加断点<br>(gdb)b +3                      设置偏移量<br>(gdb)b *0x88116fd6             在某地址处加断点<br>(gdb)b                         如果不指定位置，就是在下一行代码上设置断点<br></code></pre></td></tr></table></figure><p>设置好的断点可以通过 info break 查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info <span class="hljs-built_in">break</span><br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007febd6225bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br></code></pre></td></tr></table></figure><h3 id="disable-enable"><a href="#disable-enable" class="headerlink" title="disable | enable"></a>disable | enable</h3><p>临时禁用和启用断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007f218fcb1bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br>(gdb) disa<br><span class="hljs-built_in">disable</span>      disassemble  <br>(gdb) <span class="hljs-built_in">disable</span> 1<br>(gdb) <span class="hljs-built_in">enable</span> 1<br></code></pre></td></tr></table></figure><h3 id="r"><a href="#r" class="headerlink" title="r"></a>r</h3><p>run 开始运行</p><h3 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h3><p>backtrace 命令可以在遇到断点而停止执行时显示栈帧</p><p><code>bt N</code>只显示开头N个栈帧</p><p><code>bt -N</code>只显示最后N个栈帧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt<br><span class="hljs-comment">#0  0x00007f218fcb1bd9 in __GI___poll (fds=0x7f218400a060, nfds=2, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29</span><br><span class="hljs-comment">#1  0x00007f218ff851f6 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br><span class="hljs-comment">#2  0x00007f218ff85582 in g_main_loop_run () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br><span class="hljs-comment">#3  0x0000563b79c85395 in ?? ()</span><br><span class="hljs-comment">#4  0x00007f218fbe71fb in __libc_start_main (main=0x563b79c84640, argc=1, argv=0x7ffff90918c8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, </span><br>    stack_end=0x7ffff90918b8) at ../csu/libc-start.c:308<br><span class="hljs-comment">#5  0x0000563b79c85ffa in ?? ()</span><br></code></pre></td></tr></table></figure><p><code>bt full</code> 不仅显示backtrace，还显示局部变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt full<br><span class="hljs-comment">#0  0x00007f218fcb1bd9 in __GI___poll (fds=0x7f218400a060, nfds=2, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29</span><br>        resultvar = 18446744073709551100<br>        sc_cancel_oldtype = 0<br>        sc_ret = &lt;optimized out&gt;<br><span class="hljs-comment">#1  0x00007f218ff851f6 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br>No symbol table info available.<br><span class="hljs-comment">#2  0x00007f218ff85582 in g_main_loop_run () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br>No symbol table info available.<br><span class="hljs-comment">#3  0x0000563b79c85395 in ?? ()</span><br>No symbol table info available.<br><span class="hljs-comment">#4  0x00007f218fbe71fb in __libc_start_main (main=0x563b79c84640, argc=1, argv=0x7ffff90918c8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, </span><br>    stack_end=0x7ffff90918b8) at ../csu/libc-start.c:308<br>        self = &lt;optimized out&gt;<br>        result = &lt;optimized out&gt;<br>        unwind_buf = &#123;cancel_jmp_buf = &#123;&#123;jmp_buf = &#123;0, 3044201088132136217, 94813446234064, 140737371510976, 0, 0, 8770247100387114265, 8649937328162159897&#125;, <br>              mask_was_saved = 0&#125;&#125;, priv = &#123;pad = &#123;0x0, 0x0, 0x7ffff90918d8, 0x7f21902b2190&#125;, data = &#123;prev = 0x0, cleanup = 0x0, canceltype = -116844328&#125;&#125;&#125;<br>        not_first_call = &lt;optimized out&gt;<br><span class="hljs-comment">#5  0x0000563b79c85ffa in ?? ()</span><br></code></pre></td></tr></table></figure><h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><p>print，显示变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p result<br><span class="hljs-variable">$1</span> = <span class="hljs-string">&#x27;\000&#x27;</span> &lt;repeats 113 <span class="hljs-built_in">times</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="info-reg"><a href="#info-reg" class="headerlink" title="info reg"></a>info reg</h3><p>显示寄存器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info reg<br>rax            0xfffffffffffffdfc  -516<br>rbx            0x7f218400a060      139781925281888<br>rcx            0x7f218fcb1bd9      139782123101145<br>rdx            0xffffffff          4294967295<br>rsi            0x2                 2<br>rdi            0x7f218400a060      139781925281888<br>rbp            0x2                 0x2<br>rsp            0x7ffff90913e0      0x7ffff90913e0<br>r8             0x0                 0<br>r9             0x1                 1<br></code></pre></td></tr></table></figure><p>在寄存器之前添加 $，即可以显示各个寄存器的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p <span class="hljs-variable">$rip</span><br><span class="hljs-variable">$2</span> = (void (*)()) 0x7f218fcb1bd9 &lt;__GI___poll+73&gt;<br></code></pre></td></tr></table></figure><h3 id="x"><a href="#x" class="headerlink" title="x"></a>x</h3><p>查看内存地址保存的值</p><p><code>(gdb) x/nfu addr</code></p><p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是<br>指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可<br>以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当<br>我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作<br>一个值取出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/3uh 0x54320 //从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。<br></code></pre></td></tr></table></figure><p><code>x/i $rip</code>   显示汇编指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/i <span class="hljs-variable">$rip</span><br>=&gt; 0x7f218fcb1bd9 &lt;__GI___poll+73&gt;:     cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br></code></pre></td></tr></table></figure><p>显示寄存器可以使用的格式：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>显示为十六进制数</td></tr><tr><td>d</td><td>显示为十进制数</td></tr><tr><td>u</td><td>显示为无符号十进制数</td></tr><tr><td>o</td><td>显示为八进制数</td></tr><tr><td>t</td><td>显示为二进制数，t的由来是two</td></tr><tr><td>a</td><td>地址</td></tr><tr><td>c</td><td>显示为字符(ASCII)</td></tr><tr><td>f</td><td>浮点小数</td></tr><tr><td>s</td><td>显示为字符串</td></tr><tr><td>i</td><td>显示为机器语言(仅在显示内存的X命令中可以使用)</td></tr></tbody></table><h3 id="n"><a href="#n" class="headerlink" title="n"></a>n</h3><p>next，执行下一行语句，不进入函数</p><h3 id="s"><a href="#s" class="headerlink" title="s"></a>s</h3><p>step，单步进入，遇到函数的话就会进入函数的内部，再一行一行的执行。执行完当前函数返回到调用它的函数</p><h3 id="c"><a href="#c" class="headerlink" title="c"></a>c</h3><p>continue，继续执行，程序会在遇到断点后再次暂停运行，如果没有遇到断点就会一直运行到结束</p><p>continue 次数<br>指定次数可以忽略断点，例如，continue 5则5次遇断点不停止，第六次遇到断点才停止执行</p><h3 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h3><p>跳出当前函数，这里，运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，可以退出该函数返回到它的调用函数中</p><h3 id="forward-search-reverse-search"><a href="#forward-search-reverse-search" class="headerlink" title="forward-search  |  reverse-search"></a>forward-search  |  reverse-search</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) forward-search     //向前面搜索。 <br>(gdb) reverse-search    //从当前行的开始向后搜索<br></code></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>&lt;表达式&gt;  发生变化时暂停运行</p><h3 id="awatch"><a href="#awatch" class="headerlink" title="awatch"></a>awatch</h3><p>&lt;表达式&gt;  被访问，改变时暂停运行</p><h3 id="rwatch"><a href="#rwatch" class="headerlink" title="rwatch"></a>rwatch</h3><p>&lt;表达式&gt;  被访问时暂停运行</p><h3 id="info-locals"><a href="#info-locals" class="headerlink" title="info locals"></a>info locals</h3><p>打印出当前函数中所有局部变量以及值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info locals<br>resultvar = 18446744073709551100<br>sc_cancel_oldtype = 0<br>sc_ret = &lt;optimized out&gt;<br></code></pre></td></tr></table></figure><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>delete 删除断点和监视点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br>4       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br><br>--&gt;删除1号断点<br>(gdb) d 1<br>(gdb) info b<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br></code></pre></td></tr></table></figure><h3 id="set-variable"><a href="#set-variable" class="headerlink" title="set variable &lt;变量&gt; &#x3D; &lt;表达式&gt;"></a>set variable &lt;变量&gt; &#x3D; &lt;表达式&gt;</h3><p>设置变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb)p options<br><span class="hljs-variable">$7</span> =1<br>(gdb)<span class="hljs-built_in">set</span> varaable options = 0<br>(gdb)p options <br><span class="hljs-variable">$8</span> = 0<br></code></pre></td></tr></table></figure><h3 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h3><p>用于反汇编函数或指定地址范围的代码，以显示对应的汇编指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;address&gt; &lt;+offset&gt;:  &lt;assembly_instruction&gt;  &lt;operands&gt;<br><br>&lt;address&gt;：指令的地址<br>&lt;+offset&gt;：相对于函数或代码块开始处的偏移量<br>&lt;assembly_instruction&gt;：汇编指令的助记符<br>&lt;operands&gt;：汇编指令的操作数<br>在输出中，箭头 =&gt; 表示当前执行的指令<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">disassemble ：默认情况下，会反汇编当前执行点所在的函数或指定地址处的代码。<br>disassemble function_name ：反汇编指定函数的代码。<br>disassemble /m address ：从指定地址开始反汇编代码，/m 选项可用于指定反汇编的长度<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) disassemble <br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> __GI___poll:<br>   0x00007f218fcb1b90 &lt;+0&gt;:     lea    0xc6b59(%rip),%rax        <span class="hljs-comment"># 0x7f218fd786f0 &lt;__libc_multiple_threads&gt;</span><br>   0x00007f218fcb1b97 &lt;+7&gt;:     mov    (%rax),%eax<br>   0x00007f218fcb1b99 &lt;+9&gt;:     <span class="hljs-built_in">test</span>   %eax,%eax<br>   0x00007f218fcb1b9b &lt;+11&gt;:    jne    0x7f218fcb1bb0 &lt;__GI___poll+32&gt;<br>   0x00007f218fcb1b9d &lt;+13&gt;:    mov    <span class="hljs-variable">$0x7</span>,%eax<br>   0x00007f218fcb1ba2 &lt;+18&gt;:    syscall <br>   0x00007f218fcb1ba4 &lt;+20&gt;:    cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br>   0x00007f218fcb1baa &lt;+26&gt;:    ja     0x7f218fcb1c00 &lt;__GI___poll+112&gt;<br>   0x00007f218fcb1bac &lt;+28&gt;:    retq   <br>   0x00007f218fcb1bad &lt;+29&gt;:    nopl   (%rax)<br>   0x00007f218fcb1bb0 &lt;+32&gt;:    push   %r12<br>   0x00007f218fcb1bb2 &lt;+34&gt;:    mov    %edx,%r12d<br>   0x00007f218fcb1bb5 &lt;+37&gt;:    push   %rbp<br>   0x00007f218fcb1bb6 &lt;+38&gt;:    mov    %rsi,%rbp<br>   0x00007f218fcb1bb9 &lt;+41&gt;:    push   %rbx<br>   0x00007f218fcb1bba &lt;+42&gt;:    mov    %rdi,%rbx<br>   0x00007f218fcb1bbd &lt;+45&gt;:    sub    <span class="hljs-variable">$0x10</span>,%rsp<br>   0x00007f218fcb1bc1 &lt;+49&gt;:    callq  0x7f218fcc9a60 &lt;__libc_enable_asynccancel&gt;<br>   0x00007f218fcb1bc6 &lt;+54&gt;:    mov    %r12d,%edx<br>   0x00007f218fcb1bc9 &lt;+57&gt;:    mov    %rbp,%rsi<br>   0x00007f218fcb1bcc &lt;+60&gt;:    mov    %rbx,%rdi<br>   0x00007f218fcb1bcf &lt;+63&gt;:    mov    %eax,%r8d<br>   0x00007f218fcb1bd2 &lt;+66&gt;:    mov    <span class="hljs-variable">$0x7</span>,%eax<br>   0x00007f218fcb1bd7 &lt;+71&gt;:    syscall <br>=&gt; 0x00007f218fcb1bd9 &lt;+73&gt;:    cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br>   0x00007f218fcb1bdf &lt;+79&gt;:    ja     0x7f218fcb1c12 &lt;__GI___poll+130&gt;<br>   0x00007f218fcb1be1 &lt;+81&gt;:    mov    %r8d,%edi<br>   0x00007f218fcb1be4 &lt;+84&gt;:    mov    %eax,0xc(%rsp)<br>   0x00007f218fcb1be8 &lt;+88&gt;:    callq  0x7f218fcc9ac0 &lt;__libc_disable_asynccancel&gt;<br>   0x00007f218fcb1bed &lt;+93&gt;:    mov    0xc(%rsp),%eax<br>   0x00007f218fcb1bf1 &lt;+97&gt;:    add    <span class="hljs-variable">$0x10</span>,%rsp<br>   0x00007f218fcb1bf5 &lt;+101&gt;:   pop    %rbx<br>   0x00007f218fcb1bf6 &lt;+102&gt;:   pop    %rbp<br>   0x00007f218fcb1bf7 &lt;+103&gt;:   pop    %r12<br>   0x00007f218fcb1bf9 &lt;+105&gt;:   retq   <br>   0x00007f218fcb1bfa &lt;+106&gt;:   nopw   0x0(%rax,%rax,1)<br>   0x00007f218fcb1c00 &lt;+112&gt;:   mov    0xc1269(%rip),%rdx        <span class="hljs-comment"># 0x7f218fd72e70</span><br>   0x00007f218fcb1c07 &lt;+119&gt;:   neg    %eax<br>   0x00007f218fcb1c09 &lt;+121&gt;:   mov    %eax,%fs:(%rdx)<br>   0x00007f218fcb1c0c &lt;+124&gt;:   mov    <span class="hljs-variable">$0xffffffff</span>,%eax<br>   0x00007f218fcb1c11 &lt;+129&gt;:   retq   <br>   0x00007f218fcb1c12 &lt;+130&gt;:   mov    0xc1257(%rip),%rdx        <span class="hljs-comment"># 0x7f218fd72e70</span><br>   0x00007f218fcb1c19 &lt;+137&gt;:   neg    %eax<br>   0x00007f218fcb1c1b &lt;+139&gt;:   mov    %eax,%fs:(%rdx)<br>   0x00007f218fcb1c1e &lt;+142&gt;:   mov    <span class="hljs-variable">$0xffffffff</span>,%eax<br>   0x00007f218fcb1c23 &lt;+147&gt;:   jmp    0x7f218fcb1be1 &lt;__GI___poll+81&gt;<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h3 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h3><p>可以定义在断点中断后执行的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">commands 断点编号<br>命令<br>...<br>end<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007f218fcb1bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br>(gdb) <span class="hljs-built_in">command</span> 1 <br>Type commands <span class="hljs-keyword">for</span> breakpoint(s) 1, one per line.<br>End with a line saying just <span class="hljs-string">&quot;end&quot;</span>.<br>&gt;p <span class="hljs-variable">$rip</span><br>&gt;end<br></code></pre></td></tr></table></figure><h3 id="l"><a href="#l" class="headerlink" title="l"></a>l</h3><p>list，命令用于显示源代码，当没有参数时，它会显示当前执行代码的周围区域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">list：显示当前执行点周围的源代码。<br>list function_name：显示特定函数的源代码。<br>list filename:linenum：显示特定文件中特定行号的源代码。<br>list start, end：显示指定范围内的源代码行<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) list<br>24      <span class="hljs-keyword">in</span> ../sysdeps/unix/sysv/linux/poll.c<br></code></pre></td></tr></table></figure><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>用于设置要在每次程序停止时自动显示的表达式的值，持续监视特定变量或表达式的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) display x<br>1: x = 5<br>(gdb) display *ptr<br>2: *ptr = 0x7fff5fbff7f<br>(gdb) display result<br>3: result = 42<br>(gdb) display a &gt; b<br>4: a &gt; b = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>用undisplay取消</p><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>进行指定位置跳转，执行完区间代码</p>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kdump</title>
    <link href="/dbg_meth/kdump/"/>
    <url>/dbg_meth/kdump/</url>
    
    <content type="html"><![CDATA[<h1 id="Kdump"><a href="#Kdump" class="headerlink" title="Kdump"></a>Kdump</h1><p>kdump是在系统崩溃、死锁、或者死机的时候用来转储内存为vmcore保存到磁盘的一个工具和服务</p><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">CONFIG_KEXEC=y<br>CONFIG_KEXEC_FILE=y   <br><span class="hljs-comment">//两者选其一，或者都选也可以，对应两个版本的kexec接口</span><br><br>CONFIG_CRASH_DUMP=y   <br><span class="hljs-comment">//内核支持系统崩溃转储功能，即能够生成 vmcore 文件以便进行故障诊断和调试</span><br>CONFIG_PROC_VMCORE=y<br><span class="hljs-comment">//内核支持在 /proc 文件系统中生成 vmcore 文件以供调试和分析系统崩溃时的信息</span><br>CONFIG_RELOCATABLE=y<br><span class="hljs-comment">//内核能够在运行时进行地址重定位，从而使内核能够在不同的物理内存地址上加载和运行</span><br>CONFIG_SYSFS=y<br>CONFIG_DEBUG_INFO=y<br><span class="hljs-comment">//编译过程中会生成额外的调试信息，包括函数符号，代码注释，宏定义等</span><br></code></pre></td></tr></table></figure><h3 id="安装用户态工具包"><a href="#安装用户态工具包" class="headerlink" title="安装用户态工具包"></a>安装用户态工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install kdump-tools<br><span class="hljs-built_in">sudo</span> apt install makedumpfile<br></code></pre></td></tr></table></figure><h3 id="配置预留内存"><a href="#配置预留内存" class="headerlink" title="配置预留内存"></a>配置预留内存</h3><p>配置第一内核启动参数（&#x2F;etc&#x2F;default&#x2F;grub.d&#x2F;kdump-tools.cfg）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;<span class="hljs-variable">$GRUB_CMDLINE_LINUX_DEFAULT</span> crashkernel=512M&quot;</span><br></code></pre></td></tr></table></figure><p>完整的格式可以是：crashkernel&#x3D;1G-:512M@3G，其含义是：</p><ul><li>当内存大于1Ｇ时，预留512Ｍ</li><li>预留位置在3Ｇ</li><li>如果“@offset”部分留空的话，内核会自动寻找合适的位置。（一般都不需要指定）</li><li>在x86虚拟机环境里，直接用crashkernel&#x3D;512M就能正常运行，但某些架构不行，所以推荐用这个格式：crashkernel&#x3D;1G-:512M。</li><li>预留内存大小默认是128Ｍ，一般而言都太小了，建议使用512Ｍ</li></ul><p>注意：</p><ul><li>sw内核的crashkernel代码不完整，没有实现自动寻找的功能，所以不指定offset时会默认为offset&#x3D;0，与第一内核发生冲突而导致系统起不来，此时应该用完整的格式，比如1G-:512M@3G。</li></ul><p>配置完成后需要重启系统生效</p><p>有两种方式可以确认内核是否正确完成了内存预留：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dmesg | grep -i crashkernel<br><br>[0.008200] Reserving 512MB of memory at 1520MB <span class="hljs-keyword">for</span> crashkernel (System RAM: 4095MB)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /proc/iomem<br><br>00100000-7ffdbfff : System RAM<br>01000000-02002287 : Kernel code<br>02200000-02cb1fff : Kernel rodata<br>02e00000-0311473f : Kernel data<br>03449000-039fffff : Kernel bss<br>5f000000-7effffff : Crash kernel<br></code></pre></td></tr></table></figure><h3 id="触发Kdump"><a href="#触发Kdump" class="headerlink" title="触发Kdump"></a>触发Kdump</h3><ul><li>手动触发<ul><li>开启sysrq   <code>sysctl kernel.sysrq=1</code></li><li>触发panic   <code>echo c &gt; /proc/sysrq-trigger</code></li></ul></li><li>oops</li><li>oom</li><li>softlockup&#x2F;hardlockup</li><li>rcu-stall</li></ul>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf</title>
    <link href="/dbg_meth/perf/"/>
    <url>/dbg_meth/perf/</url>
    
    <content type="html"><![CDATA[<p>tar -xvf perf-5.10.0.tar.gz<br>cd perf-5.10.0<br>cd tools&#x2F;perf&#x2F;<br>make<br>sudo cp perf &#x2F;usr&#x2F;local&#x2F;bin</p><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;perf –version</p><p>download:<br>    <a href="https://cdn.kernel.org/pub/linux/kernel/tools/perf/">https://cdn.kernel.org/pub/linux/kernel/tools/perf/</a></p>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>strace</title>
    <link href="/dbg_meth/strace/"/>
    <url>/dbg_meth/strace/</url>
    
    <content type="html"><![CDATA[<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值</p><ul><li><pre><code class="shell">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.-d 输出strace关于标准错误的调试信息.-f 跟踪由fork调用所产生的子进程.-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.-h 输出简要的帮助信息.-i 输出系统调用的入口指针.-q 禁止输出关于脱离的消息.-r 打印出相对时间关于,,每一个系统调用.-t 在输出中的每一行前加上时间信息.-tt 在输出中的每一行前加上时间信息,微秒级.-ttt 微秒级输出,以秒了表示时间.-T 显示每一调用所耗的时间.-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.-V 输出strace的版本信息.-x 以十六进制形式输出非标准字符串-xx 所有字符串以十六进制形式输出.-a column 设置返回值的输出位置.默认 为40.-e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]...qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\.-e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.-e trace=file 只跟踪有关文件操作的系统调用.-e trace=process 只跟踪有关进程控制的系统调用.-e trace=network 跟踪与网络有关的所有系统调用.-e strace=signal 跟踪所有与系统信号有关的 系统调用-e trace=ipc 跟踪所有与进程通讯有关的系统调用-e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.-e raw=set 将指定的系统调用的参数以十六进制显示.-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5-e write=set 输出写入到指定文件中的数据.-o filename 将strace的输出写入文件filename-p pid 跟踪指定的进程pid.-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.-u username 以username的UID和GID执行被跟踪的命令</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg_meth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bpftrace</title>
    <link href="/dbg_meth/bpfgrace/bpftrace/"/>
    <url>/dbg_meth/bpfgrace/bpftrace/</url>
    
    <content type="html"><![CDATA[<h2 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h2><ul><li><p>探针</p></li><li><img src="/dbg_meth/bpfgrace/bpftrace/probe.jpg" class="" title="probe"><p>kprobeb&#x2F;kretprobe为动态跟踪、内核级探针，kprobeb是检测函数执行的开始，kretprobe为检测结束（返回）</p><p>uprobe&#x2F;uretprobe为动态跟踪、用户级探针，uprobeb是检测用户级函数执行的开始，uretprobe为检测结束（返回）。tracepoint为静态跟踪、用户级探针</p></li><li><p>单行命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">bpftrace -e &#x27;BEGIN &#123; printf(&quot;Hello world!\n&quot;); &#125;&#x27;<br>bpftrace -e &#x27;kprobe:vfs_read &#123; @[tid] = count();&#125;&#x27;<br>bpftrace -e &#x27;kprobe:vfs_read  /pid == 123/ &#123; @[tid, comm] = count();&#125;&#x27;<br>bpftrace -e &#x27;t:block:block_rq_insert &#123; @[kstack] = count(); &#125;&#x27;<br></code></pre></td></tr></table></figure><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">probes /filter/ &#123; actions &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>probes</code>表示事件 tracepoint、kprobe、kretprobe、uprobe、BEGIN、END</p></li><li><p><code>filter</code>表示过滤条件 当一个事件触发时，会先判断该条件，满足条件才会执行后面的action行为</p></li><li><p><code>action</code>表示具体操作</p></li><li><p><code>bpftrace -e &#39;kprobe:vfs_read  /pid == 123/ &#123; @[tid, comm] = count();&#125;&#39;</code></p></li></ul></li><li><p>变量</p><ul><li><p>内部变量（build-in）</p></li><li><pre><code class="c">uid:用户idtid：线程idpid：进程idcpu：cpu idcgroup：cgroup idprobe：当前的trace点comm：进程名字nsecs：纳秒级别的时间戳kstack：内核栈回溯ustack - 用户栈回溯curtask：当前进程的task_struct地址args:获取该kprobe或者tracepoint的参数列表arg0:获取该kprobe的第一个变量，tracepoint不可用arg1:获取该kprobe的第二个变量，tracepoint不可用arg2:获取该kprobe的第三个变量，tracepoint不可用retval: kretprobe中获取函数返回值args-&gt;ret: kretprobe中获取函数返回值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 使用`-v`选项可以列出tracepoint类型跟踪点的参数<br><br>  ```c<br>  <span class="hljs-meta"># bpftrace -lv tracepoint:syscalls:sys_enter_shmctl</span><br>  tracepoint:syscalls:sys_enter_shmctl<br>      <span class="hljs-type">int</span> __syscall_nr;<br>      <span class="hljs-type">int</span> shmid;<br>      <span class="hljs-type">int</span> cmd;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">shmid_ds</span> * buf;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>dbg_meth</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符设备驱动</title>
    <link href="/kernel/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/kernel/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="Linux内核对设备的分类"><a href="#Linux内核对设备的分类" class="headerlink" title="Linux内核对设备的分类"></a>Linux内核对设备的分类</h3><p>linux的文件种类：</p><ol><li>-：普通文件</li><li>d：目录文件</li><li>p：管道文件</li><li>s：本地socket文件</li><li>l：链接文件</li><li>c：字符设备</li><li>b：块设备</li></ol><p>Linux内核按驱动程序实现模型框架的不同，将设备分为三类：</p><ol><li>字符设备：按字节流形式进行数据读写的设备，一般情况下按顺序访问，数据量不大，一般不设缓存</li><li>块设备：按整块进行数据读写的设备，最小的块大小为512字节（一个扇区），块的大小必须是扇区的整数倍，Linux系统的块大小一般为4096字节，随机访问，设缓存以提高效率</li><li>网络设备：针对网络数据收发的设备</li></ol><h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>内核用设备号来区分同类里不同的设备，设备号是一个无符号32位整数，数据类型为dev_t，设备号分为两部分：</p><ol><li>主设备号：占高12位，用来表示驱动程序相同的一类设备</li><li>次设备号：占低20位，用来表示被操作的哪个具体设备</li></ol><p>应用程序打开一个设备文件时，通过设备号来查找定位内核中管理的设备。</p><h4 id="MKDEV"><a href="#MKDEV" class="headerlink" title="MKDEV"></a>MKDEV</h4><p>宏用来将主设备号和次设备号组合成32位完整的设备号，用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dev_t</span> devno;<br><span class="hljs-type">int</span> major = <span class="hljs-number">251</span>;<span class="hljs-comment">//主设备号</span><br><span class="hljs-type">int</span> minor = <span class="hljs-number">2</span>;<span class="hljs-comment">//次设备号</span><br>devno = MKDEV(major,minor);<br></code></pre></td></tr></table></figure><h4 id="MAJOR"><a href="#MAJOR" class="headerlink" title="MAJOR"></a>MAJOR</h4><p>宏用来从32位设备号中分离出主设备号，用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dev_t</span> devno = MKDEV(<span class="hljs-number">249</span>,<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> major = MAJOR(devno);<br></code></pre></td></tr></table></figure><h4 id="MINOR"><a href="#MINOR" class="headerlink" title="MINOR"></a>MINOR</h4><p>宏用来从32位设备号中分离出次设备号，用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dev_t</span> devno = MKDEV(<span class="hljs-number">249</span>,<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> minor = MINOR(devno);<br></code></pre></td></tr></table></figure><p>如果已知一个设备的主次设备号，应用层指定好设备文件名，那么可以用mknod命令在&#x2F;dev目录创建代表这个设备的文件，即此后应用程序对此文件的操作就是对其代表的设备操作，mknod用法如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">cd /dev<br>mknod 设备文件名 设备种类(c为字符设备,b为块设备)  主设备号  次设备号  //ubuntu下需加sudo执行<br></code></pre></td></tr></table></figure><p>在应用程序中如果要创建设备可以调用系统调用函数mknod，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">mode_t</span> mode,<span class="hljs-type">dev_t</span> dev)</span>;<br>pathname:带路径的设备文件名，无路径默认为当前目录，一般都创建在/dev下<br>mode：文件权限 位或 S_IFCHR/S_IFBLK<br>dev:  <span class="hljs-number">32</span>位设备号<br>返回值：成功为<span class="hljs-number">0</span>，失败<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="申请-注销设备号"><a href="#申请-注销设备号" class="headerlink" title="申请&#x2F;注销设备号"></a>申请&#x2F;注销设备号</h3><p>字符驱动开发的第一步是通过模块的入口函数向内核添加本设备驱动的代码框架，主要完成：</p><ol><li>申请设备号</li><li>定义、初始化、向内核添加代表本设备的结构体元素</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>功能：手动分配设备号，先验证设备号是否被占用，如果没有则申请占用该设备号<br>参数：<br>from：自己指定的设备号<br>count：申请的设备数量<br>name：/proc/devices文件中与该设备对应的名字，方便用户层查询主设备号<br>返回值：<br>成功为0，失败负数，绝对值为错误码<br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev,<span class="hljs-type">unsigned</span> baseminor,<span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>功能：动态分配设备号，查询内核里未被占用的设备号，如果找到则占用该设备号<br>参数：<br>dev：分配设备号成功后用来存放分配到的设备号<br>baseminior：起始的次设备号，一般为0<br>count：申请的设备数量<br>name：/proc/devices文件中与该设备对应的名字，方便用户层查询主次设备号<br>返回值：<br>成功为0，失败负数，绝对值为错误码<br></code></pre></td></tr></table></figure><p>分配成功后在&#x2F;proc&#x2F;devices 可以查看到申请到主设备号和对应的设备名，mknod时参数可以参考查到的此设备信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br>功能：释放设备号<br>参数：<br>from：已成功分配的设备号将被释放<br>count：申请成功的设备数量<br></code></pre></td></tr></table></figure><p>释放后&#x2F;proc&#x2F;devices文件对应的记录消失</p><h3 id="注册字符设备"><a href="#注册字符设备" class="headerlink" title="注册字符设备"></a>注册字符设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span>              <span class="hljs-comment">//表示该类型实体是一种内核对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>             <span class="hljs-comment">//填THIS_MODULE，表示该字符设备从属于哪个内核模块</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><span class="hljs-comment">//指向空间存放着针对该设备的各种操作函数地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>            <span class="hljs-comment">//链表指针域</span><br><span class="hljs-type">dev_t</span> dev;                        <span class="hljs-comment">//设备号</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;               <span class="hljs-comment">//设备数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>自己定义的结构体中必须有一个成员为 struct cdev cdev，两种方法定义一个设备：</p><ol><li>直接定义：定义结构体全局变量</li><li>动态申请：<code>struct  cdev * cdev_alloc()</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cdev_init() - initialize a cdev structure</span><br><span class="hljs-comment"> * @cdev: the structure to initialize</span><br><span class="hljs-comment"> * @fops: the file_operations for this device</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span><br><span class="hljs-comment"> * system with cdev_add().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *cdev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><br>&#123;<br><span class="hljs-built_in">memset</span>(cdev, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> *cdev);<br>INIT_LIST_HEAD(&amp;cdev-&gt;<span class="hljs-built_in">list</span>);<br>kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<br>cdev-&gt;ops = fops;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cdev_add() - add a char device to the system</span><br><span class="hljs-comment"> * @p: the cdev structure for the device</span><br><span class="hljs-comment"> * @dev: the first device number for which this device is responsible</span><br><span class="hljs-comment"> * @count: the number of consecutive minor numbers corresponding to this</span><br><span class="hljs-comment"> *         device</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cdev_add() adds the device represented by @p to the system, making it</span><br><span class="hljs-comment"> * live immediately.  A negative error code is returned on failure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cdev_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">dev_t</span> dev, <span class="hljs-type">unsigned</span> count)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>p-&gt;dev = dev;<br>p-&gt;count = count;<br><br><span class="hljs-keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV))<br><span class="hljs-keyword">return</span> -EBUSY;<br><br>error = kobj_map(cdev_map, dev, count, <span class="hljs-literal">NULL</span>,<br> exact_match, exact_lock, p);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>kobject_get(p-&gt;kobj.parent);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cdev_del() - remove a cdev from the system</span><br><span class="hljs-comment"> * @p: the cdev structure to be removed</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cdev_del() removes @p from the system, possibly freeing the structure</span><br><span class="hljs-comment"> * itself.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> This guarantees that cdev device will no longer be able to be</span><br><span class="hljs-comment"> * opened, however any cdevs already open will remain and their fops will</span><br><span class="hljs-comment"> * still be callable even after cdev_del returns.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p)</span><br>&#123;<br>cdev_unmap(p-&gt;dev, p-&gt;count);<br>kobject_put(&amp;p-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="file-operations"><a href="#file-operations" class="headerlink" title="file_operations"></a>file_operations</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<span class="hljs-comment">//数据操作位置的定位  指向函数用来获取或设置设备数据的开始操作位置（位置指示器），对应lseek系统调用，是lseek系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<span class="hljs-comment">//读设备  指向函数用来将设备产生的数据读到用户空间，对应read系统调用，是read系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<span class="hljs-comment">//写设备  指向函数用来将用户空间的数据写进设备，对应write系统调用，是write系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">int</span> (*iopoll)(<span class="hljs-keyword">struct</span> kiocb *kiocb, <span class="hljs-type">bool</span> spin);<br><span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-type">int</span> (*iterate_shared) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-type">__poll_t</span> (*poll) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *);<span class="hljs-comment">//POLL机制，实现对设备的多路复用方式的访问   指向函数用来协助多路复用机制完成对本设备可读、可写数据的监控，对应select、poll、epoll_wait系统调用，是select、poll、epoll_wait系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<span class="hljs-comment">//读写设备参数，读设备状态、控制设备   指向函数用来获取、设置设备一些属性或设备的工作方式等非数据读写操作，对应ioctl系统调用，是ioctl系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_supported_flags;<br><span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<span class="hljs-comment">//打开设备  指向函数一般用来对设备进行硬件上的初始化，对于一些简单的设备该函数只需要return 0，对应open系统调用，是open系统调用函数实现过程中调用的函数,</span><br><br><span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<span class="hljs-comment">//关闭设备  指向函数一般用来对设备进行硬件上的关闭操作，对于一些简单的设备该函数只需要return 0，对应close系统调用，是close系统调用函数实现过程中调用的函数</span><br><span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<span class="hljs-comment">//信号驱动  指向函数用来创建信号驱动机制的引擎，对应fcntl系统调用的FASYNC标记设置，是fcntl系统调用函数FASYNC标记设置过程中调用的函数</span><br><span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br>  <span class="hljs-type">loff_t</span> len);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">ssize_t</span> (*copy_file_range)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-keyword">struct</span> file *,<br><span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">loff_t</span> (*remap_file_range)(<span class="hljs-keyword">struct</span> file *file_in, <span class="hljs-type">loff_t</span> pos_in,<br>   <span class="hljs-keyword">struct</span> file *file_out, <span class="hljs-type">loff_t</span> pos_out,<br>   <span class="hljs-type">loff_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remap_flags);<br><span class="hljs-type">int</span> (*fadvise)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-type">bool</span> may_pollfree;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设备模型</title>
    <link href="/kernel/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/kernel/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-设备模型"><a href="#linux-设备模型" class="headerlink" title="linux 设备模型"></a>linux 设备模型</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><table><thead><tr><th>类型</th><th>内容</th><th>内核数据结构</th><th>对应&#x2F;sys项</th></tr></thead><tbody><tr><td>设备Devices</td><td>设备是此模型中最基本的类型，以设备本身的连接按层次组织</td><td>struct device</td><td>&#x2F;sys&#x2F;devices&#x2F;?&#x2F;?&#x2F;…&#x2F;</td></tr><tr><td>驱动Drivers</td><td>在一个系统中安装多个相同设备，只需要一份驱动程序的支持</td><td>struct device_driver</td><td>&#x2F;sys&#x2F;bus&#x2F;pci&#x2F;drivers&#x2F;?&#x2F;</td></tr><tr><td>总线Bus</td><td>在整个总线级别对此总线上连接的所有设备进行管理</td><td>struct bus_type</td><td>&#x2F;sys&#x2F;bus&#x2F;?&#x2F;</td></tr><tr><td>类Classes</td><td>这是按照功能进行分类组织的设备层次树；如 USB 接口和 PS&#x2F;2 接口的鼠标都是输入设备，都会出现在&#x2F;sys&#x2F;class&#x2F;input&#x2F;下</td><td>struct class</td><td>&#x2F;sys&#x2F;class&#x2F;?&#x2F;</td></tr></tbody></table><h3 id="目录组织结构"><a href="#目录组织结构" class="headerlink" title="目录组织结构"></a>目录组织结构</h3><table><thead><tr><th>&#x2F;sys下的子目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;sys&#x2F;devices</td><td>内核对系统中所有设备的分层次表达模型，也是&#x2F;sys文件系统管理设备的最重要的目录结构</td></tr><tr><td>&#x2F;sys&#x2F;dev</td><td>这个目录下维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(&#x2F;sys&#x2F;devices下)的符号链接文件</td></tr><tr><td>&#x2F;sys&#x2F;bus</td><td>内核设备按总线类型分层放置的目录结构， devices 中的所有设备都是连接于某种总线之下，在这里的每一种具体总线之下可以找到每一个具体设备的符号链接，它也是构成 Linux 统一设备模型的一部分</td></tr><tr><td>&#x2F;sys&#x2F;class</td><td>按照设备功能分类的设备模型，如系统所有输入设备都会出现在&#x2F;sys&#x2F;class&#x2F;input 之下，而不论它们是以何种总线连接到系统。它也是构成 Linux 统一设备模型的一部分</td></tr><tr><td>&#x2F;sys&#x2F;kernel</td><td>内核所有可调整参数的位置，目前只有 uevent_helper, kexec_loaded, mm, 和新式的slab 分配器等几项较新的设计在使用它，其它内核可调整参数仍然位于sysctl(&#x2F;proc&#x2F;sys&#x2F;kernel) 接口中</td></tr><tr><td>&#x2F;sys&#x2F;module</td><td>这里有系统中所有模块的信息，不论这些模块是以内联(inlined)方式编译到内核映像文件(vmlinuz)中还是编译为外部模块(ko文件)，都可能会出现在&#x2F;sys&#x2F;module 中</td></tr><tr><td>&#x2F;sys&#x2F;power</td><td>系统中电源选项，这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机、重启等</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/config/shell/"/>
    <url>/config/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p><code>sudo apt install    fzf   ripgrep</code></p><p>~&#x2F;.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ~/.bashrc: executed by bash(1) for non-login shells.</span><br><span class="hljs-comment"># see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)</span><br><span class="hljs-comment"># for examples</span><br><br><span class="hljs-comment"># If not running interactively, don&#x27;t do anything</span><br><span class="hljs-keyword">case</span> $- <span class="hljs-keyword">in</span><br>    *i*) ;;<br>      *) <span class="hljs-built_in">return</span>;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># don&#x27;t put duplicate lines or lines starting with space in the history.</span><br><span class="hljs-comment"># See bash(1) for more options</span><br>HISTCONTROL=ignoreboth<br><br><span class="hljs-comment"># append to the history file, don&#x27;t overwrite it</span><br><span class="hljs-built_in">shopt</span> -s histappend<br><br><span class="hljs-comment"># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span><br>HISTSIZE=1000<br>HISTFILESIZE=2000<br><br><span class="hljs-comment"># check the window size after each command and, if necessary,</span><br><span class="hljs-comment"># update the values of LINES and COLUMNS.</span><br><span class="hljs-built_in">shopt</span> -s checkwinsize<br><br><span class="hljs-comment"># If set, the pattern &quot;**&quot; used in a pathname expansion context will</span><br><span class="hljs-comment"># match all files and zero or more directories and subdirectories.</span><br><span class="hljs-comment">#shopt -s globstar</span><br><br><span class="hljs-comment"># make less more friendly for non-text input files, see lesspipe(1)</span><br><span class="hljs-comment">#[ -x /usr/bin/lesspipe ] &amp;&amp; eval &quot;$(SHELL=/bin/sh lesspipe)&quot;</span><br><br><span class="hljs-comment"># set variable identifying the chroot you work in (used in the prompt below)</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;debian_chroot:-&#125;</span>&quot;</span> ] &amp;&amp; [ -r /etc/debian_chroot ]; <span class="hljs-keyword">then</span><br>    debian_chroot=$(<span class="hljs-built_in">cat</span> /etc/debian_chroot)<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># set a fancy prompt (non-color, unless we know we &quot;want&quot; color)</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> <span class="hljs-keyword">in</span><br>    xterm-color|*-256color) color_prompt=<span class="hljs-built_in">yes</span>;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># uncomment for a colored prompt, if the terminal has the capability; turned</span><br><span class="hljs-comment"># off by default to not distract the user: the focus in a terminal window</span><br><span class="hljs-comment"># should be on the output of commands, not on the prompt</span><br><span class="hljs-comment">#force_color_prompt=yes</span><br><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$force_color_prompt</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; <span class="hljs-keyword">then</span><br>        <span class="hljs-comment"># We have color support; assume it&#x27;s compliant with Ecma-48</span><br>        <span class="hljs-comment"># (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span><br>        <span class="hljs-comment"># a case would tend to support setf rather than setaf.)</span><br>        color_prompt=<span class="hljs-built_in">yes</span><br>    <span class="hljs-keyword">else</span><br>        color_prompt=<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$color_prompt</span>&quot;</span> = <span class="hljs-built_in">yes</span> ]; <span class="hljs-keyword">then</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="hljs-keyword">else</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">unset</span> color_prompt force_color_prompt<br><br><span class="hljs-comment"># If this is an xterm set the title to user@host:dir</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> <span class="hljs-keyword">in</span><br>xterm*|rxvt*)<br>    PS1=<span class="hljs-string">&quot;\[\e]0;<span class="hljs-variable">$&#123;debian_chroot:+($debian_chroot)&#125;</span>\u@\h: \w\a\]<span class="hljs-variable">$PS1</span>&quot;</span><br>    ;;<br>*)<br>    ;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># enable color support of ls and also add handy aliases</span><br><span class="hljs-keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b)</span>&quot;</span><br>    <span class="hljs-built_in">alias</span> <span class="hljs-built_in">ls</span>=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias dir=&#x27;dir --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span><br><br>    <span class="hljs-comment">#alias grep=&#x27;grep --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># colored GCC warnings and errors</span><br><span class="hljs-comment">#export GCC_COLORS=&#x27;error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01&#x27;</span><br><br><span class="hljs-comment"># some more ls aliases</span><br><span class="hljs-comment">#alias ll=&#x27;ls -l&#x27;</span><br><span class="hljs-comment">#alias la=&#x27;ls -A&#x27;</span><br><span class="hljs-comment">#alias l=&#x27;ls -CF&#x27;</span><br><br><span class="hljs-comment"># Alias definitions.</span><br><span class="hljs-comment"># You may want to put all your additions into a separate file like</span><br><span class="hljs-comment"># ~/.bash_aliases, instead of adding them here directly.</span><br><span class="hljs-comment"># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span><br><br><span class="hljs-keyword">if</span> [ -f ~/.bash_aliases ]; <span class="hljs-keyword">then</span><br>    . ~/.bash_aliases<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># enable programmable completion features (you don&#x27;t need to enable</span><br><span class="hljs-comment"># this, if it&#x27;s already enabled in /etc/bash.bashrc and /etc/profile</span><br><span class="hljs-comment"># sources /etc/bash.bashrc).</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">shopt</span> -oq posix; <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="hljs-keyword">then</span><br>    . /usr/share/bash-completion/bash_completion<br>  <span class="hljs-keyword">elif</span> [ -f /etc/bash_completion ]; <span class="hljs-keyword">then</span><br>    . /etc/bash_completion<br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># Set LS_COLORS environment by Deepin</span><br><span class="hljs-keyword">if</span> [[ (<span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = *256color || <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = screen* || <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = xterm* ) &amp;&amp; -f /etc/lscolor-256color ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span> -b /etc/lscolor-256color)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span>)<br><span class="hljs-keyword">fi</span><br><br>[ -f ~/.fzf.bash ] &amp;&amp; <span class="hljs-built_in">source</span> ~/.fzf.bash<br><br><span class="hljs-built_in">export</span> FZF_DEFAULT_COMMAND=<span class="hljs-string">&#x27;rg --files --hidden&#x27;</span><br><span class="hljs-built_in">export</span> FZF_CTRL_T_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$FZF_DEFAULT_COMMAND</span>&quot;</span><br><span class="hljs-comment">#export FZF_DEFAULT_OPTS=&#x27;--preview &quot;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (rougify &#123;&#125;  || highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null&quot; --height 50% --reverse --border&#x27;</span><br><br><span class="hljs-comment">#bind -x &#x27;&quot;\C-f&quot;: &quot;$(fzf)&quot;&#x27;</span><br><span class="hljs-comment"># Custom FZF command to open the selected file</span><br>fzf-<span class="hljs-function"><span class="hljs-title">open</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> file<br>  file=$(fzf --preview <span class="hljs-string">&quot;[[ \$(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (rougify &#123;&#125;  || highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null&quot;</span> --height 50% --reverse --border --select-1 --exit-0) &amp;&amp; vim <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># Bind Ctrl+F to fzf-open</span><br><span class="hljs-built_in">bind</span> -x <span class="hljs-string">&#x27;&quot;\C-f&quot;: &quot;fzf-open&quot;&#x27;</span><br><br></code></pre></td></tr></table></figure><p><code>source ~/.bashrc</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tmux</title>
    <link href="/config/tmux/"/>
    <url>/config/tmux/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>插件，<code>tmux-continuum</code>  <code>plugins</code>放入~&#x2F;.tmux文件夹</p><p>~&#x2F;.tmux.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置Prefix为Ctrl+x</span><br>set-option -g prefix C-x<br>unbind C-b<br><span class="hljs-built_in">bind</span> C-x send-prefix<br> <br><span class="hljs-comment"># 开始鼠标模式</span><br><span class="hljs-comment">##  tmux v2.1及上 </span><br>set-option -g mouse on<br>set-window-option -g mode-mouse on <span class="hljs-comment"># (setw其实是set-window-option的别名)</span><br>setw -g mouse-resize-pane on <span class="hljs-comment"># 开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线</span><br>setw -g mouse-select-pane on <span class="hljs-comment"># 开启用鼠标点击pane来激活该pane</span><br>setw -g mouse-select-window on <span class="hljs-comment"># 开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）</span><br>setw -g mode-mouse on <span class="hljs-comment"># 开启window/pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</span><br><br><span class="hljs-built_in">set</span> -g history-limit 100000<br><br><span class="hljs-comment"># 开启复制模式</span><br>setw -g mode-keys vi<br>set-window-option -g mode-keys vi<br> <br><span class="hljs-comment"># 使用快捷键r重新读取配置文件</span><br><span class="hljs-built_in">bind</span> r source-file ~/.tmux.conf\; display <span class="hljs-string">&quot;Reloaded!&quot;</span><br> <br><span class="hljs-comment"># 设置Window和Pane开始编号为1</span><br>set-option -g base-index 1<br>set-window-option -g pane-base-index 1<br> <br>bind-key k select-pane -U <span class="hljs-comment"># up</span><br>bind-key j select-pane -D <span class="hljs-comment"># down </span><br>bind-key h select-pane -L <span class="hljs-comment"># left</span><br>bind-key l select-pane -R <span class="hljs-comment"># right</span><br><br><span class="hljs-comment"># 设置Ctrl+j为横向分屏</span><br>bind-key -n C-j split-window -h<br><br><span class="hljs-comment"># 设置Ctrl+h为竖向分屏</span><br>bind-key -n C-h split-window -v<br><br><span class="hljs-comment"># List of plugins</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tpm&#x27;</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-sensible&#x27;</span><br><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;dracula/tmux&#x27;</span><br><span class="hljs-built_in">set</span> -g @dracula-plugins <span class="hljs-string">&quot;ssh-session cpu-usage ram-usage time&quot;</span>  <span class="hljs-comment">#状态栏显示的内容</span><br><span class="hljs-built_in">set</span> -g @dracula-show-flags <span class="hljs-literal">true</span> <br><span class="hljs-built_in">set</span> -g @dracula-show-left-icon session  <span class="hljs-comment"># 最左侧的图标显示当前tmux session名称</span><br><span class="hljs-built_in">set</span> -g @dracula-show-powerline <span class="hljs-literal">true</span> <span class="hljs-comment"># 显示powerline,更美观</span><br><span class="hljs-built_in">set</span> -g @dracula-time-format <span class="hljs-string">&quot;%F %R&quot;</span> <span class="hljs-comment"># 时间格式 </span><br><br><span class="hljs-comment">#ls颜色</span><br><span class="hljs-comment">#set -g default-terminal &quot;tmux-256color&quot;</span><br><span class="hljs-comment">#set-option -a terminal-overrides &quot;,*256col*:RGB&quot;</span><br><br>run <span class="hljs-string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br>run-shell ~/.tmux/tmux-continuum/continuum.tmux<br><span class="hljs-built_in">set</span> -g @continuum-save-interval <span class="hljs-string">&#x27;60&#x27;</span><br></code></pre></td></tr></table></figure><p><code>tmux source-file ~/.tmux.conf</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/config/vim/"/>
    <url>/config/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h3 id="安装Vim插件管理器-VimPlug"><a href="#安装Vim插件管理器-VimPlug" class="headerlink" title="安装Vim插件管理器 VimPlug"></a><strong>安装Vim插件管理器 VimPlug</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br></code></pre></td></tr></table></figure><h3 id="配置-vimrc"><a href="#配置-vimrc" class="headerlink" title="配置 ~&#x2F;.vimrc"></a><strong>配置 ~&#x2F;.vimrc</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">call plug#begin()<br><br>Plug <span class="hljs-string">&#x27;scrooloose/nerdtree&#x27;</span><br>noremap &lt;leader&gt;t :NERDTreeToggle&lt;CR&gt;<br>autocmd VimEnter * wincmd p<br>autocmd BufEnter * <span class="hljs-keyword">if</span> 0 == len(filter(range(1, winnr(<span class="hljs-string">&#x27;$&#x27;</span>)), <span class="hljs-string">&#x27;empty(getbufvar(winbufnr(v:val), &quot;&amp;bt&quot;))&#x27;</span>)) | qa! | endif<br><span class="hljs-built_in">let</span> NERDTreeWinSize=25<br><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;do&#x27;</span>: &#123; -&gt; fzf#install() &#125; &#125;<br>Plug <span class="hljs-string">&#x27;junegunn/fzf.vim&#x27;</span><br>nnoremap &lt;c-p&gt; :Files&lt;CR&gt;<br>nnoremap &lt;c-g&gt; :Ag&lt;CR&gt;<br><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;~/.fzf&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>: <span class="hljs-string">&#x27;./install --all&#x27;</span> &#125;<br>Plug <span class="hljs-string">&#x27;tracyone/fzf-funky&#x27;</span>,&#123;<span class="hljs-string">&#x27;on&#x27;</span>: <span class="hljs-string">&#x27;FzfFunky&#x27;</span>&#125;<br>nnoremap &lt;Leader&gt;f :FzfFunky&lt;CR&gt;<br><br>Plug <span class="hljs-string">&#x27;majutsushi/tagbar&#x27;</span><br>nmap &lt;Leader&gt;b :TagbarToggle&lt;CR&gt;<br><span class="hljs-built_in">let</span> g:tagbar_width=30<br>autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()<br><br>call plug#end()<br><br><span class="hljs-built_in">set</span> mouse=a<br><span class="hljs-built_in">set</span> backspace=indent,eol,start<br><span class="hljs-built_in">set</span> cursorline<br><span class="hljs-built_in">set</span> autoindent    <span class="hljs-string">&quot; 在输入文本时自动缩进</span><br><span class="hljs-string">set smartindent   &quot;</span> 根据上一行的缩进进行智能缩进<br></code></pre></td></tr></table></figure><h3 id="把插件放到-vim文件夹中"><a href="#把插件放到-vim文件夹中" class="headerlink" title="把插件放到~&#x2F;.vim文件夹中"></a>把插件放到~&#x2F;.vim文件夹中</h3><p>autoload 和 plugged</p><p>执行<code>source ~/.vimrc</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ctags</title>
    <link href="/commands/ctags/"/>
    <url>/commands/ctags/</url>
    
    <content type="html"><![CDATA[<h1 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h1><p><strong>生成索引文件  <code>ctags –R .</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Ctrl + ]     跳到光标所在变量的定义处<br>Ctrl + t     返回查找或跳转，从哪里跳过来的跳回哪里，即使用了很多次 Ctrl+]，该命令也会回到最初一次的位置<br>vi –t tag   找到名为 tag 的变量的定义处<br>g + ]          列出变量的所有引用供用户选择<br>:ts         tagslist  同 g + ]<br>:tp         tagspreview 上一个tag标记文件<br>:tn         tagsnext  下一个tag标记文件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>commands</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/commands/vim_command/"/>
    <url>/commands/vim_command/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p><strong>vim打开文件：</strong></p><table><thead><tr><th>Vi 使用的选项</th><th>说明</th></tr></thead><tbody><tr><td>vim  filename</td><td>打开或新建一个文件，并将光标置于第一行的首部</td></tr><tr><td>vim   -r  filename</td><td>恢复上次 vim 打开时崩溃的文件</td></tr><tr><td>vim  -R  filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>vim  +  filename</td><td>打开文件，并将光标置于最后一行的首部</td></tr><tr><td>vim  +n  filename</td><td>打开文件，并将光标置于第 n 行的首部</td></tr><tr><td>vim  +&#x2F;pattern  filename</td><td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td></tr><tr><td>vim  -c command  filename</td><td>在对文件进行编辑前，先执行指定的命令</td></tr></tbody></table><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>gg</th><th>移动到首行</th></tr></thead><tbody><tr><td>G</td><td>移动到尾行</td></tr><tr><td>^或_</td><td>移动到行首第一个非空字符</td></tr><tr><td>g_</td><td>移动到行尾最后一个非空字符</td></tr><tr><td>end或者g</td><td>动到行尾最后一个字符</td></tr><tr><td>b&#x2F;B</td><td>光标向前移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>w&#x2F;W</td><td>光标向后移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>e&#x2F;E</td><td>移到单词结尾（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>数字+G</td><td>快速将光标移动到指定行</td></tr><tr><td>H</td><td>移动到屏幕顶部</td></tr><tr><td>M</td><td>移动到屏幕中间</td></tr><tr><td>L</td><td>移动到屏幕尾部</td></tr><tr><td>z+Enter</td><td>当前行在屏幕顶部</td></tr><tr><td>)</td><td>向前移动一个句子</td></tr><tr><td>(</td><td>向后移动一个句子</td></tr><tr><td>}</td><td>向前移动一个段落</td></tr><tr><td>{</td><td>向前移动一个段落</td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th>x</th><th>删除光标所在位置的字符</th></tr></thead><tbody><tr><td>X</td><td>删除光标前一个字符</td></tr><tr><td>dd</td><td>删除光标所在行，删除之后，下一行上移</td></tr><tr><td>D</td><td>删除光标位置到行尾的内容，删除之后，下一行不上移</td></tr></tbody></table><h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><table><thead><tr><th>~</th><th>转换大小写</th></tr></thead><tbody><tr><td>u</td><td>变成小写</td></tr><tr><td>U</td><td>变成大写</td></tr></tbody></table><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><table><thead><tr><th>r</th><th>替换光标所在位置的字符</th></tr></thead><tbody><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td>:s&#x2F;a1&#x2F;a2</td><td>替换当前光标所在行第一处符合条件的内容</td></tr><tr><td>:s&#x2F;a1&#x2F;a2&#x2F;g</td><td>替换当前光标所在行所有的 a1 都用 a2 替换</td></tr><tr><td>:%s&#x2F;a1&#x2F;a2</td><td>替换所有行中，第一处符合条件的内容</td></tr><tr><td>:%s&#x2F;a1&#x2F;a2&#x2F;g</td><td>替换所有行中，所有符合条件的内容</td></tr><tr><td>:n1,n2 s&#x2F;a1&#x2F;a2</td><td>将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换</td></tr><tr><td>:n1,n2 s&#x2F;a1&#x2F;a2&#x2F;g</td><td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td></tr></tbody></table><h3 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a><strong>文件切换</strong></h3><table><thead><tr><th>:files</th><th>查看当前已经打开的所有文件(%a表示激活状态，#表示上一个打开的文件)</th></tr></thead><tbody><tr><td>:open 文件名</td><td>切换到指定文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>commands</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
