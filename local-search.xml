<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内核定时器</title>
    <link href="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h2><h3 id="时间管理和内核定时器简介"><a href="#时间管理和内核定时器简介" class="headerlink" title="时间管理和内核定时器简介"></a>时间管理和内核定时器简介</h3><h4 id="内核事件管理简介"><a href="#内核事件管理简介" class="headerlink" title="内核事件管理简介"></a>内核事件管理简介</h4><p>Linux 内核中有大量的函数需要时间管理，比如周期性的调度程序、延时程序、对于我们驱动编写者来说最常用的定时器。硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率，也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz，我们在编译 Linux 内核的时候可以通过图形化界面设置系统节拍率，按照如下路径打开配置界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs te">-&gt; Kernel Features <br>-&gt; Timer frequency (&lt;choice&gt; [=y])<br></code></pre></td></tr></table></figure><img src="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/a.png" class="" title="a"><p>从图中可以看出，可选的系统节拍率为 100Hz、250Hz、300Hz、1000Hz，设置好以后打开 Linux 内核源码根目录下的.config 文件，在此文件中有相关定义：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">CONFIG<span class="hljs-built_in">_</span>HZ=250<br></code></pre></td></tr></table></figure><p>大多数初学者看到系统节拍率默认为 100Hz 的时候都会有疑问，怎么这么小？100Hz 是可选的节拍率里面最小的。为什么不选择大一点的呢？这里就引出了一个问题：高节拍率和低节拍率的优缺点：</p><p>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。</p><p>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率，本教程我们全部采用默认的 100Hz 系统节拍率。</p><p>Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0，jiffies 定义在文件 include&#x2F;linux&#x2F;jiffies.h 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 50.1.1.2 include/jiffies.h 文件代码段</span><br><span class="hljs-number">76</span> <span class="hljs-keyword">extern</span> u64 __jiffy_data jiffies_64;<br><span class="hljs-number">77</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-keyword">volatile</span> __jiffy_data jiffies;<br></code></pre></td></tr></table></figure><p>jiffies_64 和 jiffies 其实是同一个东西，jiffies_64 用于 64 位系统，而 jiffies 用于 32 位系统。为了兼容不同的硬件，jiffies 其实就是 jiffies_64 的低 32 位，jiffies_64 和 jiffies 的结构如图50.1.1.3 所示：</p><img src="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/b.png" class="" title="b"><p>当我们访问 jiffies 的时候其实访问的是 jiffies_64 的低 32 位，使用 get_jiffies_64 这个函数可以获取 jiffies_64 的值。在 32 位的系统上读取 jiffies 的值，在 64 位的系统上 jiffes 和 jiffies_64表示同一个变量，因此也可以直接读取 jiffies 的值。所以不管是 32 位的系统还是 64 位系统，都可以使用 jiffies。</p><p>前面说了 HZ 表示每秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 <strong>jiffies&#x2F;HZ 就是系统运行时间，单位为秒</strong>。不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 位的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。处理 32 位 jiffies 的绕回显得尤为重要，Linux 内核提供了如表 50.1.1.1 所示的几个 API 函数来处理绕回。</p><img src="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/c.png" class="" title="c"><p>如果 unkown 超过 known 的话，time_after 函数返回真，否则返回假。如果 unkown 没有超过 known 的话 time_before 函数返回真，否则返回假。time_after_eq 函数和 time_after 函数类似，只是多了判断等于这个条件。同理，time_before_eq 函数和 time_before 函数也类似。比如我们要判断某段代码执行时间有没有超时，此时就可以使用如下所示代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 50.1.1.3 使用 jiffies 判断超时</span><br><span class="hljs-number">1</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout;<br><span class="hljs-number">2</span>  timeout = jiffies + (<span class="hljs-number">2</span> * HZ); <span class="hljs-comment">/* 超时的时间点 */</span><br><span class="hljs-number">3</span> <br><span class="hljs-number">4</span>  <span class="hljs-comment">/*************************************</span><br><span class="hljs-comment">5  具体的代码</span><br><span class="hljs-comment">6  ************************************/</span><br><span class="hljs-number">7</span>  <br><span class="hljs-number">8</span>  <span class="hljs-comment">/* 判断有没有超时 */</span><br><span class="hljs-number">9</span>  <span class="hljs-keyword">if</span>(time_before(jiffies, timeout)) &#123;<br><span class="hljs-number">10</span> <span class="hljs-comment">/* 超时未发生 */</span><br><span class="hljs-number">11</span> &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">12</span> <span class="hljs-comment">/* 超时发生 */</span><br><span class="hljs-number">13</span> &#125;<br></code></pre></td></tr></table></figure><p>timeout 就是超时时间点，比如我们要判断代码执行时间是不是超过了 2 秒，那么超时时间点就是 jiffies+(2*HZ)，如果 jiffies 大于 timeout 那就表示超时了，否则就是没有超时。第 4-6 行就是具体的代码段。第 9 行通过函数 time_before 来判断 jiffies 是否小于 timeout，如果小于的话就表示没有超时。</p><p>为了方便开发，Linux 内核提供了几个 jiffies 和 ms、us、ns 之间的转换函数，如表 50.1.1.2所示：</p><img src="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/d.png" class="" title="d"><h4 id="内核定时器简介"><a href="#内核定时器简介" class="headerlink" title="内核定时器简介"></a>内核定时器简介</h4><p>定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。Linux 内核定时器采用系统时钟来实现，并不是我们在裸机篇中讲解的 PIT 等硬件定时器。Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，和我们使用硬件定时器的套路一样，只是使用内核定时器不需要做一大堆的寄存器初始化工作。在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。Linux 内核使用 timer_list 结构体表示内核定时器，timer_list 定义在文件include&#x2F;linux&#x2F;timer.h 中，定义如下(省略掉条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 50.1.2.1 timer_list 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires; <span class="hljs-comment">/* 定时器超时时间，单位是节拍数 */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tvec_base</span> *<span class="hljs-title">base</span>;</span><br> <span class="hljs-type">void</span> (*function)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* 定时处理函数 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data; <span class="hljs-comment">/* 要传递给 function 函数的参数 */</span><br> <span class="hljs-type">int</span> slack;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要使用内核定时器首先要先定义一个 timer_list 变量，表示定时器，tiemr_list 结构体的expires 成员变量表示超时时间，单位为节拍数。比如我们现在需要定义一个周期为 2 秒的定时器，那么这个定时器的超时时间就是 jiffies+(2<em>HZ)，因此expires&#x3D;jiffies+(2</em>HZ)。function 就是定时器超时以后的定时处理函数，我们要做的工作就放到这个函数里面，需要我们编写这个定时处理函数。</p><p>定义好定时器以后还需要通过一系列的 API 函数来初始化此定时器，这些函数如下：</p><h5 id="init-timer-函数"><a href="#init-timer-函数" class="headerlink" title="init_timer 函数"></a>init_timer 函数</h5><p>init_timer 函数负责初始化 timer_list 类型变量，当我们定义了一个 timer_list 变量以后一定要先用 init_timer 初始化一下。init_timer 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>timer</strong>：要初始化定时器。</p><p><strong>返回值：</strong>没有返回值。</p><h5 id="add-timer-函数"><a href="#add-timer-函数" class="headerlink" title="add_timer 函数"></a>add_timer 函数</h5><p>add_timer 函数用于向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>timer</strong>：要注册的定时器。</p><p><strong>返回值：</strong>没有返回值。</p><h5 id="del-timer-函数"><a href="#del-timer-函数" class="headerlink" title="del_timer 函数"></a>del_timer 函数</h5><p>del_timer 函数用于删除一个定时器，不管定时器有没有被激活，都可以使用此函数删除。<strong>在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出</strong>。del_timer 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">del_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list * timer)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>timer</strong>：要删除的定时器。</p><p><strong>返回值：</strong>0，定时器还没被激活；1，定时器已经激活。</p><h5 id="del-timer-sync-函数"><a href="#del-timer-sync-函数" class="headerlink" title="del_timer_sync 函数"></a>del_timer_sync 函数</h5><p>del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，<strong>del_timer_sync 不能使用在中断上下文中</strong>。del_timer_sync 函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">del_timer_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>timer</strong>：要删除的定时器。</p><p><strong>返回值：</strong>0，定时器还没被激活；1，定时器已经激活。</p><h5 id="mod-timer-函数"><a href="#mod-timer-函数" class="headerlink" title="mod_timer 函数"></a>mod_timer 函数</h5><p>mod_timer 函数用于修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器！函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mod_timer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timer_list *timer, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>timer</strong>：要修改超时时间(定时值)的定时器。</p><p><strong>expires</strong>：修改后的超时时间。</p><p><strong>返回值：</strong>0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已被激活。</p><p>关于内核定时器常用的 API 函数就讲这些，内核定时器一般的使用流程如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 50.1.2.2 内核定时器使用方法演示</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">timer</span>;</span> <span class="hljs-comment">/* 定义定时器 */</span><br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-comment">/* 定时器回调函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>5 &#123; <br><span class="hljs-number">6</span> <span class="hljs-comment">/* </span><br><span class="hljs-comment">7 * 定时器处理代码</span><br><span class="hljs-comment">8 */</span><br><span class="hljs-number">9</span> <br><span class="hljs-number">10</span> <span class="hljs-comment">/* 如果需要定时器周期性运行的话就使用 mod_timer</span><br><span class="hljs-comment">11 * 函数重新设置超时值并且启动定时器。</span><br><span class="hljs-comment">12 */</span><br><span class="hljs-number">13</span> mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(<span class="hljs-number">2000</span>));<br><span class="hljs-number">14</span> &#125;<br><span class="hljs-number">15</span><br><span class="hljs-number">16</span> <span class="hljs-comment">/* 初始化函数 */</span><br><span class="hljs-number">17</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>18 &#123;<br><span class="hljs-number">19</span> init_timer(&amp;timer); <span class="hljs-comment">/* 初始化定时器 */</span><br><span class="hljs-number">20</span><br><span class="hljs-number">21</span> timer.function = function; <span class="hljs-comment">/* 设置定时处理函数 */</span><br><span class="hljs-number">22</span> timer.expires=jffies + msecs_to_jiffies(<span class="hljs-number">2000</span>);<span class="hljs-comment">/* 超时时间 2 秒 */</span><br><span class="hljs-number">23</span> timer.data = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)&amp;dev; <span class="hljs-comment">/* 将设备结构体作为参数 */</span><br><span class="hljs-number">24</span> <br><span class="hljs-number">25</span> add_timer(&amp;timer); <span class="hljs-comment">/* 启动定时器 */</span><br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span><br><span class="hljs-number">28</span> <span class="hljs-comment">/* 退出函数 */</span><br><span class="hljs-number">29</span> <span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>30 &#123;<br><span class="hljs-number">31</span> del_timer(&amp;timer); <span class="hljs-comment">/* 删除定时器 */</span><br><span class="hljs-number">32</span> <span class="hljs-comment">/* 或者使用 */</span><br><span class="hljs-number">33</span> del_timer_sync(&amp;timer);<br><span class="hljs-number">34</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="内核短延时函数"><a href="#内核短延时函数" class="headerlink" title="内核短延时函数"></a>内核短延时函数</h4><p>有时候我们需要在内核中实现短延时，尤其是在 Linux 驱动中。Linux 内核提供了毫秒、微秒和纳秒延时函数，这三个函数如表 50.1.3.1 所示：</p><img src="/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/e.png" class="" title="e"><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>定时器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定时器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符设备驱动</title>
    <link href="/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。<br>在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的，Linux 应用程序对驱动程序的调用如图 40.1.1 所示：</p><img src="/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/a.png" class="" title="a"><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。比如现在有个叫做&#x2F;dev&#x2F;led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件&#x2F;dev&#x2F;led，使用完成以后使用 close 函数关闭&#x2F;dev&#x2F;led 这个文件。open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。</p><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如图 40.1.2 所示：</p><img src="/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/b.png" class="" title="b"><p>其中关于 C 库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include&#x2F;linux&#x2F;fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.1</span><span class="hljs-number">.1</span> file_operations 结构体<br><span class="hljs-number">1588</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-number">1589</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-number">1590</span>    <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-number">1591</span>    <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-number">1592</span>    <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-number">1593</span>    <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-number">1594</span>    <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-number">1595</span>    <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-number">1596</span>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br><span class="hljs-number">1597</span>    <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-number">1598</span>    <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-number">1599</span>    <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-number">1600</span>    <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-number">1601</span>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1602</span>    <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-number">1603</span>    <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1604</span>    <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-number">1605</span>    <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br><span class="hljs-number">1606</span>    <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br><span class="hljs-number">1607</span>    <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-number">1608</span>    <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-number">1609</span>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-number">1610</span>    <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-number">1611</span>    <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-number">1612</span>    <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-number">1613</span>    <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-number">1614</span>    <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-number">1615</span>    <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br><span class="hljs-number">1616</span>    <span class="hljs-type">loff_t</span> len);<br><span class="hljs-number">1617</span>    <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-number">1618</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-number">1619</span>    <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-number">1620</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">1621</span> &#125;;<br></code></pre></td></tr></table></figure><p>简单介绍一下 file_operation 结构体中比较重要的、常用的函数：</p><p>第 1589 行，owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。</p><p>第 1590 行，llseek 函数用于修改文件当前的读写位置。</p><p>第 1591 行，read 函数用于读取设备文件。</p><p>第 1592 行，write 函数用于向设备文件写入(发送)数据。</p><p>第 1596 行，poll 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。</p><p>第 1597 行，unlocked_ioctl 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。</p><p>第 1598 行，compat_ioctl 函数与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。</p><p>第 1599 行，mmap 函数用于将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。</p><p>第 1601 行，open 函数用于打开设备文件。</p><p>第 1603 行，release 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。</p><p>第 1604 行，fasync 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。</p><p>第 1605 行，aio_fsync 函数与 fasync 函数的功能类似，只是 aio_fsync 是异步刷新待处理的数据。</p><p>在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、release、write、read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。</p><h3 id="字符设备驱动开发步骤"><a href="#字符设备驱动开发步骤" class="headerlink" title="字符设备驱动开发步骤"></a>字符设备驱动开发步骤</h3><h4 id="驱动模块的加载和卸载"><a href="#驱动模块的加载和卸载" class="headerlink" title="驱动模块的加载和卸载"></a>驱动模块的加载和卸载</h4><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。总之，将驱动编译为模块最大的好处就是方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进Linux 内核中，当然也可以不编译进 Linux 内核中，具体看自己的需求。</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">module_init(xxx_init); <br><span class="hljs-comment">//注册模块加载函数</span><br>module_exit(xxx_exit); <br><span class="hljs-comment">//注册模块卸载函数</span><br></code></pre></td></tr></table></figure><p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。字符设备驱动模块加载和卸载模板如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.2</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> 字符设备驱动模块加载和卸载函数模板<br><span class="hljs-number">1</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>3 &#123;<br><span class="hljs-number">4</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>10 &#123;<br><span class="hljs-number">11</span> <span class="hljs-comment">/* 出口函数具体内容 */</span><br><span class="hljs-number">12</span> &#125;<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">15</span> module_init(xxx_init);<br><span class="hljs-number">16</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>第 2 行，定义了个名为 xxx_init 的驱动入口函数，并且使用了“__init”来修饰。</p><p>第 9 行，定义了个名为 xxx_exit 的驱动出口函数，并且使用了“__exit”来修饰。</p><p>第 15 行，调用函数 module_init 来声明 xxx_init 为驱动入口函数，当加载驱动的时候 xxx_init函数就会被调用。</p><p>第16行，调用函数module_exit来声明xxx_exit为驱动出口函数，当卸载驱动的时候xxx_exit函数就会被调用。</p><p>驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：insmod和modprobe，insmod是最简单的模块加载命令，此命令用于加载指定的.ko 模块，比如加载 drv.ko 这个驱动模块，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">insmod drv.ko<br></code></pre></td></tr></table></figure><p>insmod 命令不能解决模块的依赖关系，比如 drv.ko 依赖 first.ko 这个模块，就必须先使用insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。但是 modprobe 就不会存在这个问题，modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，因此modprobe 命令相比 insmod 要智能一些。modprobe 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能，推荐使用 modprobe 命令来加载驱动。modprobe 命令默认会去&#x2F;lib&#x2F;modules&#x2F;<kernel-version>目录中查找模块，比如本书使用的 Linux kernel 的版本号为 4.1.15，因此 modprobe 命令默认会到&#x2F;lib&#x2F;modules&#x2F;4.1.15 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。</p><p>驱动模块的卸载使用命令“rmmod”即可，比如要卸载 drv.ko，使用如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmmod drv.ko<br></code></pre></td></tr></table></figure><p>也可以使用“modprobe -r”命令卸载驱动，比如要卸载 drv.ko，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">modprobe -r drv.ko<br></code></pre></td></tr></table></figure><p>使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。所以对于模块的卸载，还是推荐使用 rmmod 命令。</p><h4 id="字符设备的注册与注销"><a href="#字符设备的注册与注销" class="headerlink" title="字符设备的注册与注销"></a>字符设备的注册与注销</h4><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure><p>register_chrdev 函数用于注册字符设备，此函数一共有三个参数，这三个参数的含义如下：</p><p><strong>major</strong>：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。</p><p><strong>name</strong>：设备名字，指向一串字符串。</p><p><strong>fops</strong>：结构体 file_operations 类型指针，指向设备的操作函数集合变量。</p><p>unregister_chrdev 函数用户注销字符设备，此函数有两个参数，这两个参数含义如下：</p><p><strong>major</strong>：要注销的设备对应的主设备号。</p><p><strong>name</strong>：要注销的设备对应的设备名。</p><p>一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块的出口函数 xxx_exit 中进行。在示例代码 40.2.2.1 中字符设备的注册和注销，内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">40.2</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span> 加入字符设备注册和注销<br><span class="hljs-number">1</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span>;</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>5 &#123;<br><span class="hljs-number">6</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">7</span> <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">10</span> retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br><span class="hljs-number">11</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-number">12</span> <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">15</span> &#125;<br><span class="hljs-number">16</span><br><span class="hljs-number">17</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">18</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>19 &#123;<br><span class="hljs-number">20</span> <span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-number">21</span> unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br><span class="hljs-number">22</span> &#125;<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">25</span> module_init(xxx_init);<br><span class="hljs-number">26</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>第 1 行，定义了一个 file_operations 结构体变量 test_fops，test_fops 就是设备的操作函数集合，只是此时我们还没有初始化 test_fops 中的 open、release 等这些成员变量，所以这个操作函数集合还是空的。</p><p>第 10 行，调用函数 register_chrdev 注册字符设备，主设备号为 200，设备名字为“chrtest”，设备操作函数集合就是第 1 行定义的 test_fops。要注意的一点就是，选择没有被使用的主设备号，输入命令“cat &#x2F;proc&#x2F;devices”可以查看当前已经被使用掉的设备号，如图所示(限于篇幅原因，只展示一部分)：</p><img src="/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/c.png" class="" title="c"><p>在图中可以列出当前系统中所有的字符设备和块设备，其中第 1 列就是设备对应的主设备号。200 这个主设备号在我的开发板中并没有被使用，所以我这里就用了 200 这个主设备号。</p><p>第 21 行，调用函数 unregister_chrdev 注销主设备号为 200 的这个设备。</p><h4 id="实现设备的具体操作函数"><a href="#实现设备的具体操作函数" class="headerlink" title="实现设备的具体操作函数"></a>实现设备的具体操作函数</h4><p>file_operations 结构体就是设备的具体操作函数，在示例代码 40.2.2.1 中我们定义了file_operations结构体类型的变量test_fops，但是还没对其进行初始化，也就是初始化其中的open、release、read 和 write 等具体的设备操作函数。本小节我们就完成变量 test_fops 的初始化，设置好针对 chrtest 设备的操作函数。在初始化 test_fops 之前我们要分析一下需求，也就是要对 chrtest这个设备进行哪些操作，只有确定了需求以后才知道我们应该实现哪些操作函数。假设对 chrtest这个设备有如下两个要求：</p><p><strong>1、能够对 chrtest 进行打开和关闭操作</strong></p><p>设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此我们需要实现 file_operations 中的 open 和 release 这两个函数。</p><p><strong>2、对 chrtest 进行读写操作</strong></p><p>假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。</p><p>需求很清晰了，修改示例代码 40.2.2.1，在其中加入 test_fops 这个结构体变量的初始化操作，完成以后的内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.2.3.1 加入设备操作函数</span><br><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>3 &#123;<br><span class="hljs-number">4</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> <span class="hljs-comment">/* 从设备读取 */</span><br><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>10 &#123;<br><span class="hljs-number">11</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 向设备写数据 */</span><br><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">chrtest_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>17 &#123;<br><span class="hljs-number">18</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">19</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span> <span class="hljs-comment">/* 关闭/释放设备 */</span><br><span class="hljs-number">23</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>24 &#123;<br><span class="hljs-number">25</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">26</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">27</span> &#125;<br><span class="hljs-number">28</span><br><span class="hljs-number">29</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">30</span> .owner = THIS_MODULE, <br><span class="hljs-number">31</span> .open = chrtest_open,<br><span class="hljs-number">32</span> .read = chrtest_read,<br><span class="hljs-number">33</span> .write = chrtest_write,<br><span class="hljs-number">34</span> .release = chrtest_release,<br><span class="hljs-number">35</span> &#125;;<br><span class="hljs-number">36</span><br><span class="hljs-number">37</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>39 &#123;<br><span class="hljs-number">40</span> <span class="hljs-comment">/* 入口函数具体内容 */</span><br><span class="hljs-number">41</span> <span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><span class="hljs-number">42</span><br><span class="hljs-number">43</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">44</span> retvalue = register_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>, &amp;test_fops);<br><span class="hljs-number">45</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-number">46</span> <span class="hljs-comment">/* 字符设备注册失败,自行处理 */</span><br><span class="hljs-number">47</span> &#125;<br><span class="hljs-number">48</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">49</span> &#125;<br><span class="hljs-number">50</span><br><span class="hljs-number">51</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">52</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>53 &#123;<br><span class="hljs-number">54</span> <span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-number">55</span> unregister_chrdev(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;chrtest&quot;</span>);<br><span class="hljs-number">56</span> &#125;<br><span class="hljs-number">57</span><br><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">59</span> module_init(xxx_init);<br><span class="hljs-number">60</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>在示例代码 40.2.3.1 中我们一开始编写了四个函数：chrtest_open、chrtest_read、chrtest_write和 chrtest_release。这四个函数就是 chrtest 设备的 open、read、write 和 release 操作函数。第 29行~35 行初始化 test_fops 的 open、read、write 和 release 这四个成员变量。</p><h4 id="添加LICENSE和作者信息"><a href="#添加LICENSE和作者信息" class="headerlink" title="添加LICENSE和作者信息"></a>添加LICENSE和作者信息</h4><p>最后我们需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用如下两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MODULE_LICENSE() <span class="hljs-comment">//添加模块 LICENSE 信息</span><br>MODULE_AUTHOR() <span class="hljs-comment">//添加模块作者信息</span><br></code></pre></td></tr></table></figure><p>最后给示例代码 40.2.3.1 加入 LICENSE 和作者信息，完成以后的内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.2.4.1 字符设备驱动最终的模板</span><br><span class="hljs-number">1</span> <span class="hljs-comment">/* 打开设备 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrtest_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>3 &#123;<br><span class="hljs-number">4</span> <span class="hljs-comment">/* 用户实现具体功能 */</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br>......<br><span class="hljs-number">57</span><br><span class="hljs-number">58</span> <span class="hljs-comment">/* 将上面两个函数指定为驱动的入口和出口函数 */</span><br><span class="hljs-number">59</span> module_init(xxx_init);<br><span class="hljs-number">60</span> module_exit(xxx_exit);<br><span class="hljs-number">61</span><br><span class="hljs-number">62</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-number">63</span> MODULE_AUTHOR(<span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Linux-设备号"><a href="#Linux-设备号" class="headerlink" title="Linux 设备号"></a>Linux 设备号</h3><h4 id="设备号的组成"><a href="#设备号的组成" class="headerlink" title="设备号的组成"></a>设备号的组成</h4><p>为了方便管理，Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。Linux 提供了一个名为 dev_t 的数据类型表示设备号，dev_t 定义在文件 include&#x2F;linux&#x2F;types.h 里面，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.1 设备号 dev_t</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">typedef</span> __u32 <span class="hljs-type">__kernel_dev_t</span>;<br>......<br><span class="hljs-number">15</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">__kernel_dev_t</span> <span class="hljs-type">dev_t</span>;<br></code></pre></td></tr></table></figure><p>可以看出 dev_t 是<code>__u32</code> 类型的，而 __u32 定义在文件 include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h 里面，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.2 __u32 类型</span><br><span class="hljs-number">26</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __u32;<br></code></pre></td></tr></table></figure><p>综上所述，dev_t 其实就是 unsigned int 类型，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号。因此 Linux系统中主设备号范围为 0~4095，所以大家在选择主设备号的时候一定不要超过这个范围。在文件 include&#x2F;linux&#x2F;kdev_t.h 中提供了几个关于设备号的操作函数(本质是宏)，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 40.3.3 设备号操作函数</span><br><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORBITS 20</span><br><span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORMASK ((1U &lt;&lt; MINORBITS) - 1)</span><br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))</span><br></code></pre></td></tr></table></figure><p>第 6 行，宏 MINORBITS 表示次设备号位数，一共是 20 位。</p><p>第 7 行，宏 MINORMASK 表示次设备号掩码。</p><p>第 9 行，宏 MAJOR 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。</p><p>第 10 行，宏 MINOR 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可。</p><p>第 11 行，宏 MKDEV 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。</p><h4 id="设备号的分配"><a href="#设备号的分配" class="headerlink" title="设备号的分配"></a>设备号的分配</h4><h5 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h5><p>本小节讲的设备号分配主要是主设备号的分配。前面讲解字符设备驱动的时候说过了，注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，使用“cat &#x2F;proc&#x2F;devices”命令即可查看当前系统中所有已经使用了的设备号。</p><h5 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h5><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题，Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure><p>函数 alloc_chrdev_region 用于申请设备号，此函数有 4 个参数：</p><p><strong>dev：</strong>保存申请到的设备号。</p><p><strong>baseminor：</strong>次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。</p><p><strong>count：</strong>要申请的设备号数量。</p><p><strong>name：</strong>设备名字。</p><p>注销字符设备之后要释放掉设备号，设备号释放函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure><p>此函数有两个参数：</p><p><strong>from：</strong>要释放的设备号。</p><p><strong>count：</strong>表示从 from 开始，要释放的设备号数量。</p><h2 id="新字符设备驱动"><a href="#新字符设备驱动" class="headerlink" title="新字符设备驱动"></a>新字符设备驱动</h2><p>字符设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备的时候就使用unregister_chrdev 函数注销字符设备，驱动模块加载成功以后还需要手动使用 mknod 命令创建设备节点。register_chrdev 和 unregister_chrdev 这两个函数是老版本驱动使用的函数，现在新的字符设备驱动已经不再使用这两个函数，而是使用Linux内核推荐的新字符设备驱动API函数。本节我们就来学习一下如何编写新字符设备驱动，并且在驱动模块加载的时候自动创建设备节点文件。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h4><p>使用 register_chrdev 函数注册字符设备的时候只需要给定一个主设备号即可，但是这样会带来两个问题：</p><p>①、需要我们事先确定好哪些主设备号没有使用。</p><p>②、会将一个主设备号下的所有次设备号都使用掉，比如现在设置 LED 这个主设备号为200，那么 0~1048575(2^20-1)这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。</p><p>解决这两个问题最好的方法就是要使用设备号的时候向 Linux 内核申请，需要几个就申请几个，由 Linux 内核分配设备可以使用的设备号。这个就是我们在 40.3.2 小节讲解的设备号的分配，如果没有指定设备号的话就使用如下函数来申请设备号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure><p>如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure><p>参数 from 是要申请的起始设备号，也就是给定的设备号；参数 count 是要申请的数量，一般都是一个；参数 name 是设备名字。</p><p>注销字符设备之后要释放掉设备号 ， 不管是通过 alloc_chrdev_region 函数还是register_chrdev_region 函数申请的设备号，统一使用如下释放函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure><p>新字符设备驱动下，设备号分配示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.1.1 新字符设备驱动下设备号分配</span><br><span class="hljs-number">1</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">4</span> <br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> (major) &#123; <span class="hljs-comment">/* 定义了主设备号 */</span><br><span class="hljs-number">6</span> devid = MKDEV(major, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 大部分驱动次设备号都选择 0*/</span><br><span class="hljs-number">7</span> register_chrdev_region(devid, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-number">8</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 没有定义设备号 */</span><br><span class="hljs-number">9</span> alloc_chrdev_region(&amp;devid, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">/* 申请设备号 */</span><br><span class="hljs-number">10</span> major = MAJOR(devid); <span class="hljs-comment">/* 获取分配号的主设备号 */</span><br><span class="hljs-number">11</span> minor = MINOR(devid); <span class="hljs-comment">/* 获取分配号的次设备号 */</span><br><span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure><p>第 1-3 行，定义了主&#x2F;次设备号变量 major 和 minor，以及设备号变量 devid。</p><p>第 5 行，判断主设备号 major 是否有效，在 Linux 驱动中一般给出主设备号的话就表示这个设备的设备号已经确定了，因为次设备号基本上都选择 0，这算个 Linux 驱动开发中约定俗成的一种规定了。</p><p>第 6 行，如果 major 有效的话就使用 MKDEV 来构建设备号，次设备号选择 0。</p><p>第 7 行，使用 register_chrdev_region 函数来注册设备号。</p><p>第 9-11 行，如果 major 无效，那就表示没有给定设备号。此时就要使用 alloc_chrdev_region函数来申请设备号。设备号申请成功以后使用 MAJOR 和 MINOR 来提取出主设备号和次设备号，当然了，第 10 和 11 行提取主设备号和次设备号的代码可以不要。</p><p>如果要注销设备号的话，使用如下代码即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">unregister_chrdev_region(devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 注销设备号 */</span><br></code></pre></td></tr></table></figure><p>注销设备号的代码很简单。</p><h4 id="新的字符设备注册方法"><a href="#新的字符设备注册方法" class="headerlink" title="新的字符设备注册方法"></a>新的字符设备注册方法</h4><h5 id="字符设备结构"><a href="#字符设备结构" class="headerlink" title="字符设备结构"></a>字符设备结构</h5><p>在 Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.1 cdev 结构体</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><br><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-number">4</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-number">6</span> <span class="hljs-type">dev_t</span> dev;<br><span class="hljs-number">7</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;<br><span class="hljs-number">8</span> &#125;;<br></code></pre></td></tr></table></figure><p>在 cdev 中有两个重要的成员变量：ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">test_cdev</span>;</span><br></code></pre></td></tr></table></figure><h5 id="cdev-init-函数"><a href="#cdev-init-函数" class="headerlink" title="cdev_init 函数"></a>cdev_init 函数</h5><p>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *cdev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)</span><br></code></pre></td></tr></table></figure><p>参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。使用 cdev_init 函数初始化 cdev 变量的示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.2 cdev_init 函数使用示例代码</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">5</span> .owner = THIS_MODULE,<br><span class="hljs-number">6</span> <span class="hljs-comment">/* 其他具体的初始项 */</span><br><span class="hljs-number">7</span> &#125;;<br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<br><span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量 */</span><br></code></pre></td></tr></table></figure><h5 id="cdev-add-函数"><a href="#cdev-add-函数" class="headerlink" title="cdev_add 函数"></a>cdev_add 函数</h5><p>cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。cdev_add 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cdev_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">dev_t</span> dev, <span class="hljs-type">unsigned</span> count)</span><br></code></pre></td></tr></table></figure><p>参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。完善示例代码 42.1.2.2，加入 cdev_add 函数，内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.2 cdev_add 函数使用示例</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">testcdev</span>;</span><br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">4</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">test_fops</span> =</span> &#123;<br><span class="hljs-number">5</span> .owner = THIS_MODULE,<br><span class="hljs-number">6</span> <span class="hljs-comment">/* 其他具体的初始项 */</span><br><span class="hljs-number">7</span> &#125;;<br><span class="hljs-number">8</span> <br><span class="hljs-number">9</span> testcdev.owner = THIS_MODULE;<br><span class="hljs-number">10</span> cdev_init(&amp;testcdev, &amp;test_fops); <span class="hljs-comment">/* 初始化 cdev 结构体变量 */</span><br><span class="hljs-number">11</span> cdev_add(&amp;testcdev, devid, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 添加字符设备 */</span><br></code></pre></td></tr></table></figure><p>示例代码 42.1.2.2 就是新的注册字符设备代码段，Linux 内核中大量的字符设备驱动都是采用这种方法向 Linux 内核添加字符设备。如果在加上示例代码 42.1.1.1 中分配设备号的程序，那么就它们一起实现的就是函数 register_chrdev 的功能。</p><h5 id="cdev-del-函数"><a href="#cdev-del-函数" class="headerlink" title="cdev_del 函数"></a>cdev_del 函数</h5><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备，cdev_del函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p)</span><br></code></pre></td></tr></table></figure><p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.1.2.3 cdev_del 函数使用示例</span><br><span class="hljs-number">1</span> cdev_del(&amp;testcdev); <span class="hljs-comment">/* 删除 cdev */</span><br></code></pre></td></tr></table></figure><p>cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。</p><h3 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h3><p>在前面的 Linux 驱动实验中，当我们使用 modprobe 加载驱动程序以后还需要使用命令“mknod”手动创建设备节点。本节就来讲解一下如何实现自动创建设备节点，在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在&#x2F;dev 目录下创建对应的设备文件。</p><h4 id="mdev-机制"><a href="#mdev-机制" class="headerlink" title="mdev 机制"></a>mdev 机制</h4><p>udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除，udev 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在&#x2F;dev 目录下创建对应的设备节点文件,使用rmmod 命令卸载驱动模块以后就删除掉&#x2F;dev 目录下的设备节点文件。使用 busybox 构建根文件系统的时候，busybox 会创建一个 udev 的简化版本—mdev，所以在嵌入式 Linux 中我们使用mdev 来实现设备节点文件的自动创建与删除，Linux 系统中的热插拔事件也由 mdev 管理，在&#x2F;etc&#x2F;init.d&#x2F;rcS 文件中如下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug<br></code></pre></td></tr></table></figure><p>上述命令设置热插拔事件由 mdev 来管理，关于 udev 或 mdev 更加详细的工作原理这里就不详细探讨了，我们重点来学习一下如何通过 mdev 来实现设备文件节点的自动创建与删除。</p><h4 id="创建和删除类"><a href="#创建和删除类" class="headerlink" title="创建和删除类"></a>创建和删除类</h4><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类，class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。class_create 是类创建函数，class_create 是个宏定义，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.2.1.1 class_create 函数</span><br><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> class_create(owner, name) \</span><br><span class="hljs-meta">2 (&#123; \</span><br><span class="hljs-meta">3 static struct lock_class_key __key; \</span><br><span class="hljs-meta">4 __class_create(owner, name, &amp;__key); \</span><br><span class="hljs-meta">5 &#125;)</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *__<span class="hljs-title">class_create</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *<span class="hljs-title">name</span>, <span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> *<span class="hljs-title">key</span>)</span><br></code></pre></td></tr></table></figure><p>根据上述代码，将宏 class_create 展开以后内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> class *<span class="hljs-title function_">class_create</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br></code></pre></td></tr></table></figure><p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。返回值是个指向结构体 class 的指针，也就是创建的类。</p><p>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">class_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *cls)</span>;<br></code></pre></td></tr></table></figure><p>参数 cls 就是要删除的类。</p><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>上一小节创建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设备。使用 device_create 函数在类下面创建设备，device_create 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device *<span class="hljs-title function_">device_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> device *parent,<span class="hljs-type">dev_t</span> devt, <span class="hljs-type">void</span> *drvdata, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br></code></pre></td></tr></table></figure><p>device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。返回值就是创建好的设备。</p><p>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">device_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-type">dev_t</span> devt)</span><br></code></pre></td></tr></table></figure><p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p><h4 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h4><p>在驱动入口函数里面创建类和设备，在驱动出口函数里面删除类和设备，参考示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码 42.2.3.1 创建/删除类/设备参考代码</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span> <br><span class="hljs-number">2</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">3</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span> <br><span class="hljs-number">4</span> <br><span class="hljs-number">5</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">6</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>7 &#123;<br><span class="hljs-number">8</span> <span class="hljs-comment">/* 创建类 */</span><br><span class="hljs-number">9</span> <span class="hljs-class"><span class="hljs-keyword">class</span> =</span> class_create(THIS_MODULE, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">10</span> <span class="hljs-comment">/* 创建设备 */</span><br><span class="hljs-number">11</span> device = device_create(class, <span class="hljs-literal">NULL</span>, devid, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>17 &#123;<br><span class="hljs-number">18</span> <span class="hljs-comment">/* 删除设备 */</span><br><span class="hljs-number">19</span> device_destroy(newchrled.class, newchrled.devid);<br><span class="hljs-number">20</span> <span class="hljs-comment">/* 删除类 */</span><br><span class="hljs-number">21</span> class_destroy(newchrled.class);<br><span class="hljs-number">22</span> &#125;<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span> module_init(led_init);<br><span class="hljs-number">25</span> module_exit(led_exit);<br></code></pre></td></tr></table></figure><h3 id="设置文件私有数据"><a href="#设置文件私有数据" class="headerlink" title="设置文件私有数据"></a>设置文件私有数据</h3><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.3.1 变量形式的设备属性</span><br><span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br></code></pre></td></tr></table></figure><p>这样写肯定没有问题，但是这样写不专业！对于一个设备的所有属性信息我们最好将其做成一个结构体。编写驱动 open 函数的时候将设备结构体作为私有数据添加到设备文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 42.3.2 设备结构体作为私有数据</span><br><span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span>&#123;</span><br><span class="hljs-number">2</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">3</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-number">4</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-number">5</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">6</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">7</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">8</span> &#125;;<br><span class="hljs-number">9</span> <br><span class="hljs-number">10</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_dev</span> <span class="hljs-title">testdev</span>;</span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> <span class="hljs-comment">/* open 函数 */</span><br><span class="hljs-number">13</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>14 &#123;<br><span class="hljs-number">15</span> filp-&gt;private_data = &amp;testdev; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-number">16</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">17</span> &#125;<br></code></pre></td></tr></table></figure><p>在 open 函数里面设置好私有数据以后，在 write、read、close 等函数中直接读取 private_data即可得到设备结构体。</p><h3 id="实验程序"><a href="#实验程序" class="headerlink" title="实验程序"></a>实验程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码 42.5.1.1 newchrled.c 文件</span><br><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><span class="hljs-number">14</span> <br><span class="hljs-number">25</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_CNT 1 <span class="hljs-comment">/* 设备号个数 */</span></span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_NAME <span class="hljs-string">&quot;newchrled&quot;</span> <span class="hljs-comment">/* 名字 */</span></span><br><span class="hljs-number">27</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF 0 <span class="hljs-comment">/* 关灯 */</span></span><br><span class="hljs-number">28</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON 1 <span class="hljs-comment">/* 开灯 */</span></span><br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span> <span class="hljs-comment">/* 寄存器物理地址 */</span><br><span class="hljs-number">31</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE (0X020C406C) </span><br><span class="hljs-number">32</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span><br><span class="hljs-number">33</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE (0X020E02F4)</span><br><span class="hljs-number">34</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE (0X0209C000)</span><br><span class="hljs-number">35</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE (0X0209C004)</span><br><span class="hljs-number">36</span> <br><span class="hljs-number">37</span> <span class="hljs-comment">/* 映射后的寄存器虚拟地址指针 */</span><br><span class="hljs-number">38</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<br><span class="hljs-number">39</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<br><span class="hljs-number">40</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<br><span class="hljs-number">41</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<br><span class="hljs-number">42</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<br><span class="hljs-number">43</span> <br><span class="hljs-number">44</span> <span class="hljs-comment">/* newchrled 设备结构体 */</span><br><span class="hljs-number">45</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span>&#123;</span><br><span class="hljs-number">46</span> <span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">/* 设备号 */</span><br><span class="hljs-number">47</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">/* cdev */</span><br><span class="hljs-number">48</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* 类 */</span><br><span class="hljs-number">49</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">/* 设备 */</span><br><span class="hljs-number">50</span> <span class="hljs-type">int</span> major; <span class="hljs-comment">/* 主设备号 */</span><br><span class="hljs-number">51</span> <span class="hljs-type">int</span> minor; <span class="hljs-comment">/* 次设备号 */</span><br><span class="hljs-number">52</span> &#125;;<br><span class="hljs-number">53</span> <br><span class="hljs-number">54</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">newchrled_dev</span> <span class="hljs-title">newchrled</span>;</span> <span class="hljs-comment">/* led 设备 */</span><br><span class="hljs-number">55</span> <br><span class="hljs-number">56</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">57 * @description : LED 打开/关闭</span><br><span class="hljs-comment">58 * @param - sta : LEDON(0) 打开 LED，LEDOFF(1) 关闭 LED</span><br><span class="hljs-comment">59 * @return : 无</span><br><span class="hljs-comment">60 */</span><br><span class="hljs-number">61</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_switch</span><span class="hljs-params">(u8 sta)</span><br>62 &#123;<br><span class="hljs-number">63</span> u32 val = <span class="hljs-number">0</span>;<br><span class="hljs-number">64</span> <span class="hljs-keyword">if</span> (sta == LEDON) &#123;<br><span class="hljs-number">65</span> val = readl(GPIO1_DR);<br><span class="hljs-number">66</span> val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <br><span class="hljs-number">67</span> writel(val, GPIO1_DR);<br><span class="hljs-number">68</span> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF) &#123;<br><span class="hljs-number">69</span> val = readl(GPIO1_DR);<br><span class="hljs-number">70</span> val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);<br><span class="hljs-number">71</span> writel(val, GPIO1_DR);<br><span class="hljs-number">72</span> &#125; <br><span class="hljs-number">73</span> &#125;<br><span class="hljs-number">74</span> <br><span class="hljs-number">75</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">76 * @description : 打开设备</span><br><span class="hljs-comment">77 * @param – inode : 传递给驱动的 inode</span><br><span class="hljs-comment">78 * @param - filp : 设备文件，file 结构体有个叫做 private_data 的成员变量</span><br><span class="hljs-comment">79 * 一般在 open 的时候将 private_data 指向设备结构体。</span><br><span class="hljs-comment">80 * @return : 0 成功;其他 失败</span><br><span class="hljs-comment">81 */</span><br><span class="hljs-number">82</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>83 &#123;<br><span class="hljs-number">84</span> filp-&gt;private_data = &amp;newchrled; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-number">85</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">86</span> &#125;<br><span class="hljs-number">87</span> <br><span class="hljs-number">88</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">89 * @description : 从设备读取数据</span><br><span class="hljs-comment">90 * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment">91 * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment">92 * @param - cnt : 要读取的数据长度</span><br><span class="hljs-comment">93 * @param – offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment">94 * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment">95 */</span><br><span class="hljs-number">96</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>97 &#123;<br><span class="hljs-number">98</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">99</span> &#125;<br><span class="hljs-number">100</span><br><span class="hljs-number">101</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">102 * @description : 向设备写数据</span><br><span class="hljs-comment">103 * @param – filp : 设备文件，表示打开的文件描述符</span><br><span class="hljs-comment">104 * @param - buf : 要写给设备写入的数据</span><br><span class="hljs-comment">105 * @param - cnt : 要写入的数据长度</span><br><span class="hljs-comment">106 * @param – offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment">107 * @return : 写入的字节数，如果为负值，表示写入失败</span><br><span class="hljs-comment">108 */</span><br><span class="hljs-number">109</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>110 &#123;<br><span class="hljs-number">111</span> <span class="hljs-type">int</span> retvalue;<br><span class="hljs-number">112</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<br><span class="hljs-number">113</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><span class="hljs-number">114</span><br><span class="hljs-number">115</span> retvalue = copy_from_user(databuf, buf, cnt);<br><span class="hljs-number">116</span> <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">117</span> printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<br><span class="hljs-number">118</span> <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">119</span> &#125;<br><span class="hljs-number">120</span><br><span class="hljs-number">121</span> ledstat = databuf[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* 获取状态值 */</span><br><span class="hljs-number">122</span><br><span class="hljs-number">123</span> <span class="hljs-keyword">if</span>(ledstat == LEDON) &#123; <br><span class="hljs-number">124</span> led_switch(LEDON); <span class="hljs-comment">/* 打开 LED 灯 */</span><br><span class="hljs-number">125</span> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;<br><span class="hljs-number">126</span> led_switch(LEDOFF); <span class="hljs-comment">/* 关闭 LED 灯 */</span><br><span class="hljs-number">127</span> &#125;<br><span class="hljs-number">128</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">129</span> &#125;<br><span class="hljs-number">130</span><br><span class="hljs-number">131</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">132 * @description : 关闭/释放设备</span><br><span class="hljs-comment">133 * @param – filp : 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment">134 * @return : 0 成功;其他 失败</span><br><span class="hljs-comment">135 */</span><br><span class="hljs-number">136</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>137 &#123;<br><span class="hljs-number">138</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">139</span> &#125;<br><span class="hljs-number">140</span><br><span class="hljs-number">141</span> <span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-number">142</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">newchrled_fops</span> =</span> &#123;<br><span class="hljs-number">143</span> .owner = THIS_MODULE,<br><span class="hljs-number">144</span> .open = led_open,<br><span class="hljs-number">145</span> .read = led_read,<br><span class="hljs-number">146</span> .write = led_write,<br><span class="hljs-number">147</span> .release = led_release,<br><span class="hljs-number">148</span> &#125;;<br><span class="hljs-number">149</span><br><span class="hljs-number">150</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">151 * @description : 驱动入口函数</span><br><span class="hljs-comment">152 * @param : 无</span><br><span class="hljs-comment">153 * @return : 无</span><br><span class="hljs-comment">154 */</span><br><span class="hljs-number">155</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>156 &#123;<br><span class="hljs-number">157</span> u32 val = <span class="hljs-number">0</span>;<br><span class="hljs-number">158</span><br><span class="hljs-number">159</span> <span class="hljs-comment">/* 初始化 LED */</span><br><span class="hljs-number">160</span> <span class="hljs-comment">/* 1、寄存器地址映射 */</span><br><span class="hljs-number">161</span> IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">162</span> SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">163</span> SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">164</span> GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">165</span> GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="hljs-number">4</span>);<br><span class="hljs-number">166</span><br><span class="hljs-number">167</span> <span class="hljs-comment">/* 2、使能 GPIO1 时钟 */</span><br><span class="hljs-number">168</span> val = readl(IMX6U_CCM_CCGR1);<br><span class="hljs-number">169</span> val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>); <span class="hljs-comment">/* 清楚以前的设置 */</span><br><span class="hljs-number">170</span> val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>); <span class="hljs-comment">/* 设置新值 */</span><br><span class="hljs-number">171</span> writel(val, IMX6U_CCM_CCGR1);<br><span class="hljs-number">172</span><br><span class="hljs-number">173</span> <span class="hljs-comment">/* 3、设置 GPIO1_IO03 的复用功能，将其复用为</span><br><span class="hljs-comment">174 * GPIO1_IO03，最后设置 IO 属性。</span><br><span class="hljs-comment">175 */</span><br><span class="hljs-number">176</span> writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);<br><span class="hljs-number">177</span> <br><span class="hljs-number">178</span> <span class="hljs-comment">/* 寄存器 SW_PAD_GPIO1_IO03 设置 IO 属性 */</span><br><span class="hljs-number">179</span> writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<br><span class="hljs-number">180</span><br><span class="hljs-number">181</span> <span class="hljs-comment">/* 4、设置 GPIO1_IO03 为输出功能 */</span><br><span class="hljs-number">182</span> val = readl(GPIO1_GDIR);<br><span class="hljs-number">183</span> val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <span class="hljs-comment">/* 清除以前的设置 */</span><br><span class="hljs-number">184</span> val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <span class="hljs-comment">/* 设置为输出 */</span><br><span class="hljs-number">185</span> writel(val, GPIO1_GDIR);<br><span class="hljs-number">186</span><br><span class="hljs-number">187</span> <span class="hljs-comment">/* 5、默认关闭 LED */</span><br><span class="hljs-number">188</span> val = readl(GPIO1_DR);<br><span class="hljs-number">189</span> val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <br><span class="hljs-number">190</span> writel(val, GPIO1_DR);<br><span class="hljs-number">191</span><br><span class="hljs-number">192</span> <span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-number">193</span> <span class="hljs-comment">/* 1、创建设备号 */</span><br><span class="hljs-number">194</span> <span class="hljs-keyword">if</span> (newchrled.major) &#123; <span class="hljs-comment">/* 定义了设备号 */</span><br><span class="hljs-number">195</span> newchrled.devid = MKDEV(newchrled.major, <span class="hljs-number">0</span>);<br><span class="hljs-number">196</span> register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);<br><span class="hljs-number">197</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 没有定义设备号 */</span><br><span class="hljs-number">198</span> alloc_chrdev_region(&amp;newchrled.devid, <span class="hljs-number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME); <span class="hljs-comment">/* 申请设备号 */</span><br><span class="hljs-number">199</span> newchrled.major = MAJOR(newchrled.devid); <span class="hljs-comment">/* 获取主设备号 */</span><br><span class="hljs-number">200</span> newchrled.minor = MINOR(newchrled.devid); <span class="hljs-comment">/* 获取次设备号 */</span><br><span class="hljs-number">201</span> &#125;<br><span class="hljs-number">202</span> printk(<span class="hljs-string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor);<br><span class="hljs-number">203</span> <br><span class="hljs-number">204</span> <span class="hljs-comment">/* 2、初始化 cdev */</span><br><span class="hljs-number">205</span> newchrled.cdev.owner = THIS_MODULE;<br><span class="hljs-number">206</span> cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);<br><span class="hljs-number">207</span> <br><span class="hljs-number">208</span> <span class="hljs-comment">/* 3、添加一个 cdev */</span><br><span class="hljs-number">209</span> cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);<br><span class="hljs-number">210</span><br><span class="hljs-number">211</span> <span class="hljs-comment">/* 4、创建类 */</span><br><span class="hljs-number">212</span> newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME);<br><span class="hljs-number">213</span> <span class="hljs-keyword">if</span> (IS_ERR(newchrled.class)) &#123;<br><span class="hljs-number">214</span> <span class="hljs-keyword">return</span> PTR_ERR(newchrled.class);<br><span class="hljs-number">215</span> &#125;<br><span class="hljs-number">216</span><br><span class="hljs-number">217</span> <span class="hljs-comment">/* 5、创建设备 */</span><br><span class="hljs-number">218</span> newchrled.device = device_create(newchrled.class, <span class="hljs-literal">NULL</span>, newchrled.devid, <span class="hljs-literal">NULL</span>, NEWCHRLED_NAME);<br><span class="hljs-number">219</span> <span class="hljs-keyword">if</span> (IS_ERR(newchrled.device)) &#123;<br><span class="hljs-number">220</span> <span class="hljs-keyword">return</span> PTR_ERR(newchrled.device);<br><span class="hljs-number">221</span> &#125;<br><span class="hljs-number">222</span> <br><span class="hljs-number">223</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">224</span> &#125;<br><span class="hljs-number">225</span><br><span class="hljs-number">226</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">227 * @description : 驱动出口函数</span><br><span class="hljs-comment">228 * @param : 无</span><br><span class="hljs-comment">229 * @return : 无</span><br><span class="hljs-comment">230 */</span><br><span class="hljs-number">231</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>232 &#123;<br><span class="hljs-number">233</span> <span class="hljs-comment">/* 取消映射 */</span><br><span class="hljs-number">234</span> iounmap(IMX6U_CCM_CCGR1);<br><span class="hljs-number">235</span> iounmap(SW_MUX_GPIO1_IO03);<br><span class="hljs-number">236</span> iounmap(SW_PAD_GPIO1_IO03);<br><span class="hljs-number">237</span> iounmap(GPIO1_DR);<br><span class="hljs-number">238</span> iounmap(GPIO1_GDIR);<br><span class="hljs-number">239</span><br><span class="hljs-number">240</span> <span class="hljs-comment">/* 注销字符设备 */</span><br><span class="hljs-number">241</span> cdev_del(&amp;newchrled.cdev);<span class="hljs-comment">/* 删除 cdev */</span><br><span class="hljs-number">242</span> unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT);<br><span class="hljs-number">243</span><br><span class="hljs-number">244</span> device_destroy(newchrled.class, newchrled.devid);<br><span class="hljs-number">245</span> class_destroy(newchrled.class);<br><span class="hljs-number">246</span> &#125;<br><span class="hljs-number">247</span><br><span class="hljs-number">248</span> module_init(led_init);<br><span class="hljs-number">249</span> module_exit(led_exit);<br><span class="hljs-number">250</span> MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-number">251</span> MODULE_AUTHOR(<span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure><p>第 25 行，宏 NEWCHRLED_CNT 表示设备数量，在申请设备号或者向 Linux 内核添加字符设备的时候需要设置设备数量，一般我们一个驱动一个设备，所以这个宏为 1。</p><p>第 26 行，宏 NEWCHRLED_NAME 表示设备名字，本实验的设备名为“newchrdev”，为了方便管理，所有使用到设备名字的地方统一使用此宏，当驱动加载成功以后就生成&#x2F;dev&#x2F;newchrled 这个设备文件。</p><p>第 44-52 行，创建设备结构体 newchrled_dev。</p><p>第 54 行，定义一个设备结构体变量 newchrdev，此变量表示 led 设备。</p><p>第 82-86 行，在 led_open 函数中设置文件的私有数据 private_data 指向 newchrdev。</p><p>第 194-221 行，根据前面讲解的方法在驱动入口函数 led_init 中申请设备号、添加字符设备、创建类和设备。本实验我们采用动态申请设备号的方法，第 202 行使用 printk 在终端上显示出申请到的主设备号和次设备号。</p><p>第 241-245 行，根据前面讲解的方法，在驱动出口函数 led_exit 中注销字符新设备、删除类和设备。</p><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>字符设备驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符设备驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断</title>
    <link href="/%E4%B8%AD%E6%96%AD/linux%E4%B8%AD%E6%96%AD/"/>
    <url>/%E4%B8%AD%E6%96%AD/linux%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-中断"><a href="#Linux-中断" class="headerlink" title="Linux 中断"></a>Linux 中断</h2><h3 id="中断-API-函数"><a href="#中断-API-函数" class="headerlink" title="中断 API 函数"></a>中断 API 函数</h3><p>对于硬件的中断处理方法：</p><p>①、使能中断，初始化相应的寄存器。</p><p>②、注册中断服务函数，也就是向 irqTable 数组的指定标号处写入中断服务函数</p><p>②、中断发生以后进入 IRQ 中断服务函数，在 IRQ 中断服务函数在数组 irqTable 里面查找具体的中断处理函数，找到以后执行相应的中断处理函数。</p><p>在 Linux 内核中也提供了大量的中断相关的 API 函数，我们来看一下这些跟中断有关的API 函数：</p><h4 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a>中断号</h4><p>每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号。</p><h4 id="request-irq-函数"><a href="#request-irq-函数" class="headerlink" title="request_irq 函数"></a>request_irq 函数</h4><p>在 Linux 内核中要想使用某个中断是需要申请的，request_irq 函数用于申请中断，request_irq函数可能会导致睡眠，<strong>因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数</strong>。request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断，request_irq 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-type">irq_handler_t</span> handler, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *dev)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>irq</strong>：要申请中断的中断号。<br><strong>handler</strong>：中断处理函数，当中断发生以后就会执行此中断处理函数。<br><strong>flags</strong>：中断标志，可以在文件 include&#x2F;linux&#x2F;interrupt.h 里面查看所有的中断标志，这里我们介绍几个常用的中断标志，如表 51.1.1.1 所示：</p><img src="/%E4%B8%AD%E6%96%AD/linux%E4%B8%AD%E6%96%AD/a.png" class="" title="a"><p>表 51.1.1.1 中的这些标志可以通过“|”来实现多种组合。<br><strong>name</strong>：中断名字，设置以后可以在&#x2F;proc&#x2F;interrupts 文件中看到对应的中断名字。<br><strong>dev：</strong>如果将 flags 设置为 IRQF_SHARED 的话，dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体，dev 会传递给中断处理函数 irq_handler_t 的第二个参数。<br><strong>返回值：</strong>0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。</p><h4 id="free-irq-函数"><a href="#free-irq-函数" class="headerlink" title="free_irq 函数"></a>free_irq 函数</h4><p>使用中断的时候需要通过 request_irq 函数申请，使用完成以后就要通过 free_irq 函数释放掉相应的中断。如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。free_irq函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>irq：</strong>要释放的中断。<br><strong>dev</strong>：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。</p><h4 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h4><p>使用 request_irq 函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">irqreturn_t</span> (*<span class="hljs-type">irq_handler_t</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *)<br></code></pre></td></tr></table></figure><p>第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。中断处理函数的返回值为 irqreturn_t 类型，irqreturn_t 类型定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.1.1 irqreturn_t 结构</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> &#123;</span><br>IRQ_NONE = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span>),<br>IRQ_HANDLED = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>),<br>IRQ_WAKE_THREAD = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>),<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">irqreturn</span> <span class="hljs-title">irqreturn_t</span>;</span><br></code></pre></td></tr></table></figure><p>可以看出 irqreturn_t 是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> IRQ_RETVAL(IRQ_HANDLED)<br></code></pre></td></tr></table></figure><h4 id="中断使能与禁止函数"><a href="#中断使能与禁止函数" class="headerlink" title="中断使能与禁止函数"></a>中断使能与禁止函数</h4><p>常用的中断使用和禁止函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br></code></pre></td></tr></table></figure><p>enable_irq 和 disable_irq 用于使能和禁止指定的中断，irq 就是要禁止的中断号。disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用另外一个中断禁止函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">disable_irq_nosync</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br></code></pre></td></tr></table></figure><p>disable_irq_nosync 函数调用以后立即返回，不会等待当前中断处理程序执行完毕。上面三个函数都是使能或者禁止某一个中断，有时候我们需要关闭当前处理器的整个中断系统，也就是在学习 STM32 的时候常说的关闭全局中断，这个时候可以使用如下两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local_irq_enable()<br>local_irq_disable()<br></code></pre></td></tr></table></figure><p>local_irq_enable 用于使能当前处理器中断系统，local_irq_disable 用于禁止当前处理器中断系统。假如 A 任务调用 local_irq_disable 关闭全局中断 10S，当关闭了 2S 的时候 B 任务开始运行，B 任务也调用 local_irq_disable 关闭全局中断 3S，3 秒以后 B 任务调用 local_irq_enable 函数将全局中断打开了。此时才过去 2+3&#x3D;5 秒的时间，然后全局中断就被打开了，此时 A 任务要关闭 10S 全局中断的愿望就破灭了，然后 A 任务就“生气了”，结果很严重，可能系统都要被A 任务整崩溃。为了解决这个问题，B 任务不能直接简单粗暴的通过 local_irq_enable 函数来打开全局中断，而是将中断状态恢复到以前的状态，要考虑到别的任务的感受，此时就要用到下面两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local_irq_save(flags)<br>local_irq_restore(flags)<br></code></pre></td></tr></table></figure><p>这两个函数是一对，local_irq_save 函数用于禁止中断，并且将中断状态保存在 flags 中。local_irq_restore 用于恢复中断，将中断到 flags 状态。</p><h3 id="上半部与下半部"><a href="#上半部与下半部" class="headerlink" title="上半部与下半部"></a>上半部与下半部</h3><p>在有些资料中也将上半部和下半部称为顶半部和底半部，都是一个意思。我们在使用request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。我们都知道中断处理函数一定要快点执行完毕，越短越好，但是现实往往是残酷的，有些中断处理过程就是比较费时间，我们必须要对其进行处理，缩小中断处理函数的执行时间。比如电容触摸屏通过中断通知 SOC 有触摸事件发生，SOC 响应中断，然后通过 IIC 接口读取触摸坐标值并将其上报给系统。但是我们都知道 IIC 的速度最高也只有400Kbit&#x2F;S，所以在中断中通过 IIC 读取数据就会浪费时间。我们可以将通过 IIC 读取触摸数据的操作暂后执行，中断处理函数仅仅相应中断，然后清除中断标志位即可。这个时候中断处理过程就分为了两部分：</p><p>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。</p><p>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</p><p>因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断，这个就很考验驱动编写人员的功底了。这里有一些可以借鉴的参考点：</p><p>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</p><p>②、如果要处理的任务对时间敏感，可以放到上半部。</p><p>③、如果要处理的任务与硬件有关，可以放到上半部</p><p>④、除了上述三点以外的其他任务，优先考虑放到下半部。</p><p>上半部处理很简单，直接编写中断处理函数就行了，关键是下半部该怎么做呢？Linux 内核提供了多种下半部机制，接下来我们来学习一下这些下半部机制。</p><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>一开始 Linux 内核提供了“bottom half”机制来实现下半部，简称“BH”。后面引入了软中断和 tasklet 来替代“BH”机制，完全可以使用软中断和 tasklet 来替代 BH，从 2.5 版本的 Linux内核开始 BH 已经被抛弃了。Linux 内核使用结构体 softirq_action 表示软中断， softirq_action结构体定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.1 softirq_action 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 kernel&#x2F;softirq.c 文件中一共定义了 10 个软中断，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.2 softirq_vec 数组</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span><br></code></pre></td></tr></table></figure><p>NR_SOFTIRQS 是枚举类型，定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.3 softirq_vec 数组</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> HI_SOFTIRQ=<span class="hljs-number">0</span>, <span class="hljs-comment">/* 高优先级软中断 */</span><br> TIMER_SOFTIRQ, <span class="hljs-comment">/* 定时器软中断 */</span><br> NET_TX_SOFTIRQ, <span class="hljs-comment">/* 网络数据发送软中断 */</span><br> NET_RX_SOFTIRQ, <span class="hljs-comment">/* 网络数据接收软中断 */</span><br> BLOCK_SOFTIRQ, <br> BLOCK_IOPOLL_SOFTIRQ, <br> TASKLET_SOFTIRQ, <span class="hljs-comment">/* tasklet 软中断 */</span><br> SCHED_SOFTIRQ, <span class="hljs-comment">/* 调度软中断 */</span><br> HRTIMER_SOFTIRQ, <span class="hljs-comment">/* 高精度定时器软中断 */</span><br> RCU_SOFTIRQ, <span class="hljs-comment">/* RCU 软中断 */</span><br> NR_SOFTIRQS<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出，一共有 10 个软中断，因此 NR_SOFTIRQS 为 10，因此数组 softirq_vec 有 10 个元素。softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数，open_softirq 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">open_softirq</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *))</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>nr</strong>：要开启的软中断，在示例代码 51.1.2.3 中选择一个。<br><strong>action</strong>：软中断对应的处理函数。<br><strong>返回值：</strong>没有返回值。</p><p>注册好软中断以后需要通过 raise_softirq 函数触发，raise_softirq 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">raise_softirq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>nr</strong>：要触发的软中断，在示例代码 51.1.2.3 中选择一个。<br><strong>返回值：</strong>没有返回值。</p><p>软中断必须在编译的时候静态注册！Linux 内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel&#x2F;softirq.c 文件里面，函数内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.4 softirq_init 函数内容</span><br><span class="hljs-number">634</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">softirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>635 &#123;<br><span class="hljs-number">636</span> <span class="hljs-type">int</span> cpu;<br><span class="hljs-number">637</span><br><span class="hljs-number">638</span> for_each_possible_cpu(cpu) &#123;<br><span class="hljs-number">639</span> per_cpu(tasklet_vec, cpu).tail =<br><span class="hljs-number">640</span> &amp;per_cpu(tasklet_vec, cpu).head;<br><span class="hljs-number">641</span> per_cpu(tasklet_hi_vec, cpu).tail =<br><span class="hljs-number">642</span> &amp;per_cpu(tasklet_hi_vec, cpu).head;<br><span class="hljs-number">643</span> &#125;<br><span class="hljs-number">644</span><br><span class="hljs-number">645</span> open_softirq(TASKLET_SOFTIRQ, tasklet_action);<br><span class="hljs-number">646</span> open_softirq(HI_SOFTIRQ, tasklet_hi_action);<br><span class="hljs-number">647</span> &#125;<br></code></pre></td></tr></table></figure><p>从示例代码 51.1.2.4 可以看出，softirq_init 函数默认会打开 TASKLET_SOFTIRQ 和HI_SOFTIRQ。</p><h4 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h4><p>tasklet 是利用软中断来实现的另外一种下半部机制，在软中断和 tasklet 之间，建议大家使用 tasklet。Linux 内核使用 tasklet_struct 结构体来表示 tasklet：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.5 tasklet_struct 结构体</span><br><span class="hljs-number">484</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span></span><br><span class="hljs-class">485 &#123;</span><br><span class="hljs-number">486</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个 tasklet */</span><br><span class="hljs-number">487</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> state; <span class="hljs-comment">/* tasklet 状态 */</span><br><span class="hljs-number">488</span> <span class="hljs-type">atomic_t</span> count; <span class="hljs-comment">/* 计数器，记录对 tasklet 的引用数 */</span><br><span class="hljs-number">489</span> <span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* tasklet 执行的函数 */</span><br><span class="hljs-number">490</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data; <span class="hljs-comment">/* 函数 func 的参数 */</span><br><span class="hljs-number">491</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 489 行的 func 函数就是 tasklet 要执行的处理函数，用户定义函数内容，相当于中断处理函数。如果要使用 tasklet，必须先定义一个 tasklet，然后使用 tasklet_init 函数初始化 tasklet，taskled_init 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>), <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span>;<br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>t</strong>：要初始化的 tasklet<br><strong>func</strong>：tasklet 的处理函数。<br><strong>data：</strong>要传递给 func 函数的参数<br><strong>返回值：</strong>没有返回值。</p><p>也可以使用宏 DECLARE_TASKLET 来一次性完成 tasklet 的定义和初始化，DECLARE_TASKLET 定义在 include&#x2F;linux&#x2F;interrupt.h 文件中，定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">DECLARE_TASKLET(name, func, data)<br></code></pre></td></tr></table></figure><p>其中 name 为要定义的 tasklet 名字，这个名字就是一个 tasklet_struct 类型的时候变量，func就是 tasklet 的处理函数，data 是传递给 func 函数的参数。</p><p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运行，tasklet_schedule 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">tasklet_schedule</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tasklet_struct *t)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>t</strong>：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。<br><strong>返回值：</strong>没有返回值。</p><p>关于 tasklet 的参考使用示例如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.7 tasklet 使用示例</span><br><span class="hljs-comment">/* 定义 taselet */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> <span class="hljs-title">testtasklet</span>;</span><br><span class="hljs-comment">/* tasklet 处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">testtasklet_func</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data)</span><br>&#123;<br> <span class="hljs-comment">/* tasklet 具体处理内容 */</span><br>&#125;<br><span class="hljs-comment">/* 中断处理函数 */</span><br><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>&#123;<br> ......<br> <span class="hljs-comment">/* 调度 tasklet */</span><br> tasklet_schedule(&amp;testtasklet);<br> ......<br>&#125;<br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> ......<br> <span class="hljs-comment">/* 初始化 tasklet */</span><br> tasklet_init(&amp;testtasklet, testtasklet_func, data);<br> <span class="hljs-comment">/* 注册中断处理函数 */</span><br> request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);<br> ......<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。</p><p>Linux 内核使用 work_struct 结构体表示一个工作，内容如下(省略掉条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.8 work_struct 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> &#123;</span><br> <span class="hljs-type">atomic_long_t</span> data; <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span><br> <span class="hljs-type">work_func_t</span> func; <span class="hljs-comment">/* 工作队列处理函数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，内容如下(省略掉条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.9 workqueue_struct 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqs</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span> <br> <span class="hljs-type">int</span> work_color;<br> <span class="hljs-type">int</span> flush_color; <br> <span class="hljs-type">atomic_t</span> nr_pwqs_to_flush;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wq_flusher</span> *<span class="hljs-title">first_flusher</span>;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_queue</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">flusher_overflow</span>;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">maydays</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> *<span class="hljs-title">rescuer</span>;</span> <br> <span class="hljs-type">int</span> nr_drainers; <br> <span class="hljs-type">int</span> saved_max_active;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_attrs</span> *<span class="hljs-title">unbound_attrs</span>;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">dfl_pwq</span>;</span> <br> <span class="hljs-type">char</span> name[WQ_NAME_LEN];<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags ____cacheline_aligned;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_pwqs</span>;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">numa_pwq_tbl</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Linux 内核使用工作者线程(worker thread)来处理工作队列中的各个工作，Linux 内核使用worker 结构体表示工作者线程，worker 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 51.1.2.10 worker 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">entry</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hentry</span>;</span><br> &#125;;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> *<span class="hljs-title">current_work</span>;</span> <br> <span class="hljs-type">work_func_t</span> current_func; <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool_workqueue</span> *<span class="hljs-title">current_pwq</span>;</span><br> <span class="hljs-type">bool</span> desc_valid;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">scheduled</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker_pool</span> *<span class="hljs-title">pool</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span> <br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> last_active; <br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags; <br> <span class="hljs-type">int</span> id; <br> <span class="hljs-type">char</span> desc[WORKER_DESC_LEN];<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> *<span class="hljs-title">rescue_wq</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从示例代码 51.1.2.10 可以看出，每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，我们只需要定义工作(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_WORK(_work, _func)</span><br></code></pre></td></tr></table></figure><p>_work 表示要初始化的工作，_func 是工作对应的处理函数。</p><p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_WORK(n, f)</span><br></code></pre></td></tr></table></figure><p>n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</p><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">schedule_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>work：</strong>要调度的工作。<br><strong>返回值：</strong>0 成功，其他值 失败。</p><p>关于工作队列的参考使用示例如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">51.1</span><span class="hljs-number">.2</span><span class="hljs-number">.11</span> 工作队列使用示例<br><span class="hljs-comment">/* 定义工作(work) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">testwork</span>;</span><br><span class="hljs-comment">/* work 处理函数 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">testwork_func_t</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span>;<br>&#123;<br> <span class="hljs-comment">/* work 具体处理内容 */</span><br>&#125;<br><span class="hljs-comment">/* 中断处理函数 */</span><br><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">test_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>&#123;<br> ......<br> <span class="hljs-comment">/* 调度 work */</span><br> schedule_work(&amp;testwork);<br> ......<br>&#125;<br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> ......<br> <span class="hljs-comment">/* 初始化 work */</span><br> INIT_WORK(&amp;testwork, <span class="hljs-type">testwork_func_t</span>);<br> <span class="hljs-comment">/* 注册中断处理函数 */</span><br> request_irq(xxx_irq, test_handler, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;xxx&quot;</span>, &amp;xxx_dev);<br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>irq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>irq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/spi/spi/"/>
    <url>/spi/spi/</url>
    
    <content type="html"><![CDATA[<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h2><h3 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h3><p>之前我们讲解了 I2C，I2C 是串行通信的一种，只需要两根线就可以完成主机和从机之间的通信，但是 I2C 的速度最高只能到 400KHz，如果对于访问速度要求比价高的话 I2C 就不适合了。本章我们就来学习一下另外一个和 I2C 一样广泛使用的串行通信：SPI，SPI 全称是 SerialPerripheral Interface，也就是串行外围设备接口。SPI 是 Motorola 公司推出的一种同步串行接口技术，是一种高速、全双工的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。</p><h3 id="SPI-协议"><a href="#SPI-协议" class="headerlink" title="SPI 协议"></a>SPI 协议</h3><p>SPI 以主从方式工作，通常是有一个主设备和一个或多个从设备，一般 SPI 需要4 根线，但是也可以使用三根线(单向传输)，本章我们讲解标准的 4 线 SPI，这四根线如下：</p><p>①、CS&#x2F;SS，Slave Select&#x2F;Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可。</p><p>②、SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。</p><p>③、MOSI&#x2F;SDO，Master Out Slave In&#x2F;Serial Data Output，简称主出从入信号线，这根数据线只能用于主机向从机发送数据，也就是主机输出，从机输入。</p><p>④、MISO&#x2F;SDI，Master In Slave Out&#x2F;Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。</p><p>SPI 通信都是由主机发起的，主机需要提供通信的时钟信号。主机通过 SPI 线连接多个从设备的结构如图 27.1.1.1 所示：</p><img src="/spi/spi/a.png" class="" title="a"><p>SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：</p><p>①、CPOL&#x3D;0，串行时钟空闲状态为低电平。</p><p>②、CPOL&#x3D;1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。</p><p>③、CPHA&#x3D;0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。</p><p>④、CPHA&#x3D;1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。</p><p>这四种工作模式如图 27.1.1.2 所示：</p><img src="/spi/spi/b.png" class="" title="b"><p>跟 I2C 一样，SPI 也是有时序图的，以 CPOL&#x3D;0，CPHA&#x3D;0 这个工作模式为例，SPI 进行全双工通信的时序如图 27.1.1.3 所示：</p><img src="/spi/spi/c.png" class="" title="c"><p>从图 27.1.1.3 可以看出，SPI 的时序图很简单，不像 I2C 那样还要分为读时序和写时序，因为 SPI 是全双工的，所以读写时序可以一起完成。图 27.1.1.3 中，CS 片选信号先拉低，选中要通信的从设备，然后通过 MOSI 和 MISO 这两根数据线进行收发数据，MOSI 数据线发出了0XD2 这个数据给从设备，同时从设备也通过 MISO 线给主设备返回了 0X66 这个数据。这个就是 SPI 时序图。</p><h2 id="SPI-驱动框架"><a href="#SPI-驱动框架" class="headerlink" title="SPI 驱动框架"></a>SPI 驱动框架</h2><p>SPI 驱动框架和 I2C 很类似，都分为主机控制器驱动和设备驱动，主机控制器也就是 SOC的 SPI 控制器接口。同一个主机不管是什么 SPI 设备，SPI 控制器部分的驱动都是一样，我们的重点就落在了种类繁多的 SPI 设备驱动。</p><h3 id="SPI-主机驱动"><a href="#SPI-主机驱动" class="headerlink" title="SPI 主机驱动"></a>SPI 主机驱动</h3><p>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master 表示 SPI 主机驱动，spi_master 是个结构体，定义在 include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，内容如下(有缩减)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">62.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> spi_master 结构体<br><span class="hljs-number">315</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_master</span> &#123;</span><br><span class="hljs-number">316</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><br><span class="hljs-number">317</span><br><span class="hljs-number">318</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>......<br><span class="hljs-number">326</span>     s16 bus_num;<br><span class="hljs-number">327</span><br><span class="hljs-number">328</span>     <span class="hljs-comment">// chipselects will be integral to many controllers; some others</span><br><span class="hljs-number">329</span>     <span class="hljs-comment">// might use board-specific GPIOs.</span><br><span class="hljs-number">330</span>     <span class="hljs-comment">//</span><br><span class="hljs-number">331</span>     u16 num_chipselect;<br><span class="hljs-number">332</span><br><span class="hljs-number">333</span>     <span class="hljs-comment">// some SPI controllers pose alignment requirements on DMAable</span><br><span class="hljs-number">334</span>     <span class="hljs-comment">// buffers; let protocol drivers know about these requirements.</span><br><span class="hljs-number">335</span>     <span class="hljs-comment">//</span><br><span class="hljs-number">336</span>     u16 dma_alignment;<br><span class="hljs-number">337</span><br><span class="hljs-number">338</span>     <span class="hljs-comment">/* spi_device.mode flags understood by this controller driver */</span><br><span class="hljs-number">339</span>     u16 mode_bits;<br><span class="hljs-number">340</span><br><span class="hljs-number">341</span>     <span class="hljs-comment">/* bitmask of supported bits_per_word for transfers */</span><br><span class="hljs-number">342</span>     u32 bits_per_word_mask;<br>......<br><span class="hljs-number">347</span>     <span class="hljs-comment">/* limits on transfer speed */</span><br><span class="hljs-number">348</span>     u32 min_speed_hz;<br><span class="hljs-number">349</span>     u32 max_speed_hz;<br><span class="hljs-number">350</span><br><span class="hljs-number">351</span>     <span class="hljs-comment">/* other constraints relevant to this driver */</span><br><span class="hljs-number">352</span>     u16 flags;<br>......<br><span class="hljs-number">359</span>     <span class="hljs-comment">/* lock and mutex for SPI bus locking */</span><br><span class="hljs-number">360</span>     <span class="hljs-type">spinlock_t</span> bus_lock_spinlock;<br><span class="hljs-number">361</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bus_lock_mutex</span>;</span><br><span class="hljs-number">362</span><br><span class="hljs-number">363</span>     <span class="hljs-comment">/* flag indicating that the SPI bus is locked for exclusive use */</span><br><span class="hljs-number">364</span>     <span class="hljs-type">bool</span> bus_lock_flag;<br>......<br><span class="hljs-number">372</span>     <span class="hljs-type">int</span> (*setup)(<span class="hljs-keyword">struct</span> spi_device *spi);<br><span class="hljs-number">373</span><br>......<br><span class="hljs-number">393</span>     <span class="hljs-type">int</span> (*transfer)(<span class="hljs-keyword">struct</span> spi_device *spi,<br><span class="hljs-number">394</span>     <span class="hljs-keyword">struct</span> spi_message *mesg);<br>......<br><span class="hljs-number">434</span>     <span class="hljs-type">int</span> (*transfer_one_message)(<span class="hljs-keyword">struct</span> spi_master *master,<br><span class="hljs-number">435</span>     <span class="hljs-keyword">struct</span> spi_message *mesg);<br>......<br><span class="hljs-number">462</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 393 行，transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。</p><p>第 434 行，transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。也就是 SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。和 I2C 适配器驱动一样，SPI 主机驱动一般都是 SOC 厂商去编写的，所以我们作为 SOC 的使用者，这一部分的驱动就不用操心了，除非你是在 SOC 原厂工作，内容就是写 SPI 主机驱动。</p><p>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册spi_master。</p><h4 id="spi-master-申请与释放"><a href="#spi-master-申请与释放" class="headerlink" title="spi_master 申请与释放"></a>spi_master 申请与释放</h4><p>spi_alloc_master 函数用于申请 spi_master，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> spi_master *<span class="hljs-title function_">spi_alloc_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">unsigned</span> size)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备，一般是 platform_device 中的 dev 成员变量。<br><strong>size：</strong>私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。<br><strong>返回值：</strong>申请到的 spi_master。</p><p>spi_master 的释放通过 spi_master_put 函数来完成，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master_put 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_master_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>master：</strong>要释放的 spi_master。<br><strong>返回值：</strong>无</p><h4 id="spi-master-注册与注销"><a href="#spi-master-注册与注销" class="headerlink" title="spi_master 注册与注销"></a>spi_master 注册与注销</h4><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，spi_master 注册函数为spi_register_master，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>master：</strong>要注册的 spi_master。<br><strong>返回值：</strong>0，成功；负值，失败。</p><p>I.MX6U 的 SPI 主机驱动会采用 spi_bitbang_start 这个 API 函数来完成 spi_master 的注册，spi_bitbang_start 函数内部其实也是通过调用 spi_register_master 函数来完成 spi_master 的注册。</p><p>如果要注销 spi_master 的话可以使用 spi_unregister_master 函数，此函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_master</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_master *master)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>master：</strong>要注销的 spi_master。<br><strong>返回值：</strong>无。</p><p>如果使用 spi_bitbang_start 注册 spi_master 的话就要使用 spi_bitbang_stop 来注销掉spi_master。</p><h3 id="SPI-设备驱动"><a href="#SPI-设备驱动" class="headerlink" title="SPI 设备驱动"></a>SPI 设备驱动</h3><p>spi 设备驱动和 i2c 设备驱动也很类似，Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，我们在编写 SPI 设备驱动的时候需要实现 spi_driver 。spi_driver 结构体定义在include&#x2F;linux&#x2F;spi&#x2F;spi.h 文件中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> *<span class="hljs-title">id_table</span>;</span><br>    <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> spi_device *spi);<br>    <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> spi_device *spi);<br>    <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> spi_device *spi);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出，spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。</p><p>同样的，spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>sdrv：</strong>要注册的 spi_driver。<br><strong>返回值：</strong>0，注册成功；赋值，注册失败。</p><p>注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函数完成 spi_driver 的注销，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_unregister_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_driver *sdrv)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>sdrv：</strong>要注销的 spi_driver。<br><strong>返回值：</strong>无。</p><p>spi_driver 注册示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.1.1.3 spi_driver 注册示例程序</span><br><span class="hljs-comment">/* probe 函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span><br>&#123;<br>    <span class="hljs-comment">/* 具体函数内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* remove 函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi)</span><br>&#123;<br>    <span class="hljs-comment">/* 具体函数内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;<br>    &#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;, <br>    &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">/* 设备树匹配列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<br>    &#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,<br>    &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">/* SPI 驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<br>    .probe = xxx_probe,<br>    .remove = xxx_remove,<br>    .driver = &#123;<br>        .owner = THIS_MODULE,<br>        .name = <span class="hljs-string">&quot;xxx&quot;</span>,<br>        .of_match_table = xxx_of_match,<br>    &#125;,<br>    .id_table = xxx_id,<br>&#125;;<br><br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> spi_register_driver(&amp;xxx_driver);<br>&#125;<br><br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    spi_unregister_driver(&amp;xxx_driver);<br>&#125;<br><br>module_init(xxx_init);<br>module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>第 1-36 行，spi_driver 结构体，需要 SPI 设备驱动人员编写，包括匹配表、probe 函数等。和 i2c_driver、platform_driver 一样，就不详细讲解了。</p><p>第 39-42 行，在驱动入口函数中调用 spi_register_driver 来注册 spi_driver。</p><p>第 45-48 行，在驱动出口函数中调用 spi_unregister_driver 来注销 spi_driver。</p><h3 id="SPI-设备和驱动匹配过程"><a href="#SPI-设备和驱动匹配过程" class="headerlink" title="SPI 设备和驱动匹配过程"></a>SPI 设备和驱动匹配过程</h3><p>SPI 设备和驱动的匹配过程是由 SPI 总线来完成的，这点和 platform、I2C 等驱动一样，SPI总线为 spi_bus_type，定义在 drivers&#x2F;spi&#x2F;spi.c 文件中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.1.3.1 spi_bus_type 结构体</span><br><span class="hljs-number">131</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">spi_bus_type</span> =</span> &#123;<br><span class="hljs-number">132</span>     .name = <span class="hljs-string">&quot;spi&quot;</span>,<br><span class="hljs-number">133</span>     .dev_groups = spi_dev_groups,<br><span class="hljs-number">134</span>     .match = spi_match_device,<br><span class="hljs-number">135</span>     .uevent = spi_uevent,<br><span class="hljs-number">136</span> &#125;;<br></code></pre></td></tr></table></figure><p>可以看出，SPI 设备和驱动的匹配函数为 spi_match_device，函数内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.1.3.2 spi_match_device 函数</span><br><span class="hljs-number">99</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_match_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>100 &#123;<br><span class="hljs-number">101</span>     <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span> =</span> to_spi_device(dev);<br><span class="hljs-number">102</span>     <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_driver</span> *<span class="hljs-title">sdrv</span> =</span> to_spi_driver(drv);<br><span class="hljs-number">103</span><br><span class="hljs-number">104</span>     <span class="hljs-comment">/* Attempt an OF style match */</span><br><span class="hljs-number">105</span>     <span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br><span class="hljs-number">106</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">107</span> <br><span class="hljs-number">108</span>     <span class="hljs-comment">/* Then try ACPI */</span><br><span class="hljs-number">109</span>     <span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br><span class="hljs-number">110</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">111</span> <br><span class="hljs-number">112</span>     <span class="hljs-keyword">if</span> (sdrv-&gt;id_table)<br><span class="hljs-number">113</span>     <span class="hljs-keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);<br><span class="hljs-number">114</span> <br><span class="hljs-number">115</span>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="hljs-number">0</span>;<br><span class="hljs-number">116</span> &#125;<br></code></pre></td></tr></table></figure><p>spi_match_device 函数和 i2c_match_device 函数对于设备和驱动的匹配过程基本一样。</p><p>第 105 行，of_driver_match_device 函数用于完成设备树设备和驱动匹配。比较 SPI 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 SPI 设备和驱动匹配。</p><p>第 109 行，acpi_driver_match_device 函数用于 ACPI 形式的匹配。</p><p>第 113 行，spi_match_id 函数用于传统的、无设备树的 SPI 设备和驱动匹配过程。比较 SPI设备名字和 spi_device_id 的 name 字段是否相等，相等的话就说明 SPI 设备和驱动匹配。</p><p>第 115 行，比较 spi_device 中 modalias 成员变量和 device_driver 中的 name 成员变量是否相等。</p><h3 id="SPI-设备数据收发处理流程"><a href="#SPI-设备数据收发处理流程" class="headerlink" title="SPI 设备数据收发处理流程"></a>SPI 设备数据收发处理流程</h3><p>SPI 设备驱动的核心是 spi_driver，当我们向 Linux 内核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.3.2.1 spi_transfer 结构体</span><br><span class="hljs-number">603</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> &#123;</span><br><span class="hljs-number">604</span>     <span class="hljs-comment">// it&#x27;s ok if tx_buf == rx_buf (right?)</span><br><span class="hljs-number">605</span>     <span class="hljs-comment">// for MicroWire, one buffer must be null</span><br><span class="hljs-number">606</span>     <span class="hljs-comment">// buffers must work with dma_*map_single() calls, unless</span><br><span class="hljs-number">607</span>     <span class="hljs-comment">// spi_message.is_dma_mapped reports a pre-existing mapping</span><br><span class="hljs-number">608</span>     <span class="hljs-comment">//</span><br><span class="hljs-number">609</span>     <span class="hljs-type">const</span> <span class="hljs-type">void</span> *tx_buf;<br><span class="hljs-number">610</span>     <span class="hljs-type">void</span> *rx_buf;<br><span class="hljs-number">611</span>     <span class="hljs-type">unsigned</span> len;<br><span class="hljs-number">612</span> <br><span class="hljs-number">613</span>     <span class="hljs-type">dma_addr_t</span> tx_dma;<br><span class="hljs-number">614</span>     <span class="hljs-type">dma_addr_t</span> rx_dma;<br><span class="hljs-number">615</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">tx_sg</span>;</span><br><span class="hljs-number">616</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sg_table</span> <span class="hljs-title">rx_sg</span>;</span><br><span class="hljs-number">617</span> <br><span class="hljs-number">618</span>     <span class="hljs-type">unsigned</span> cs_change:<span class="hljs-number">1</span>;<br><span class="hljs-number">619</span>     <span class="hljs-type">unsigned</span> tx_nbits:<span class="hljs-number">3</span>;<br><span class="hljs-number">620</span>     <span class="hljs-type">unsigned</span> rx_nbits:<span class="hljs-number">3</span>;<br><span class="hljs-number">621</span>     <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_SINGLE 0x01 <span class="hljs-comment">/* 1bit transfer */</span></span><br><span class="hljs-number">622</span>     <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_DUAL 0x02 <span class="hljs-comment">/* 2bits transfer */</span></span><br><span class="hljs-number">623</span>     <span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_NBITS_QUAD 0x04 <span class="hljs-comment">/* 4bits transfer */</span></span><br><span class="hljs-number">624</span>     u8 bits_per_word;<br><span class="hljs-number">625</span>     u16 delay_usecs;<br><span class="hljs-number">626</span>     u32 speed_hz;<br><span class="hljs-number">627</span> <br><span class="hljs-number">628</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfer_list</span>;</span><br><span class="hljs-number">629</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 609 行，tx_buf 保存着要发送的数据。</p><p>第 610 行，rx_buf 用于保存接收到的数据。</p><p>第 611 行，len 是要进行传输的数据长度，SPI 是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer 中也就没有发送长度和接收长度之分。</p><p>spi_transfer 需要组织成 spi_message，spi_message 也是一个结构体，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.3.2.2 spi_message 结构体</span><br><span class="hljs-number">660</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> &#123;</span><br><span class="hljs-number">661</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">transfers</span>;</span><br><span class="hljs-number">662</span> <br><span class="hljs-number">663</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_device</span> *<span class="hljs-title">spi</span>;</span><br><span class="hljs-number">664</span> <br><span class="hljs-number">665</span>     <span class="hljs-type">unsigned</span> is_dma_mapped:<span class="hljs-number">1</span>;<br>......<br><span class="hljs-number">678</span>     <span class="hljs-comment">/* completion is reported through a callback */</span><br><span class="hljs-number">679</span>     <span class="hljs-type">void</span> (*complete)(<span class="hljs-type">void</span> *context);<br><span class="hljs-number">680</span>     <span class="hljs-type">void</span> *context;<br><span class="hljs-number">681</span>     <span class="hljs-type">unsigned</span> frame_length;<br><span class="hljs-number">682</span>     <span class="hljs-type">unsigned</span> actual_length;<br><span class="hljs-number">683</span>     <span class="hljs-type">int</span> status;<br><span class="hljs-number">684</span> <br><span class="hljs-number">685</span>     <span class="hljs-comment">// for optional use by whatever driver currently owns the</span><br><span class="hljs-number">686</span>     <span class="hljs-comment">// spi_message ... between calls to spi_async and then later</span><br><span class="hljs-number">687</span>     <span class="hljs-comment">// complete(), that&#x27;s the spi_master controller driver.</span><br><span class="hljs-number">688</span>     <span class="hljs-comment">//</span><br><span class="hljs-number">689</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">queue</span>;</span><br><span class="hljs-number">690</span>     <span class="hljs-type">void</span> *state;<br><span class="hljs-number">691</span> &#125;;<br></code></pre></td></tr></table></figure><p>在使用spi_message之前需要对其进行初始化，spi_message初始化函数为spi_message_init，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_message *m)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>m：</strong>要初始化的 spi_message。<br><strong>返回值：</strong>无。</p><p>spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数，此函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">spi_message_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_transfer *t, <span class="hljs-keyword">struct</span> spi_message *m)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>t：</strong>要添加到队列中的 spi_transfer。<br><strong>m</strong>：spi_transfer 要加入的 spi_message。<br><strong>返回值：</strong>无。</p><p>spi_message 准备好以后就可以进行数据传输了，数据传输分为同步传输和异步传输，同步传输会阻塞的等待 SPI 数据传输完成，同步传输函数为 spi_sync，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>spi：</strong>要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值：</strong>无。</p><p>异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。SPI 异步传输函数为 spi_async，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">spi_async</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>spi：</strong>要进行数据传输的 spi_device。<br><strong>message</strong>：要传输的 spi_message。<br><strong>返回值：</strong>无。</p><p>我们采用同步传输方式来完成 SPI 数据的传输工作，也就是 spi_sync 函数。综上所述，SPI 数据传输步骤如下：</p><p>Version:0.9 StartHTML:0000000105 EndHTML:0000004721 StartFragment:0000000141 EndFragment:0000004681</p><p>①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是要进行数据通信的长度。</p><p>②、使用 spi_message_init 函数初始化 spi_message。</p><p>③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message 队列中。</p><p>④、使用 spi_sync 函数完成 SPI 数据同步传输。</p><p>通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 62.3.2.3 SPI 数据读写操作</span><br><span class="hljs-comment">/* SPI 多字节发送 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_send</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;<br>        .tx_buf = buf,<br>        .len = len,<br>    &#125;;<br>    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span><br>    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span><br>    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-comment">/* SPI 多字节接收 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_receive</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 *buf, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_message</span> <span class="hljs-title">m</span>;</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_transfer</span> <span class="hljs-title">t</span> =</span> &#123;<br>        .rx_buf = buf,<br>        .len = len,<br>    &#125;;<br>    spi_message_init(&amp;m); <span class="hljs-comment">/* 初始化 spi_message */</span><br>    spi_message_add_tail(t, &amp;m);<span class="hljs-comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span><br>    ret = spi_sync(spi, &amp;m); <span class="hljs-comment">/* 同步传输 */</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>spi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C</title>
    <link href="/i2c/i2c%E9%A9%B1%E5%8A%A8/"/>
    <url>/i2c/i2c%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><h2 id="I2C-简介"><a href="#I2C-简介" class="headerlink" title="I2C 简介"></a>I2C 简介</h2><h3 id="什么是I2C"><a href="#什么是I2C" class="headerlink" title="什么是I2C"></a>什么是I2C</h3><p>I2C 是很常见的一种总线协议，I2C 是 NXP 公司设计的，I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。I2C 总线工作是按照一定的协议来运行的，接下来就看一下 I2C 协议。</p><h3 id="I2C-协议"><a href="#I2C-协议" class="headerlink" title="I2C 协议"></a>I2C 协议</h3><p>I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C设备了，一个 I2C 总线连接多个 I2C 设备如图 26.1.1.1 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/a.png" class="" title="a"><p>图 26.1.1.1 中 SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。其余的 I2C 从器件都挂接到 SDA 和 SCL 这两根线上，这样就可以通过 SDA 和 SCL 这两根线来访问多个 I2C设备。</p><p>接下来看一下 I2C 协议有关的术语：</p><h4 id="起始位"><a href="#起始位" class="headerlink" title="起始位"></a>起始位</h4><p>顾名思义，也就是 I2C 通信起始标志，通过这个起始位就可以告诉 I2C 从机，“我”要开始进行 I2C 通信了。在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位，如图 26.1.1.2 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/b.png" class="" title="b"><h4 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h4><p>停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位，如图 26.1.1.3 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/c.png" class="" title="c"><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生，如图 26.1.1.4 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/d.png" class="" title="d"><h4 id="应答信号"><a href="#应答信号" class="headerlink" title="应答信号"></a>应答信号</h4><p>当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p><h4 id="I2C-写时序"><a href="#I2C-写时序" class="headerlink" title="I2C 写时序"></a>I2C 写时序</h4><p>主机通过 I2C 总线与从机之间进行通信不外乎两个操作：写和读，I2C 总线单字节写时序如图 26.1.1.5 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/e.png" class="" title="e"><p>图 26.1.1.5 就是 I2C 写时序，我们来看一下写时序的具体步骤：</p><p>1)、开始信号。</p><p>2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为1 的话表示这是一个读操作，为 0 的话表示这是一个写操作。</p><p>3)、 I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作。</p><p>4)、从机发送的 ACK 应答信号。</p><p>5)、重新发送开始信号。</p><p>6)、发送要写写入数据的寄存器地址。</p><p>7)、从机发送的 ACK 应答信号。</p><p>8)、发送要写入寄存器的数据。</p><p>9)、从机发送的 ACK 应答信号。</p><p>10)、停止信号。</p><h4 id="I2C-读时序"><a href="#I2C-读时序" class="headerlink" title="I2C 读时序"></a>I2C 读时序</h4><p>I2C 总线单字节读时序如图 26.1.1.6 所示：</p><img src="/i2c/i2c%E9%A9%B1%E5%8A%A8/f.png" class="" title="f"><p>I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值，我们具体来看一下这几步。</p><p>1)、主机发送起始信号。</p><p>2)、主机发送要读取的 I2C 从设备地址。</p><p>3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。</p><p>4)、从机发送的 ACK 应答信号。</p><p>5)、重新发送 START 信号。</p><p>6)、主机发送要读取的寄存器地址。</p><p>7)、从机发送的 ACK 应答信号。</p><p>8)、重新发送 START 信号。</p><p>9)、重新发送要读取的 I2C 从设备地址。</p><p>10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。</p><p>11)、从机发送的 ACK 应答信号。</p><p>12)、从 I2C 器件里面读取到的数据。</p><p>13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。</p><p>14)、主机发出 STOP 信号，停止 I2C 通信。</p><h4 id="I2C-多字节读写时序"><a href="#I2C-多字节读写时序" class="headerlink" title="I2C 多字节读写时序"></a>I2C 多字节读写时序</h4><p>有时候我们需要读写多个字节，多字节读写时序和单字节的基本一致，只是在读写数据的时候可以连续发送多个自己的数据，其他的控制时序都是和单字节一样的。</p><h2 id="I2C-驱动框架"><a href="#I2C-驱动框架" class="headerlink" title="I2C 驱动框架"></a>I2C 驱动框架</h2><p>Linux内核将 I2C 驱动分为两部分：</p><ul><li>I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。</li><li>I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</li></ul><h3 id="I2C-总线驱动"><a href="#I2C-总线驱动" class="headerlink" title="I2C 总线驱动"></a>I2C 总线驱动</h3><p>首先来看一下 I2C 总线，在讲 platform 的时候就说过，platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter，i2c_adapter 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.1.1.1 i2c_adapter 结构体</span><br><span class="hljs-number">498</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> &#123;</span><br><span class="hljs-number">499</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-number">500</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">/* classes to allow probing for */</span><br><span class="hljs-number">501</span>     <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span> <span class="hljs-comment">/* 总线访问算法 */</span><br><span class="hljs-number">502</span>     <span class="hljs-type">void</span> *algo_data;<br><span class="hljs-number">503</span> <br><span class="hljs-number">504</span>     <span class="hljs-comment">/* data fields that are valid for all devices */</span><br><span class="hljs-number">505</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">bus_lock</span>;</span><br><span class="hljs-number">506</span> <br><span class="hljs-number">507</span>     <span class="hljs-type">int</span> timeout; <span class="hljs-comment">/* in jiffies */</span><br><span class="hljs-number">508</span>     <span class="hljs-type">int</span> retries;<br><span class="hljs-number">509</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* the adapter device */</span><br><span class="hljs-number">510</span> <br><span class="hljs-number">511</span>     <span class="hljs-type">int</span> nr;<br><span class="hljs-number">512</span>     <span class="hljs-type">char</span> name[<span class="hljs-number">48</span>];<br><span class="hljs-number">513</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span><br><span class="hljs-number">514</span> <br><span class="hljs-number">515</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">userspace_clients_lock</span>;</span><br><span class="hljs-number">516</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">userspace_clients</span>;</span><br><span class="hljs-number">517</span> <br><span class="hljs-number">518</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_bus_recovery_info</span> *<span class="hljs-title">bus_recovery_info</span>;</span><br><span class="hljs-number">519</span>     <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter_quirks</span> *<span class="hljs-title">quirks</span>;</span><br><span class="hljs-number">520</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 501 行，i2c_algorithm 类型的指针变量 algo，对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。</p><p>i2c_algorithm 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下(删除条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">61.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span> i2c_algorithm 结构体<br><span class="hljs-number">391</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> &#123;</span><br>......<br><span class="hljs-number">398</span> <span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs,<br><span class="hljs-number">399</span> <span class="hljs-type">int</span> num);<br><span class="hljs-number">400</span> <span class="hljs-type">int</span> (*smbus_xfer) (<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<br><span class="hljs-number">401</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<br><span class="hljs-number">402</span> u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<br><span class="hljs-number">403</span><br><span class="hljs-number">404</span> <span class="hljs-comment">/* To determine what the adapter supports */</span><br><span class="hljs-number">405</span> u32 (*functionality) (<span class="hljs-keyword">struct</span> i2c_adapter *);<br>......<br><span class="hljs-number">411</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 398 行，master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</p><p>第 400 行，smbus_xfer 就是 SMBUS 总线的传输函数。</p><p>综上所述，I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，这两个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_numbered_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span><br></code></pre></td></tr></table></figure><p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter使用静态总线号。函数参数和返回值含义如下：</p><p><strong>adapter</strong> <strong>或</strong> <strong>adap</strong>：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。<br><strong>返回值：</strong>0，成功；负值，失败。</p><p>如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter * adap)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：</p><p><strong>adap</strong>：要删除的 I2C 适配器。<br><strong>返回值：</strong>无。</p><p>关于 I2C 的总线(控制器或适配器)驱动就讲解到这里，一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。因此 I2C 总线驱动对我们这些 SOC 使用者来说是被屏蔽掉的，我们只要专注于 I2C 设备驱动即可。除非你是在半导体公司上班，工作内容就是写 I2C 适配器驱动。</p><h3 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h3><p>I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，根据总线、设备和驱动模型，I2C 总线上一小节已经讲了。还剩下设备和驱动，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。</p><h4 id="i2c-client-结构体"><a href="#i2c-client-结构体" class="headerlink" title="i2c_client 结构体"></a>i2c_client 结构体</h4><p>i2c_client 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.1.2.1 i2c_client 结构体</span><br><span class="hljs-number">217</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> &#123;</span><br><span class="hljs-number">218</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags; <span class="hljs-comment">/* 标志 */</span><br><span class="hljs-number">219</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr; <span class="hljs-comment">/* 芯片地址，7 位，存在低 7 位*/</span><br>......<br><span class="hljs-number">222</span> <span class="hljs-type">char</span> name[I2C_NAME_SIZE]; <span class="hljs-comment">/* 名字 */</span><br><span class="hljs-number">223</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span> <span class="hljs-comment">/* 对应的 I2C 适配器 */</span><br><span class="hljs-number">224</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span> <span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-number">225</span> <span class="hljs-type">int</span> irq; <span class="hljs-comment">/* 中断 */</span><br><span class="hljs-number">226</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">detected</span>;</span><br>......<br><span class="hljs-number">230</span> &#125;;<br></code></pre></td></tr></table></figure><p>一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。</p><h4 id="i2c-driver-结构体"><a href="#i2c-driver-结构体" class="headerlink" title="i2c_driver 结构体"></a>i2c_driver 结构体</h4><p>i2c_driver 类似 platform_driver，是我们编写 I2C 设备驱动重点要处理的内容，i2c_driver 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">61.1</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span> i2c_driver 结构体<br><span class="hljs-number">161</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> &#123;</span><br><span class="hljs-number">162</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br><span class="hljs-number">163</span><br><span class="hljs-number">164</span> <span class="hljs-comment">// Notifies the driver that a new bus has appeared. You should </span><br><span class="hljs-number">165</span> <span class="hljs-comment">// avoid using this, it will be removed in a near future.</span><br><span class="hljs-number">166</span> <span class="hljs-comment">//</span><br><span class="hljs-number">167</span> <span class="hljs-type">int</span> (*attach_adapter)(<span class="hljs-keyword">struct</span> i2c_adapter *) __deprecated;<br><span class="hljs-number">168</span><br><span class="hljs-number">169</span> <span class="hljs-comment">/* Standard driver model interfaces */</span><br><span class="hljs-number">170</span> <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *);<br><span class="hljs-number">171</span> <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> i2c_client *);<br><span class="hljs-number">172</span><br><span class="hljs-number">173</span> <span class="hljs-comment">/* driver model interfaces that don&#x27;t relate to enumeration */</span><br><span class="hljs-number">174</span> <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> i2c_client *);<br><span class="hljs-number">175</span><br><span class="hljs-number">176</span> <span class="hljs-comment">// Alert callback, for example for the SMBus alert protocol.</span><br><span class="hljs-number">177</span> <span class="hljs-comment">// The format and meaning of the data value depends on the </span><br><span class="hljs-number">178</span> <span class="hljs-comment">// protocol.For the SMBus alert protocol, there is a single bit </span><br><span class="hljs-number">179</span> <span class="hljs-comment">// of data passed as the alert response&#x27;s low bit (&quot;event </span><br><span class="hljs-number">180</span> <span class="hljs-comment">// flag&quot;). </span><br><span class="hljs-number">181</span> <span class="hljs-type">void</span> (*alert)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data);<br><span class="hljs-number">182</span><br><span class="hljs-number">183</span> <span class="hljs-comment">// a ioctl like command that can be used to perform specific </span><br><span class="hljs-number">184</span> <span class="hljs-comment">// functions with the device.</span><br><span class="hljs-number">185</span> <br><span class="hljs-number">186</span> <span class="hljs-type">int</span> (*command)(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<br><span class="hljs-type">void</span> *arg);<br><span class="hljs-number">187</span><br><span class="hljs-number">188</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><br><span class="hljs-number">189</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> *<span class="hljs-title">id_table</span>;</span><br><span class="hljs-number">190</span><br><span class="hljs-number">191</span> <span class="hljs-comment">/* Device detection callback for automatic device creation */</span><br><span class="hljs-number">192</span> <span class="hljs-type">int</span> (*detect)(<span class="hljs-keyword">struct</span> i2c_client *, <span class="hljs-keyword">struct</span> i2c_board_info *);<br><span class="hljs-number">193</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *address_list;<br><span class="hljs-number">194</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">clients</span>;</span><br><span class="hljs-number">195</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 170 行，当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。</p><p>第 188 行，device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量，也就是驱动的兼容(compatible)属性。</p><p>第 189 行，id_table 是传统的、未使用设备树的设备匹配 ID 表。</p><p>对于我们 I2C 设备驱动编写人来说，重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。i2c_driver 注册函数为 int i2c_register_driver，此函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner, <span class="hljs-keyword">struct</span> i2c_driver *driver)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>owner</strong>：一般为 THIS_MODULE。<br><strong>driver</strong>：要注册的 i2c_driver。<br><strong>返回值：</strong>0，成功；负值，失败。</p><p>另外 i2c_add_driver 也常常用于注册 i2c_driver，i2c_add_driver 是一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.1.2.3 i2c_add_driver 宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> i2c_add_driver(driver) \</span><br><span class="hljs-meta">i2c_register_driver(THIS_MODULE, driver)</span><br></code></pre></td></tr></table></figure><p>i2c_add_driver 就是对 i2c_register_driver 做了一个简单的封装，只有一个参数，就是要注册的 i2c_driver。</p><p>注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到i2c_del_driver 函数，此函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_driver *driver)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>driver</strong>：要注销的 i2c_driver。<br><strong>返回值：</strong>无。</p><p>i2c_driver 的注册示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c">示例代码 <span class="hljs-number">61.1</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span> i2c_driver 注册流程<br><span class="hljs-number">1</span> <span class="hljs-comment">/* i2c 驱动的 probe 函数 */</span><br><span class="hljs-number">2</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span><br>3 &#123;<br><span class="hljs-number">4</span> <span class="hljs-comment">/* 函数具体程序 */</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span> &#125;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> <span class="hljs-comment">/* i2c 驱动的 remove 函数 */</span><br><span class="hljs-number">9</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span><br>10 &#123;<br><span class="hljs-number">11</span> <span class="hljs-comment">/* 函数具体程序 */</span><br><span class="hljs-number">12</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span><br><span class="hljs-number">15</span> <span class="hljs-comment">/* 传统匹配方式 ID 列表 */</span><br><span class="hljs-number">16</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">xxx_id</span>[] =</span> &#123;<br><span class="hljs-number">17</span> &#123;<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">0</span>&#125;, <br><span class="hljs-number">18</span> &#123;&#125;<br><span class="hljs-number">19</span> &#125;;<br><span class="hljs-number">20</span><br><span class="hljs-number">21</span> <span class="hljs-comment">/* 设备树匹配列表 */</span><br><span class="hljs-number">22</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<br><span class="hljs-number">23</span> &#123; .compatible = <span class="hljs-string">&quot;xxx&quot;</span> &#125;,<br><span class="hljs-number">24</span> &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<br><span class="hljs-number">25</span> &#125;;<br><span class="hljs-number">26</span><br><span class="hljs-number">27</span> <span class="hljs-comment">/* i2c 驱动结构体 */</span><br><span class="hljs-number">28</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<br><span class="hljs-number">29</span> .probe = xxx_probe,<br><span class="hljs-number">30</span> .remove = xxx_remove,<br><span class="hljs-number">31</span> .driver = &#123;<br><span class="hljs-number">32</span> .owner = THIS_MODULE,<br><span class="hljs-number">33</span> .name = <span class="hljs-string">&quot;xxx&quot;</span>,<br><span class="hljs-number">34</span> .of_match_table = xxx_of_match,<br><span class="hljs-number">35</span> &#125;,<br><span class="hljs-number">36</span> .id_table = xxx_id,<br><span class="hljs-number">37</span> &#125;;<br><span class="hljs-number">38</span> <br><span class="hljs-number">39</span> <span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-number">40</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>41 &#123;<br><span class="hljs-number">42</span> <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-number">43</span><br><span class="hljs-number">44</span> ret = i2c_add_driver(&amp;xxx_driver);<br><span class="hljs-number">45</span> <span class="hljs-keyword">return</span> ret;<br><span class="hljs-number">46</span> &#125;<br><span class="hljs-number">47</span><br><span class="hljs-number">48</span> <span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-number">49</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>50 &#123;<br><span class="hljs-number">51</span> i2c_del_driver(&amp;xxx_driver);<br><span class="hljs-number">52</span> &#125;<br><span class="hljs-number">53</span><br><span class="hljs-number">54</span> module_init(xxx_init);<br><span class="hljs-number">55</span> module_exit(xxx_exit);<br></code></pre></td></tr></table></figure><p>第 16-19 行，i2c_device_id，无设备树的时候匹配 ID 表。</p><p>第 22-25 行，of_device_id，设备树所使用的匹配表。</p><p>第 28-37 行，i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。</p><h3 id="I2C-设备和驱动匹配过程"><a href="#I2C-设备和驱动匹配过程" class="headerlink" title="I2C 设备和驱动匹配过程"></a>I2C 设备和驱动匹配过程</h3><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers&#x2F;i2c&#x2F;i2c-core.c 就是 I2C 的核心部分，I2C 核心提供了一些与具体硬件无关的 API 函数，比如前面讲过的：</p><h4 id="i2c-adapter-注册-注销函数"><a href="#i2c-adapter-注册-注销函数" class="headerlink" title="i2c_adapter 注册&#x2F;注销函数"></a>i2c_adapter 注册&#x2F;注销函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_numbered_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter * adap)</span><br></code></pre></td></tr></table></figure><h4 id="i2c-driver-注册-注销函数"><a href="#i2c-driver-注册-注销函数" class="headerlink" title="i2c_driver 注册&#x2F;注销函数"></a>i2c_driver 注册&#x2F;注销函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *owner, <span class="hljs-keyword">struct</span> i2c_driver *driver)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_driver</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_driver *driver)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_del_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_driver *driver)</span><br></code></pre></td></tr></table></figure><p>设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义在 drivers&#x2F;i2c&#x2F;i2c-core.c 文件，i2c_bus_type 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.1.2.5 i2c_bus_type 总线</span><br><span class="hljs-number">736</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">i2c_bus_type</span> =</span> &#123;<br><span class="hljs-number">737</span> .name = <span class="hljs-string">&quot;i2c&quot;</span>,<br><span class="hljs-number">738</span> .match = i2c_device_match,<br><span class="hljs-number">739</span> .probe = i2c_device_probe,<br><span class="hljs-number">740</span> .remove = i2c_device_remove,<br><span class="hljs-number">741</span> .shutdown = i2c_device_shutdown,<br><span class="hljs-number">742</span> &#125;;<br></code></pre></td></tr></table></figure><p>.match 就是 I2C 总线的设备和驱动匹配函数，在这里就是 i2c_device_match 这个函数，此函数内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.1.2.6 i2c_device_match 函数</span><br><span class="hljs-number">457</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>458 &#123;<br><span class="hljs-number">459</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> i2c_verify_client(dev);<br><span class="hljs-number">460</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> *<span class="hljs-title">driver</span>;</span><br><span class="hljs-number">461</span><br><span class="hljs-number">462</span> <span class="hljs-keyword">if</span> (!client)<br><span class="hljs-number">463</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">464</span><br><span class="hljs-number">465</span> <span class="hljs-comment">/* Attempt an OF style match */</span><br><span class="hljs-number">466</span> <span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br><span class="hljs-number">467</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">468</span><br><span class="hljs-number">469</span> <span class="hljs-comment">/* Then ACPI style match */</span><br><span class="hljs-number">470</span> <span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br><span class="hljs-number">471</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">472</span><br><span class="hljs-number">473</span> driver = to_i2c_driver(drv);<br><span class="hljs-number">474</span> <span class="hljs-comment">/* match on an id table if there is one */</span><br><span class="hljs-number">475</span> <span class="hljs-keyword">if</span> (driver-&gt;id_table)<br><span class="hljs-number">476</span> <span class="hljs-keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">477</span><br><span class="hljs-number">478</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">479</span> &#125;<br></code></pre></td></tr></table></figure><p>第 466 行，of_driver_match_device 函数用于完成设备树设备和驱动匹配。比较 I2C 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 I2C设备和驱动匹配。</p><p>第 470 行，acpi_driver_match_device 函数用于 ACPI 形式的匹配。</p><p>第 476 行，i2c_match_id 函数用于传统的、无设备树的 I2C 设备和驱动匹配过程。比较 I2C设备名字和 i2c_device_id 的 name 字段是否相等，相等的话就说明 I2C 设备和驱动匹配。</p><h3 id="I2C-设备信息描述"><a href="#I2C-设备信息描述" class="headerlink" title="I2C 设备信息描述"></a>I2C 设备信息描述</h3><h4 id="使用设备树"><a href="#使用设备树" class="headerlink" title="使用设备树"></a>使用设备树</h4><p>使用设备树的时候 I2C 设备信息通过创建相应的节点就行了，比如 NXP 官方的 EVK 开发板在 I2C1 上接了 mag3110 这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然后在这个子节点内描述 mag3110 这个芯片的相关信息。打开 imx6ull-14x14-evk.dts 这个设备树文件，然后找到如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.3.1.4 mag3110 子节点</span><br><span class="hljs-number">1</span> &amp;i2c1 &#123;<br><span class="hljs-number">2</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br><span class="hljs-number">3</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br><span class="hljs-number">4</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br><span class="hljs-number">5</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<br><span class="hljs-number">6</span> <br><span class="hljs-number">7</span> mag3110@<span class="hljs-number">0</span>e &#123;<br><span class="hljs-number">8</span> compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<br><span class="hljs-number">9</span> reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<br><span class="hljs-number">10</span>position = &lt;<span class="hljs-number">2</span>&gt;;<br><span class="hljs-number">11</span>&#125;;<br>......<br><span class="hljs-number">20</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 7-11 行，向 i2c1 添加 mag3110 子节点，第 7 行“mag3110@0e”是子节点名字，“@”后面的“0e”就是 mag3110 的 I2C 器件地址。第 8 行设置 compatible 属性值为“fsl,mag3110”。第 9 行的 reg 属性也是设置 mag3110 的器件地址的，因此值为 0x0e。I2C 设备节点的创建重点是 compatible 属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</p><h3 id="I2C-设备数据收发处理流程"><a href="#I2C-设备数据收发处理流程" class="headerlink" title="I2C 设备数据收发处理流程"></a>I2C 设备数据收发处理流程</h3><p>I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>adap</strong>：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。<br><strong>msgs</strong>：I2C 要发送的一个或多个消息。<br><strong>num：</strong>消息数量，也就是 msgs 的数量。<br><strong>返回值：</strong>负值，失败，其他非负值，发送的 msgs 数量。</p><p>我们重点来看一下 msgs 这个参数，这是一个 i2c_msg 类型的指针参数，I2C 进行数据收发说白了就是消息的传递，Linux 内核使用 i2c_msg 结构体来描述一个消息。i2c_msg 结构体定义在 include&#x2F;uapi&#x2F;linux&#x2F;i2c.h 文件中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 61.3.2.1 i2c_msg 结构体</span><br><span class="hljs-number">68</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> &#123;</span><br><span class="hljs-number">69</span> __u16 addr; <span class="hljs-comment">/* 从机地址 */</span><br><span class="hljs-number">70</span> __u16 flags; <span class="hljs-comment">/* 标志 */</span><br><span class="hljs-number">71</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_TEN 0x0010</span><br><span class="hljs-number">72</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RD 0x0001</span><br><span class="hljs-number">73</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_STOP 0x8000</span><br><span class="hljs-number">74</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NOSTART 0x4000</span><br><span class="hljs-number">75</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_REV_DIR_ADDR 0x2000 </span><br><span class="hljs-number">76</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_IGNORE_NAK 0x1000 </span><br><span class="hljs-number">77</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NO_RD_ACK 0x0800</span><br><span class="hljs-number">78</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RECV_LEN 0x0400</span><br><span class="hljs-number">79</span> __u16 len; <span class="hljs-comment">/* 消息(本 msg)长度 */</span><br><span class="hljs-number">80</span> __u8 *buf; <span class="hljs-comment">/* 消息数据 */</span><br><span class="hljs-number">81</span> &#125;;<br></code></pre></td></tr></table></figure><p>使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg，使用 i2c_transfer 进行 I2C 数据收发的示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> &#123;</span><br>    ......<br>    <span class="hljs-type">void</span> *private_data; <span class="hljs-comment">/* 私有数据，一般会设置为 i2c_client */</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @description : 读取 I2C 设备多个寄存器数据</span><br><span class="hljs-comment">* @param – dev : I2C 设备</span><br><span class="hljs-comment">* @param – reg : 要读取的寄存器首地址</span><br><span class="hljs-comment">* @param – val : 读取到的数据</span><br><span class="hljs-comment">* @param – len : 要读取的数据长度</span><br><span class="hljs-comment">* @return : 操作结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[2];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)<br>    dev-&gt;private_data;<br><br>    <span class="hljs-comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址 */</span><br>    msg[<span class="hljs-number">0</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><br>    msg[<span class="hljs-number">0</span>].flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为发送数据 */</span><br>    msg[<span class="hljs-number">0</span>].buf = &amp;reg; <span class="hljs-comment">/* 读取的首地址 */</span><br>    msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>; <span class="hljs-comment">/* reg 长度 */</span><br><br>    <span class="hljs-comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span><br>    msg[<span class="hljs-number">1</span>].addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><br>    msg[<span class="hljs-number">1</span>].flags = I2C_M_RD; <span class="hljs-comment">/* 标记为读取数据 */</span><br>    msg[<span class="hljs-number">1</span>].buf = val; <span class="hljs-comment">/* 读取数据缓冲区 */</span><br>    msg[<span class="hljs-number">1</span>].len = len; <span class="hljs-comment">/* 要读取的数据长度 */</span><br><br>    ret = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;<br>        ret = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ret = -EREMOTEIO;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @description : 向 I2C 设备多个寄存器写入数据</span><br><span class="hljs-comment">* @param – dev : 要写入的设备结构体</span><br><span class="hljs-comment">* @param – reg : 要写入的寄存器首地址</span><br><span class="hljs-comment">* @param – buf : 要写入的数据缓冲区</span><br><span class="hljs-comment">* @param – len : 要写入的数据长度</span><br><span class="hljs-comment">* @return : 操作结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> s32 <span class="hljs-title function_">xxx_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xxx_dev *dev, u8 reg, u8 *buf, len)</span><br>&#123;<br>    u8 b[<span class="hljs-number">256</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> (<span class="hljs-keyword">struct</span> i2c_client *)<br>    dev-&gt;private_data;<br><br>    b[<span class="hljs-number">0</span>] = reg; <span class="hljs-comment">/* 寄存器首地址 */</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">1</span>],buf,len); <span class="hljs-comment">/* 将要发送的数据拷贝到数组 b 里面 */</span><br><br>    msg.addr = client-&gt;addr; <span class="hljs-comment">/* I2C 器件地址 */</span><br>    msg.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 标记为写数据 */</span><br><br>    msg.buf = b; <span class="hljs-comment">/* 要发送的数据缓冲区 */</span><br>    msg.len = len + <span class="hljs-number">1</span>; <span class="hljs-comment">/* 要发送的数据长度 */</span><br><br>    <span class="hljs-keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第2-5行，设备结构体，在设备结构体里面添加一个指向void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。</p><p>第 15-40 行，xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。第 18 行定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。</p><p>第 50~66 行，xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</p><p>另外还有两个API函数分别用于I2C数据的收发操作，这两个函数最终都会调用i2c_transfer。首先来看一下 I2C 数据发送函数 i2c_master_send，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>client</strong>：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要发送的数据。<br><strong>count：</strong>要发送的数据字节数，要小于 64KB，因为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值：</strong>负值，失败，其他非负值，发送的字节数。</p><p>I2C 数据接收函数为 i2c_master_recv，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_master_recv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_client *client,  <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>client</strong>：I2C 设备对应的 i2c_client。<br><strong>buf</strong>：要接收的数据。<br><strong>count：</strong>要接收的数据字节数，要小于 64KB，因为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。<br><strong>返回值：</strong>负值，失败，其他非负值，发送的字节数。</p><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>i2c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>i2c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>device tree</title>
    <link href="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <url>/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-设备树"><a href="#Linux-设备树" class="headerlink" title="Linux 设备树"></a>Linux 设备树</h2><h3 id="什么是设备树？"><a href="#什么是设备树？" class="headerlink" title="什么是设备树？"></a>什么是设备树？</h3><p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等，如图 43.1.1所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/devicetree.png" class="" title="devicetree"><p>在图 43.1.1 中，树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。DTS 文件的主要功能就是按照图 43.1.1所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。</p><p>在 3.x 版本(具体哪个版本笔者也无从考证)以前的 Linux 内核中 ARM 架构并没有采用设备树。在没有设备树的时候 Linux 是如何描述 ARM 架构中的板级信息呢？在 Linux 内核源码中大量的 arch&#x2F;arm&#x2F;mach-xxx 和 arch&#x2F;arm&#x2F;plat-xxx 文件夹，这些文件夹里面的文件就是对应平台下的板级信息。比如在 arch&#x2F;arm&#x2F;mach-smdk2440.c 中有如下内容(有缩减)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_display</span> <span class="hljs-title">smdk2440_lcd_cfg</span> __<span class="hljs-title">initdata</span> =</span> &#123;<br><br>    .lcdcon5 = S3C2410_LCDCON5_FRM565 |<br>    S3C2410_LCDCON5_INVVLINE |<br>    S3C2410_LCDCON5_INVVFRAME |<br>    S3C2410_LCDCON5_PWREN |<br>    S3C2410_LCDCON5_HWSWP,<br>    ......<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s3c2410fb_mach_info</span> <span class="hljs-title">smdk2440_fb_info</span> __<span class="hljs-title">initdata</span> =</span> &#123;<br>    .displays = &amp;smdk2440_lcd_cfg,<br>    .num_displays = <span class="hljs-number">1</span>,<br>    .default_display = <span class="hljs-number">0</span>,<br>    ......<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<br>    &amp;s3c_device_ohci,<br>    &amp;s3c_device_lcd,<br>    &amp;s3c_device_wdt,<br>    &amp;s3c_device_i2c0,<br>    &amp;s3c_device_iis,<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中的结构体变量 smdk2440_fb_info 就是描述 SMDK2440 这个开发板上的 LCD 信息的，结构体指针数组 smdk2440_devices 描述的 SMDK2440 这个开发板上的所有平台相关信息。这个仅仅是使用 2440 这个芯片的 SMDK2440 开发板下的 LCD 信息，SMDK2440 开发板还有很多的其他外设硬件和平台硬件信息。使用 2440 这个芯片的板子有很多，每个板子都有描述相应板级信息的文件，这仅仅只是一个 2440。随着智能手机的发展，每年新出的 ARM 架构芯片少说都在数十、数百款，Linux 内核下板级信息文件将会成指数级增长！这些板级信息文件都是.c 或.h 文件，都会被硬编码进 Linux 内核中，导致 Linux 内核“虚胖”。就好比你喜欢吃自助餐，然后花了 100 多到一家宣传看着很不错的自助餐厅，结果你想吃的牛排、海鲜、烤肉基本没多少，全都是一些凉菜、炒面、西瓜、饮料等小吃，相信你此时肯定会脱口而出一句“F<em>k!”、“骗子！”。同样的，当 Linux 之父 linus 看到 ARM 社区向 Linux 内核添加了大量“无用”、冗余的板级信息文件，不禁的发出了一句“This whole ARM thing is a f</em>cking pain in the ass”。从此以后 ARM 社区就引入了 PowerPC 等架构已经采用的设备树(Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件，类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)，.dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。<br>这个就是设备树的由来，简而言之就是，Linux 内核中 ARM 架构下有太多的冗余的垃圾板级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树。</p><h3 id="DTS、DTB、DTC"><a href="#DTS、DTB、DTC" class="headerlink" title="DTS、DTB、DTC"></a>DTS、DTB、DTC</h3><p>DTS 是设备树源码文件，DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！DTC 工具源码在 Linux 内核的 scripts&#x2F;dtc 目录下，scripts&#x2F;dtc&#x2F;Makefile 文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">hostprogs-y := dtc<br>always := $(hostprogs-y)<br><br>dtc-objs := dtc.o flattree.o fstree.o data.o livetree.o treesource.o \<br>srcpos.o checks.o util.o<br>dtc-objs += dtc-lexer.lex.o dtc-parser.tab.o<br>......<br></code></pre></td></tr></table></figure><p>可以看出，DTC 工具依赖于 dtc.c、flattree.c、fstree.c 等文件，最终编译并链接出 DTC 这个主机文件。如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行<code>make all</code>或者<code>make dtbs</code><br><code>make all</code>命令是编译 Linux 源码中的所有东西，包括 zImage，.ko 驱动模块以及设备树，如果只是编译设备树的话建议使用<code>make dtbs</code>命令。</p><p>基于 ARM 架构的 SOC 有很多种，一种 SOC 又可以制作出很多款板子，每个板子都有一个对应的 DTS 文件，那么如何确定编译哪一个 DTS 文件呢？我们就以 I.MX6ULL 这款芯片对应的板子为例来看一下，打开 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;Makefile，有如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6UL)</span> += \<br>imx6ul-14x14-ddr3-arm2.dtb \<br>imx6ul-14x14-ddr3-arm2-emmc.dtb \<br>......<br>dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6ULL)</span> += \<br>imx6ull-14x14-ddr3-arm2.dtb \<br>imx6ull-14x14-ddr3-arm2-adc.dtb \<br>imx6ull-14x14-ddr3-arm2-cs42888.dtb \<br>imx6ull-14x14-ddr3-arm2-ecspi.dtb \<br>imx6ull-14x14-ddr3-arm2-emmc.dtb \<br>imx6ull-14x14-ddr3-arm2-epdc.dtb \<br>imx6ull-14x14-ddr3-arm2-flexcan2.dtb \<br>imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb \<br>imx6ull-14x14-ddr3-arm2-lcdif.dtb \<br>imx6ull-14x14-ddr3-arm2-ldo.dtb \<br>imx6ull-14x14-ddr3-arm2-qspi.dtb \<br>imx6ull-14x14-ddr3-arm2-qspi-all.dtb \<br>imx6ull-14x14-ddr3-arm2-tsc.dtb \<br>imx6ull-14x14-ddr3-arm2-uart2.dtb \<br>imx6ull-14x14-ddr3-arm2-usb.dtb \<br>imx6ull-14x14-ddr3-arm2-wm8958.dtb \<br>imx6ull-14x14-evk.dtb \<br>imx6ull-14x14-evk-btwifi.dtb \<br>imx6ull-14x14-evk-emmc.dtb \<br>imx6ull-14x14-evk-gpmi-weim.dtb \<br>imx6ull-14x14-evk-usb-certi.dtb \<br>imx6ull-alientek-emmc.dtb \<br>imx6ull-alientek-nand.dtb \<br>imx6ull-9x9-evk.dtb \<br>imx6ull-9x9-evk-btwifi.dtb \<br>imx6ull-9x9-evk-ldo.dtb<br>dtb-<span class="hljs-variable">$(CONFIG_SOC_IMX6SLL)</span> += \<br>imx6sll-lpddr2-arm2.dtb \<br>imx6sll-lpddr3-arm2.dtb \<br>......<br></code></pre></td></tr></table></figure><p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL&#x3D;y)，所有使用到I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用 I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会将对应的.dts 编译为二进制的.dtb文件。</p><h3 id="DTS语法"><a href="#DTS语法" class="headerlink" title="DTS语法"></a>DTS语法</h3><h4 id="dtsi头文件"><a href="#dtsi头文件" class="headerlink" title="dtsi头文件"></a>dtsi头文件</h4><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-alientek-emmc.dts 中有如下所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/input/input.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;imx6ull.dtsi&quot;</span></span><br></code></pre></td></tr></table></figure><p>在.dts 设备树文件中，可以通过“#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。</p><p>一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。比如 imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息的，内容如下：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi1.png" class="" title="dtsi1"><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/dtsi2.png" class="" title="dtsi2"><p>示例代码 43.3.1.3 中第 54<del>89 行就是 cpu0 这个设备节点信息，这个节点信息描述了I.MX6ULL 这颗 SOC 所使用的 CPU 信息，比如架构是 cortex-A7，频率支持 996MHz、792MHz、528MHz、396MHz 和 198MHz 等等。在 imx6ull.dtsi 文件中不仅仅描述了 cpu0 这一个节点信息，I.MX6ULL 这颗 SOC 所有的外设都描述的清清楚楚，比如 ecspi1</del>4、uart1<del>8、usbphy1</del>2、i2c1~4等等</p><h4 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h4><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。以下是从imx6ull.dtsi 文件中缩减出来的设备树文件内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">/ &#123;<br>    aliases &#123;<br>        can0 = &amp;flexcan1;<br>    &#125;;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    intc: interrupt-controller@<span class="hljs-number">00</span>a01000 &#123;<br>        compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<br>        <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>;</span><br>        interrupt-controller;<br>        reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<br>        &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>第 1 行，“&#x2F;”是根节点，每个设备树文件只有一个根节点。细心的同学应该会发现，imx6ull.dtsi和 imx6ull-alientek-emmc.dts 这两个文件都有一个“&#x2F;”根节点，这样不会出错吗？不会的，因为这两个“&#x2F;”根节点的内容会合并成一个根节点。</p><p>第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">node-name@unit-address<br></code></pre></td></tr></table></figure><p>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。<br>但是我们在示例代码 43.3.2.1 中我们看到的节点命名却如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu0:cpu@<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">label: node-name@unit-address<br></code></pre></td></tr></table></figure><p>引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。再比如节点 “intc: interrupt-controller@00a01000”，节点 label 是 intc，而节点名字就很长了，为“interruptcontroller@00a01000”。很明显通过&amp;intc 来访问“interrupt-controller@00a01000”这个节点要方便很多！<br>每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。</p><p>设备树源码中常用的几种数据形式如下所示：<br>1、字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<span class="hljs-comment">//设置 compatible 属性的值为字符串“arm,cortex-a7”。</span><br></code></pre></td></tr></table></figure><p>2、32位无符号整数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">reg = &lt;<span class="hljs-number">0</span>&gt;;<span class="hljs-comment">//设置 reg 属性的值为 0</span><br><span class="hljs-comment">//reg 的值也可以设置为一组值，例如：</span><br>reg = &lt;<span class="hljs-number">0</span> <span class="hljs-number">0x123456</span> <span class="hljs-number">100</span>&gt;;<br></code></pre></td></tr></table></figure><p>3、字符串列表<br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-gpmi-nand&quot;</span>, <span class="hljs-string">&quot;fsl, imx6ul-gpmi-nand&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h4><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性，Linux 下的很多外设驱动都会使用这些标准属性。</p><h5 id="compatible属性"><a href="#compatible属性" class="headerlink" title="compatible属性"></a>compatible属性</h5><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;manufacturer,model&quot;</span><br></code></pre></td></tr></table></figure><p>其中 manufacturer 表示厂商，model 一般是模块对应的驱动名字。比如 imx6ull-alientek-emmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点，I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960，sound 节点的 compatible 属性值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,<span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>;<br></code></pre></td></tr></table></figure><p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p><p>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。<br>比如在文件 imx-wm8960.c 中有如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">632</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">imx_wm8960_dt_ids</span>[] =</span> &#123;<br><span class="hljs-number">633</span>     &#123; .compatible = <span class="hljs-string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,<br><span class="hljs-number">634</span>     &#123; <span class="hljs-comment">/* sentinel */</span> &#125;<br><span class="hljs-number">635</span> &#125;;<br><span class="hljs-number">636</span> MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);<br><span class="hljs-number">637</span><br><span class="hljs-number">638</span> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">imx_wm8960_driver</span> =</span> &#123;<br><span class="hljs-number">639</span>     .driver = &#123;<br><span class="hljs-number">640</span>         .name = <span class="hljs-string">&quot;imx-wm8960&quot;</span>,<br><span class="hljs-number">641</span>         .pm = &amp;snd_soc_pm_ops,<br><span class="hljs-number">642</span>         .of_match_table = imx_wm8960_dt_ids,<br><span class="hljs-number">643</span>     &#125;,<br><span class="hljs-number">644</span>     .probe = imx_wm8960_probe,<br><span class="hljs-number">645</span>     .remove = imx_wm8960_remove,<br><span class="hljs-number">646</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 632-635 行的数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br>第 642 行，wm8960 采用了 platform_driver 驱动模式，此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个 platform_driver 所使用的OF 匹配表。</p><h5 id="model属性"><a href="#model属性" class="headerlink" title="model属性"></a>model属性</h5><p>model属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">model = <span class="hljs-string">&quot;wm8960-audio&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="status属性"><a href="#status属性" class="headerlink" title="status属性"></a>status属性</h5><p>status 属性看名字就知道是和设备状态有关的，status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表所示：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>okay</td><td>表明设备是可操作的</td></tr><tr><td>disabled</td><td>表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。</td></tr><tr><td>fail</td><td>表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。</td></tr><tr><td>fail-sss</td><td>含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td></tr></tbody></table><h5 id="address-cells和-size-cells属性"><a href="#address-cells和-size-cells属性" class="headerlink" title="#address-cells和#size-cells属性"></a>#address-cells和#size-cells属性</h5><p>这两个属性的值都是无符号 32 位整形，#address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)，#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。#address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度，reg 属性的格式一为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;<br></code></pre></td></tr></table></figure><p>每个“address length”组合表示一个地址范围，其中 address 是起始地址，length 是地址长度，#address-cells 表明 address 这个数据所占用的字长，#size-cells 表明 length 这个数据所占用的字长，比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C">spi4 &#123;<br>    compatible = <span class="hljs-string">&quot;spi-gpio&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>    gpio_spi: gpio_spi@<span class="hljs-number">0</span> &#123;<br>        compatible = <span class="hljs-string">&quot;fairchild,74hc595&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0</span>&gt;;<br>    &#125;;<br>&#125;;<br><br>aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><br>    dcp: dcp@<span class="hljs-number">02280000</span> &#123;<br>        compatible = <span class="hljs-string">&quot;fsl,imx6sl-dcp&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0x02280000</span> <span class="hljs-number">0x4000</span>&gt;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第 3，4 行，节点 spi4 的#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，说明 spi4 的子节点 reg 属性中起始地址所占用的字长为 1，地址长度所占用的字长为 0。<br>第 8 行，子节点 gpio_spi: gpio_spi@0 的 reg 属性值为 &lt;0&gt;，因为父节点设置了#addresscells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;0&gt;，因此 addres&#x3D;0，没有 length 的值相当于设置了起始地址，而没有设置地址长度。<br>第 14，15 行，设置 aips3: aips-bus@02200000 节点#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1。<br>第 19 行，子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;，因为父节点设置了#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，address&#x3D; 0x02280000，length&#x3D; 0x4000，相当于设置了起始地址为 0x02280000，地址长度为 0x40000。</p><h5 id="reg属性"><a href="#reg属性" class="headerlink" title="reg属性"></a>reg属性</h5><p>reg 属性前面已经提到过了，reg 属性的值一般是(address，length)对。reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，比如在 imx6ull.dtsi 中有如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uart1: serial@<span class="hljs-number">02020000</span> &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-uart&quot;</span>,<br><span class="hljs-string">&quot;fsl,imx6q-uart&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-uart&quot;</span>;<br>reg = &lt;<span class="hljs-number">0x02020000</span> <span class="hljs-number">0x4000</span>&gt;;<br>interrupts = &lt;GIC_SPI <span class="hljs-number">26</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br>clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,<br>&lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;<br>clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<br>status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码是节点 uart1，uart1 节点描述了 I.MX6ULL 的 UART1 相关信息，重点是第 326 行的 reg 属性。其中 uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、#sizecells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000，length&#x3D;0x4000。查阅《I.MX6ULL 参考手册》可知，I.MX6ULL 的 UART1 寄存器首地址为 0x02020000，但是 UART1 的地址长度(范围)并没有 0x4000 这么多，这里我们重点是获取 UART1 寄存器首地址。</p><h5 id="ranges属性"><a href="#ranges属性" class="headerlink" title="ranges属性"></a>ranges属性</h5><p>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵，ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：<br><strong>child-bus-address</strong>：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>parent-bus-address</strong>：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br><strong>length</strong>：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。</p><p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于我们所使用的 I.MX6ULL 来说，子地址空间和父地址空间完全相同，因此会在 imx6ull.dtsi中找到大量的值为空的 ranges 属性，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">137</span> soc &#123;<br><span class="hljs-number">138</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">139</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">140</span> compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br><span class="hljs-number">141</span> interrupt-parent = &lt;&amp;gpc&gt;;<br><span class="hljs-number">142</span> ranges;<br>......<br><span class="hljs-number">1177</span> &#125;<br></code></pre></td></tr></table></figure><p>第 142 行定义了 ranges 属性，但是 ranges 属性值为空。<br>ranges 属性不为空的示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">soc &#123;<br>    compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    ranges = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0xe0000000</span> <span class="hljs-number">0x00100000</span>&gt;;<br><br>    serial &#123;<br>        device_type = <span class="hljs-string">&quot;serial&quot;</span>;<br>        compatible = <span class="hljs-string">&quot;ns16550&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;;<br>        clock-frequency = &lt;<span class="hljs-number">0</span>&gt;;<br>        interrupts = &lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;;<br>        interrupt-parent = &lt;&amp;ipic&gt;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第 5 行，节点 soc 定义的 ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。<br>第 10 行，serial 是串口设备节点，reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换，serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。</p><h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>name 属性值为字符串，name 属性用于记录节点名字，name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p><h5 id="device-type属性"><a href="#device-type属性" class="headerlink" title="device_type属性"></a>device_type属性</h5><p>device_type 属性值为字符串，IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设备树没有 FCode，所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。imx6ull.dtsi 的 cpu0 节点用到了此属性，内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>reg = &lt;<span class="hljs-number">0</span>&gt;;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="根节点compatible属性"><a href="#根节点compatible属性" class="headerlink" title="根节点compatible属性"></a>根节点compatible属性</h4><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外，imx6ull-alientek-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">/ &#123;<br>model = <span class="hljs-string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，那么根节点中的 compatible属性是为了做什么工作的？ 通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第二个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。接下来我们就来学习一下 Linux 内核在使用设备树前后是如何判断是否支持某款设备的。</p><h6 id="使用设备树的设备匹配方法"><a href="#使用设备树的设备匹配方法" class="headerlink" title="使用设备树的设备匹配方法"></a>使用设备树的设备匹配方法</h6><p>DT_MACHINE_START 也定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h里面，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span><br><span class="hljs-meta">static const struct machine_desc __mach_desc_##_name \</span><br><span class="hljs-meta">__used \</span><br><span class="hljs-meta">__attribute__((__section__(<span class="hljs-string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span><br><span class="hljs-meta"> .nr = ~0, \</span><br><span class="hljs-meta"> .name = _namestr,</span><br></code></pre></td></tr></table></figure><p>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *imx6ul_dt_compat[] __initconst = &#123;<br><span class="hljs-string">&quot;fsl,imx6ul&quot;</span>,<br><span class="hljs-string">&quot;fsl,imx6ull&quot;</span>,<br><span class="hljs-literal">NULL</span>,<br>&#125;;<br><br>DT_MACHINE_START(IMX6UL, <span class="hljs-string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)<br>.map_io = imx6ul_map_io,<br>.init_irq = imx6ul_init_irq,<br>.init_machine = imx6ul_init_machine,<br>.init_late = imx6ul_init_late,<br>.dt_compat = imx6ul_dt_compat,<br>MACHINE_END<br></code></pre></td></tr></table></figure><p>machine_desc 结构体中有个.dt_compat 成员变量，此成员变量保存着本设备兼容属性，示例代码中设置.dt_compat &#x3D; imx6ul_dt_compat，imx6ul_dt_compat 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“&#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。imx6ull-alientek-emmc.dts 中根节点的 compatible 属性值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br></code></pre></td></tr></table></figure><p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。如果将 imx6ull-alientek-emmc.dts 根节点的 compatible 属性改为其他的值，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ullll&quot;</span><br></code></pre></td></tr></table></figure><p>重新编译 DTS，并用新的 DTS 启动 Linux 内核，结果如图所示的错误提示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/error.png" class="" title="error"><p>当我们修改了根节点 compatible 属性内容以后，因为 Linux 内核找不到对应的设备，因此Linux 内核无法启动。在 uboot 输出 Starting kernel…以后就再也没有其他信息输出了。</p><p>接下来我们简单看一下 Linux 内核是如何根据设备树根节点的 compatible 属性来匹配出对应的 machine_desc，Linux 内核调用 start_kernel 函数来启动内核，start_kernel 函数会调用setup_arch 函数来匹配 machine_desc，setup_arch 函数定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中，函数内容如下(有缩减)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">913</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span><br>914 &#123;<br><span class="hljs-number">915</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>;</span><br><span class="hljs-number">916</span><br><span class="hljs-number">917</span> setup_processor();<br><span class="hljs-number">918</span> mdesc = setup_machine_fdt(__atags_pointer);<br><span class="hljs-number">919</span> <span class="hljs-keyword">if</span> (!mdesc)<br><span class="hljs-number">920</span> mdesc = setup_machine_tags(__atags_pointer, <br>__machine_arch_type);<br><span class="hljs-number">921</span> machine_desc = mdesc;<br><span class="hljs-number">922</span> machine_name = mdesc-&gt;name;<br>......<br><span class="hljs-number">986</span> &#125;<br></code></pre></td></tr></table></figure><p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址，setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。<br>函数 setup_machine_fdt 定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 中，内容如下(有缩减)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">204</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> machine_desc * __init <span class="hljs-title function_">setup_machine_fdt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dt_phys)</span><br>205 &#123;<br><span class="hljs-number">206</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">machine_desc</span> *<span class="hljs-title">mdesc</span>, *<span class="hljs-title">mdesc_best</span> =</span> <span class="hljs-literal">NULL</span>;<br>......<br><span class="hljs-number">214</span><br><span class="hljs-number">215</span> <span class="hljs-keyword">if</span> (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))<br><span class="hljs-number">216</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">217</span><br><span class="hljs-number">218</span> mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);<br><span class="hljs-number">219</span><br>......<br><span class="hljs-number">247</span> __machine_arch_type = mdesc-&gt;nr;<br><span class="hljs-number">248</span><br><span class="hljs-number">249</span> <span class="hljs-keyword">return</span> mdesc;<br><span class="hljs-number">250</span> &#125;<br></code></pre></td></tr></table></figure><p>第 218 行，调用函数 of_flat_dt_match_machine 来获取匹配的 machine_desc，参数 mdesc_best是默认的 machine_desc ，参数 arch_get_next_mach 是个函数，此函数定义在定义在arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 文件中。找到匹配的 machine_desc 的过程就是用设备树根节点的compatible 属性值和 Linux 内核中 machine_desc 下.dt_compat 的值比较，看看那个相等，如果相等的话就表示找到匹配的 machine_desc，arch_get_next_mach 函数的工作就是获取 Linux 内核中下一个 machine_desc 结构体。<br>最后再来看一下 of_flat_dt_match_machine 函数，此函数定义在文件 drivers&#x2F;of&#x2F;fdt.c 中，内容如下(有缩减)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">705</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> * __init <span class="hljs-title function_">of_flat_dt_match_machine</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span></span><br><span class="hljs-params">*default_match,</span><br><span class="hljs-params"><span class="hljs-number">706</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> * (*get_next_compat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span>**))</span><br>707 &#123;<br><span class="hljs-number">708</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data = <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">709</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *best_data = default_match;<br><span class="hljs-number">710</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> *compat;<br><span class="hljs-number">711</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dt_root;<br><span class="hljs-number">712</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> best_score = ~<span class="hljs-number">1</span>, score = <span class="hljs-number">0</span>;<br><span class="hljs-number">713</span><br><span class="hljs-number">714</span> dt_root = of_get_flat_dt_root();<br><span class="hljs-number">715</span> <span class="hljs-keyword">while</span> ((data = get_next_compat(&amp;compat))) &#123;<br><span class="hljs-number">716</span> score = of_flat_dt_match(dt_root, compat);<br><span class="hljs-number">717</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">0</span> &amp;&amp; score &lt; best_score) &#123;<br><span class="hljs-number">718</span> best_data = data;<br><span class="hljs-number">719</span> best_score = score;<br><span class="hljs-number">720</span> &#125;<br><span class="hljs-number">721</span> &#125;<br>......<br><span class="hljs-number">739</span><br><span class="hljs-number">740</span> pr_info(<span class="hljs-string">&quot;Machine model: %s\n&quot;</span>, of_flat_dt_get_machine_name());<br><span class="hljs-number">741</span><br><span class="hljs-number">742</span> <span class="hljs-keyword">return</span> best_data;<br><span class="hljs-number">743</span> &#125;<br></code></pre></td></tr></table></figure><p>第 714 行，通过函数 of_get_flat_dt_root 获取设备树根节点。<br>第 715-720 行，此循环就是查找匹配的 machine_desc 过程，第 716 行的 of_flat_dt_match 函数会将根节点 compatible 属性的值和每个 machine_desc 结构体中. dt_compat 的值进行比较，直至找到匹配的那个 machine_desc。<br>总结一下，Linux 内核通过根节点 compatible 属性找到对应的设备的函数调用过程，如图所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/start_kernel.png" class="" title="start_kernel"><h4 id="向节点追加或修改内容"><a href="#向节点追加或修改内容" class="headerlink" title="向节点追加或修改内容"></a>向节点追加或修改内容</h4><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片fxls8471，fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.1 i2c1 节点</span><br><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-number">938</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">939</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">940</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-number">941</span> reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">942</span> interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-number">943</span> clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-number">944</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">945</span> &#125;;<br></code></pre></td></tr></table></figure><p>示例代码 43.3.5.1 就是 I.MX6ULL 的 I2C1 节点，现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.2 添加 fxls8471 子节点</span><br><span class="hljs-number">937</span> i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-number">938</span> <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-number">939</span> <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><span class="hljs-number">940</span> compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br><span class="hljs-number">941</span> reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<br><span class="hljs-number">942</span> interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br><span class="hljs-number">943</span> clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<br><span class="hljs-number">944</span> status = <span class="hljs-string">&quot;disabled&quot;</span>;<br><span class="hljs-number">945</span><br><span class="hljs-number">946</span> <span class="hljs-comment">//fxls8471 子节点</span><br><span class="hljs-number">947</span> fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-number">948</span> compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-number">949</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<br><span class="hljs-number">950</span> &#125;;<br><span class="hljs-number">951</span> &#125;;<br></code></pre></td></tr></table></figure><p>第 947-950 行就是添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码 43.3.5.2 这样写肯定是不行的。<br>这里就要引入另外一个内容，那就是如何向节点追加数据，我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-alientek-emmc.dts，因此我们需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.3 节点追加数据方法</span><br>&amp;i2c1 &#123;<br><span class="hljs-comment">/* 要追加或修改的内容 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>第 1 行，&amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1: i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。<br>打开 imx6ull-alientek-emmc.dts，找到如下所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.5.4 向 i2c1 节点追加数据</span><br><span class="hljs-number">224</span> &amp;i2c1 &#123;<br><span class="hljs-number">225</span> clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br><span class="hljs-number">226</span> pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br><span class="hljs-number">227</span> pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br><span class="hljs-number">228</span> status = <span class="hljs-string">&quot;okay&quot;</span>;<br><span class="hljs-number">229</span><br><span class="hljs-number">230</span> mag3110@<span class="hljs-number">0</span>e &#123;<br><span class="hljs-number">231</span> compatible = <span class="hljs-string">&quot;fsl,mag3110&quot;</span>;<br><span class="hljs-number">232</span> reg = &lt;<span class="hljs-number">0x0e</span>&gt;;<br><span class="hljs-number">233</span> position = &lt;<span class="hljs-number">2</span>&gt;;<br><span class="hljs-number">234</span> &#125;;<br><span class="hljs-number">235</span><br><span class="hljs-number">236</span> fxls8471@<span class="hljs-number">1</span>e &#123;<br><span class="hljs-number">237</span> compatible = <span class="hljs-string">&quot;fsl,fxls8471&quot;</span>;<br><span class="hljs-number">238</span> reg = &lt;<span class="hljs-number">0x1e</span>&gt;;<br><span class="hljs-number">239</span> position = &lt;<span class="hljs-number">0</span>&gt;;<br><span class="hljs-number">240</span> interrupt-parent = &lt;&amp;gpio5&gt;;<br><span class="hljs-number">241</span> interrupts = &lt;<span class="hljs-number">0</span> <span class="hljs-number">8</span>&gt;;<br><span class="hljs-number">242</span> &#125;;<br><span class="hljs-number">243</span> &#125;;<br></code></pre></td></tr></table></figure><p>示例代码 43.3.5.4 就是向 i2c1 节点添加&#x2F;修改数据，比如第 225 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第 228 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 230-234 行，i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用mag3110。<br>第 236-242 行，i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。<br>因为示例代码 43.3.5.4 中的内容是 imx6ull-alientek-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容。</p><h3 id="创建小型模板设备树"><a href="#创建小型模板设备树" class="headerlink" title="创建小型模板设备树"></a>创建小型模板设备树</h3><p>上一节已经对 DTS 的语法做了比较详细的讲解，本节我们就根据前面讲解的语法，从头到尾编写一个小型的设备树文件。当然了，这个小型设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。在实际产品开发中，我们是不需要完完全全的重写一个.dts 设备树文件，一般都是使用 SOC 厂商提供好的.dts 文件，我们只需要在上面根据自己的实际情况做相应的修改即可。在编写设备树之前要先定义一个设备，我们就以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：<br>①、I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000，大小为 0x4000。<br>④、I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为 0x02184000，大小为 0x4000。<br>⑤、I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。<br>为了简单起见，我们就在设备树里面就实现这些内容即可，首先，搭建一个仅含有根节点“&#x2F;”的基础的框架，新建一个名为 myfirst.dts 文件，在里面输入如下所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.1 设备树基础框架</span><br>/ &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设备树框架很简单，就一个根节点“&#x2F;”，根节点里面只有一个 compatible 属性。我们就在这个基础框架上面将上面列出的内容一点点添加进来。</p><p>1、添加cpus节点</p><p>首先添加 CPU 节点，I.MX6ULL 采用 Cortex-A7 架构，而且只有一个 CPU，因此只有一个cpu0 节点，完成以后如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.2 添加 CPU0 节点</span><br>/ &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br>    <br>cpus &#123;<br><span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>    <br><span class="hljs-comment">//CPU0 节点</span><br>cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>reg = &lt;<span class="hljs-number">0</span>&gt;;<br>&#125;;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>第 4~14 行，cpus 节点，此节点用于描述 SOC 内部的所有 CPU，因为 I.MX6ULL 只有一个CPU，因此只有一个 cpu0 子节点。</p><p>2、添加soc节点</p><p>像 uart，iic 控制器等等这些都属于 SOC 内部外设，因此一般会创建一个叫做 soc 的父节点来管理这些 SOC 内部外设的子节点，添加 soc 节点以后的 myfirst.dts 文件内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.3 添加 soc 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>第 17~22 行，soc 节点，soc 节点设置#address-cells &#x3D; &lt;1&gt;，#size-cells &#x3D; &lt;1&gt;，这样 soc 子节点的 reg 属性中起始地占用一个字长，地址空间长度也占用一个字长。<br>第 21 行，ranges 属性，ranges 属性为空，说明子空间和父空间地址范围相同。</p><p>3、添加ocram节点</p><p>根据第②点的要求，添加 ocram 节点，ocram 是 I.MX6ULL 内部 RAM，因此 ocram 节点应该是 soc 节点的子节点。ocram 起始地址为 0x00900000，大小为 128KB(0x20000)，添加 ocram节点以后 myfirst.dts 文件内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.4 添加 ocram 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>        compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>        device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>        reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>第 24~27 行，ocram 节点，第 24 行节点名字@后面的 0x00900000 就是 ocram 的起始地址。<br>第 26 行的 reg 属性也指明了 ocram 内存的起始地址为 0x00900000，大小为 0x20000。</p><p>4、添加 aips1、aips2 和 aips3 这三个子节点</p><p>I.MX6ULL 内部分为三个域：aips1-3，这三个域分管不同的外设控制器，aips1-3 这三个域对应的内存范围如表所示：</p><table><thead><tr><th>域</th><th>起始地址</th><th>大小（十六进制）</th></tr></thead><tbody><tr><td>AIPS1</td><td>0x02000000</td><td>0x100000</td></tr><tr><td>AIPS2</td><td>0x02100000</td><td>0x100000</td></tr><tr><td>AIPS3</td><td>0x02200000</td><td>0x100000</td></tr></tbody></table><p>我们先在设备树中添加这三个域对应的子节点。aips1~3 这三个域都属于 soc 节点的子节点，完成以后的 myfirst.dts 文件内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.5 添加 aips1~3 节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br><br>        <span class="hljs-comment">//aips1 节点</span><br>        aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br><br>        <span class="hljs-comment">//aips2 节点</span><br>        aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br><br>        <span class="hljs-comment">//aips3 节点 </span><br>        aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、添加 ecspi1、usbotg1 和 rngb 这三个外设控制器节点</p><p>最后我们在 myfirst.dts 文件中加入 ecspi1，usbotg1 和 rngb 这三个外设控制器对应的节点，其中 ecspi1 属于 aips1 的子节点，usbotg1 属于 aips2 的子节点，rngb 属于 aips3 的子节点。最终的 myfirst.dts 文件内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.4.6 添加 ecspi1、usbotg1 和 rngb 这三个节点</span><br>/ &#123;<br>    compatible = <span class="hljs-string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="hljs-string">&quot;fsl,imx6ull&quot;</span>;<br><br>    cpus &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br><br>        <span class="hljs-comment">//CPU0 节点</span><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123;<br>            compatible = <span class="hljs-string">&quot;arm,cortex-a7&quot;</span>;<br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;;<br>        &#125;;<br>    &#125;;<br><br>    <span class="hljs-comment">//soc 节点</span><br>    soc &#123;<br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>        ranges;<br><br>        <span class="hljs-comment">//ocram 节点</span><br>        ocram: sram@<span class="hljs-number">00900000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,lpm-sram&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x00900000</span> <span class="hljs-number">0x20000</span>&gt;;<br>        &#125;;<br><br>        <span class="hljs-comment">//aips1 节点</span><br>        aips1: aips-bus@<span class="hljs-number">02000000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02000000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//ecspi1 节点</span><br>            ecspi1: ecspi@<span class="hljs-number">02008000</span> &#123;<br>                <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>                <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>                compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02008000</span> <span class="hljs-number">0x4000</span>&gt;;<br>                status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//aips2 节点</span><br>        aips2: aips-bus@<span class="hljs-number">02100000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02100000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//usbotg1 节点</span><br>            usbotg1: usb@<span class="hljs-number">02184000</span> &#123;<br>                compatible = <span class="hljs-string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="hljs-string">&quot;fsl,imx27-usb&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02184000</span> <span class="hljs-number">0x4000</span>&gt;;<br>                status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//aips3 节点 </span><br>        aips3: aips-bus@<span class="hljs-number">02200000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;fsl,aips-bus&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>            reg = &lt;<span class="hljs-number">0x02200000</span> <span class="hljs-number">0x100000</span>&gt;;<br>            ranges;<br><br>            <span class="hljs-comment">//rngb 节点</span><br>            rngb: rngb@<span class="hljs-number">02284000</span> &#123;<br>                compatible = <span class="hljs-string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="hljs-string">&quot;fsl,imx-rng&quot;</span>, <span class="hljs-string">&quot;imx-rng&quot;</span>;<br>                reg = &lt;<span class="hljs-number">0x02284000</span> <span class="hljs-number">0x4000</span>&gt;;<br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，myfirst.dts 这个小型的模板设备树就编写好了，基本和 imx6ull.dtsi 很像，可以看做是 imx6ull.dtsi 的缩小版。在 myfirst.dts 里面我们仅仅是编写了 I.MX6ULL 的外设控制器节点，像 IIC 接口，SPI 接口下所连接的具体设备我们并没有写，因为具体的设备其设备树属性内容不同，这个等到具体的实验在详细讲解。</p><h3 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h3><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹，如图 43.5.1 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/a.png" class="" title="a"><p>图 43.5.1 就是目录&#x2F;proc&#x2F;device-tree 目录下的内容，&#x2F;proc&#x2F;device-tree 目录下是根节点“&#x2F;”的所有属性和子节点，我们依次来看一下这些属性和子节点。</p><p>1、根节点 “&#x2F;” 各个属性值</p><p>在图 43.5.1 中，根节点属性属性表现为一个个的文件(图中细字体文件)，比如图 43.5.1 中的“#address-cells”、“#size-cells”、“compatible”、“model”和“name”这 5 个文件，它们在设备树中就是根节点的 5个属性。既然是文件那么肯定可以查看其内容，输入 cat 命令来查看 model和 compatible 这两个文件的内容，结果如图 43.5.2 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/b.png" class="" title="b"><p>从图 43.5.2 可以看出，文件 model 的内容是“Freescale i.MX6 ULL 14x14 EVK Board”，文件 compatible 的内容为“fsl,imx6ull-14x14-evkfsl,imx6ull”。打开文件 imx6ull-alientek-emmc.dts查看一下，这不正是根节点“&#x2F;”的 model 和 compatible 属性值吗！</p><p>2、根节点 “&#x2F;” 各子节点</p><p>图 43.5.1 中各个文件夹(图中粗字体文件夹)就是根节点“&#x2F;”的各个子节点，比如“aliases”、“backlight”、“chosen”和“clocks”等等。大家可以查看一下 imx6ull-alientek-emmc.dts 和imx6ull.dtsi 这两个文件，看看根节点的子节点都有哪些，看看是否和图 43.5.1 中的一致。<br>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点，如图 43.5.3 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/c.png" class="" title="c"><p>和根节点“&#x2F;”一样，图 43.5.3 中的所有文件分别为 soc 节点的属性文件和子节点文件夹。大家可以自行查看一下这些属性文件的内容是否和 imx6ull.dtsi 中 soc 节点的属性值相同，也可以进入“busfreq”这样的文件夹里面查看 soc 节点的子节点信息。</p><h3 id="特殊节点"><a href="#特殊节点" class="headerlink" title="特殊节点"></a>特殊节点</h3><p>在根节点“&#x2F;”中有两个特殊的子节点：aliases 和 chosen，我们接下来看一下这两个特殊的子节点。</p><h4 id="aliases子节点"><a href="#aliases子节点" class="headerlink" title="aliases子节点"></a>aliases子节点</h4><p>打开 imx6ull.dtsi 文件，aliases 节点内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.1.1 aliases 子节点</span><br><span class="hljs-number">18</span> aliases &#123;<br><span class="hljs-number">19</span>      can0 = &amp;flexcan1;<br><span class="hljs-number">20</span>      can1 = &amp;flexcan2;<br><span class="hljs-number">21</span>      ethernet0 = &amp;fec1;<br><span class="hljs-number">22</span>      ethernet1 = &amp;fec2;<br><span class="hljs-number">23</span>      gpio0 = &amp;gpio1;<br><span class="hljs-number">24</span>      gpio1 = &amp;gpio2;<br>        ......       <br><span class="hljs-number">42</span>      spi0 = &amp;ecspi1;<br><span class="hljs-number">43</span>      spi1 = &amp;ecspi2;<br><span class="hljs-number">44</span>      spi2 = &amp;ecspi3;<br><span class="hljs-number">45</span>      spi3 = &amp;ecspi4;<br><span class="hljs-number">46</span>      usbphy0 = &amp;usbphy1;<br><span class="hljs-number">47</span>      usbphy1 = &amp;usbphy2;<br><span class="hljs-number">48</span> &#125;;<br></code></pre></td></tr></table></figure><p>单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p><h4 id="chosen子节点"><a href="#chosen子节点" class="headerlink" title="chosen子节点"></a>chosen子节点</h4><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少，imx6ull-alientek-emmc.dts 中 chosen 节点内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.2.1 chosen 子节点</span><br>chosen &#123;<br><span class="hljs-built_in">stdout</span>-path = &amp;uart1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从示例代码 43.6.2.1 中可以看出，chosen 节点仅仅设置了属性“stdout-path”，表示标准输出使用 uart1。但是当我们进入到&#x2F;proc&#x2F;device-tree&#x2F;chosen 目录里面，会发现多了 bootargs 这个属性，如图 43.6.2.1 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/d.png" class="" title="d"><p>输入 cat 命令查看 bootargs 这个文件的内容，结果如图 43.6.2.2 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/e.png" class="" title="e"><p>从图 43.6.2.2 可以看出，bootargs 这个文件的内容为“console&#x3D;ttymxc0,115200……”，这个不就是我们在 uboot 中设置的 bootargs 环境变量的值吗？现在有两个疑点：<br>①、我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么图 43.6.2.1 中 bootargs这个属性是怎么产生的？<br>②、为何 bootargs 文件的内容和 uboot 中 bootargs 环境变量的值一样？它们之间有什么关系？</p><p>前面讲解 uboot 的时候说过，uboot 在启动 Linux 内核的时候会将 bootargs 的值传递给 Linux内核，bootargs 会作为 Linux 内核的命令行参数，Linux 内核启动的时候会打印出命令行参数(也就是 uboot 传递进来的 bootargs 的值)，如图 43.6.2.3 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/f.png" class="" title="f"><p>既然 chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性！并且设置 bootargs 属性的值为 bootargs环境变量的值。因为在启动 Linux 内核之前，只有 uboot 知道 bootargs 环境变量的值，并且 uboot也知道.dtb 设备树文件在 DRAM 中的位置，因此 uboot 的“作案”嫌疑最大。在 uboot 源码中全局搜索“chosen”这个字符串，看看能不能找到一些蛛丝马迹。果然不出所料，在common&#x2F;fdt_support.c 文件中发现了“chosen”的身影，fdt_support.c 文件中有个 fdt_chosen 函数，此函数内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.6.2.2 uboot 源码中的 fdt_chosen 函数</span><br><span class="hljs-number">275</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fdt_chosen</span><span class="hljs-params">(<span class="hljs-type">void</span> *fdt)</span><br>276 &#123;<br><span class="hljs-number">277</span>     <span class="hljs-type">int</span> nodeoffset;<br><span class="hljs-number">278</span>     <span class="hljs-type">int</span> err;<br><span class="hljs-number">279</span>     <span class="hljs-type">char</span> *str; <span class="hljs-comment">/* used to set string properties */</span><br><span class="hljs-number">280</span><br><span class="hljs-number">281</span>     err = fdt_check_header(fdt);<br><span class="hljs-number">282</span>     <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">283</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));<br><span class="hljs-number">284</span>         <span class="hljs-keyword">return</span> err;<br><span class="hljs-number">285</span>     &#125;<br><span class="hljs-number">286</span><br><span class="hljs-number">287</span>     <span class="hljs-comment">/* find or create &quot;/chosen&quot; node. */</span><br><span class="hljs-number">288</span>     nodeoffset = fdt_find_or_add_subnode(fdt, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;chosen&quot;</span>);<br><span class="hljs-number">289</span>     <span class="hljs-keyword">if</span> (nodeoffset &lt; <span class="hljs-number">0</span>)<br><span class="hljs-number">290</span>         <span class="hljs-keyword">return</span> nodeoffset;<br><span class="hljs-number">291</span><br><span class="hljs-number">292</span>     str = getenv(<span class="hljs-string">&quot;bootargs&quot;</span>);<br><span class="hljs-number">293</span>     <span class="hljs-keyword">if</span> (str) &#123;<br><span class="hljs-number">294</span>         err = fdt_setprop(fdt, nodeoffset, <span class="hljs-string">&quot;bootargs&quot;</span>, str,<br><span class="hljs-number">295</span>         <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br><span class="hljs-number">296</span>         <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">297</span>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,<br><span class="hljs-number">298</span>             fdt_strerror(err));<br><span class="hljs-number">299</span>             <span class="hljs-keyword">return</span> err;<br><span class="hljs-number">300</span>         &#125;<br><span class="hljs-number">301</span>     &#125;<br><span class="hljs-number">302</span><br><span class="hljs-number">303</span>     <span class="hljs-keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);<br><span class="hljs-number">304</span> &#125;<br></code></pre></td></tr></table></figure><p>第 288 行，调用函数 fdt_find_or_add_subnode 从设备树(.dtb)中找到 chosen 节点，如果没有找到的话就会自己创建一个 chosen 节点。<br>第 292 行，读取 uboot 中 bootargs 环境变量的内容。<br>第 294 行，调用函数 fdt_setprop 向 chosen 节点添加 bootargs 属性，并且 bootargs 属性的值就是环境变量 bootargs 的内容。<br>证据“实锤”了，就是 uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。接下来我们顺着 fdt_chosen 函数一点点的抽丝剥茧，看看都有哪些函数调用了 fdt_chosen，一直找到最终的源头。见图 43.6.2.4：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/g.png" class="" title="g"><p>图 43.6.2.4 中框起来的部分就是函数 do_bootm_linux 函数的执行流程，也就是说do_bootm_linux 函数会通过一系列复杂的调用，最终通过 fdt_chosen 函数在 chosen 节点中加入了 bootargs 属性。而我们通过 bootz 命令启动 Linux 内核的时候会运行 do_bootm_linux 函数，至此，真相大白，一切事情的源头都源于如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bootz 80800000 – 83000000<br></code></pre></td></tr></table></figure><h3 id="Linux-内核解析-DTB-文件"><a href="#Linux-内核解析-DTB-文件" class="headerlink" title="Linux 内核解析 DTB 文件"></a>Linux 内核解析 DTB 文件</h3><p>Linux 内核在启动的时候会解析 DTB 文件，然后在&#x2F;proc&#x2F;device-tree 目录下生成相应的设备树节点文件。接下来我们简单分析一下 Linux 内核是如何解析 DTB 文件的，流程如图 43.7.1 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/h.png" class="" title="h"><p>从图 43.7.1 中可以看出，在 start_kernel 函数中完成了设备树节点解析的工作，最终实际工作的函数为 unflatten_dt_node。</p><h3 id="绑定信息文档"><a href="#绑定信息文档" class="headerlink" title="绑定信息文档"></a>绑定信息文档</h3><p>设备树是用来描述板子上的设备信息的，不同的设备其信息不同，反映到设备树中就是属性不同。那么我们在设备树中添加一个硬件对应的节点的时候从哪里查阅相关的说明呢？在Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux 源码目录&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，如图 43.8.1 所示：</p><img src="/devicetree/linux%E8%AE%BE%E5%A4%87%E6%A0%91/i.png" class="" title="i"><p>比如我们现在要想在 I.MX6ULL 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-imx.txt，此文档详细的描述了 I.MX 系列的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">* Freescale Inter <span class="hljs-title function_">IC</span> <span class="hljs-params">(I2C)</span> and High Speed Inter <span class="hljs-title function_">IC</span> <span class="hljs-params">(HS-I2C)</span> <span class="hljs-keyword">for</span> i.MX<br>Required properties:<br>- compatible :<br> - &quot;fsl,imx1-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on i.MX1 <br>SoC<br> - &quot;fsl,imx21-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on i.MX21 <br>SoC<br> - &quot;fsl,vf610-i2c&quot; <span class="hljs-keyword">for</span> I2C compatible with the one integrated on Vybrid <br>vf610 SoC<br>- reg : Should contain I2C/HS-I2C registers location and length<br>- interrupts : Should contain I2C/HS-I2C interrupt<br>- clocks : Should contain the I2C/HS-I2C clock specifier<br>    <br>Optional properties:<br>- clock-frequency : Constains desired I2C/HS-I2C bus clock frequency in <br>Hz.<br> The absence of the propoerty indicates the <span class="hljs-keyword">default</span> frequency 100 kHz.<br>- dmas: A <span class="hljs-built_in">list</span> of two dma specifiers, one <span class="hljs-keyword">for</span> each entry in dma-names.<br>- dma-names: should contain &quot;tx&quot; and &quot;rx&quot;.<br>    <br>Examples:<br><br>i2c@83fc4000 &#123; <span class="hljs-comment">/* I2C2 on i.MX51 */</span><br>     compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>     reg = &lt;<span class="hljs-number">0x83fc4000</span> <span class="hljs-number">0x4000</span>&gt;;<br>     interrupts = &lt;<span class="hljs-number">63</span>&gt;;<br>&#125;;<br><br>i2c@<span class="hljs-number">70038000</span> &#123; <span class="hljs-comment">/* HS-I2C on i.MX51 */</span><br>compatible = <span class="hljs-string">&quot;fsl,imx51-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<br>reg = &lt;<span class="hljs-number">0x70038000</span> <span class="hljs-number">0x4000</span>&gt;;<br>interrupts = &lt;<span class="hljs-number">64</span>&gt;;<br>clock-frequency = &lt;<span class="hljs-number">400000</span>&gt;;<br>&#125;;<br><br>i2c0: i2c@<span class="hljs-number">40066000</span> &#123; <span class="hljs-comment">/* i2c0 on vf610 */</span><br>     compatible = <span class="hljs-string">&quot;fsl,vf610-i2c&quot;</span>;<br>     reg = &lt;<span class="hljs-number">0x40066000</span> <span class="hljs-number">0x1000</span>&gt;;<br>     interrupts =&lt;<span class="hljs-number">0</span> <span class="hljs-number">71</span> <span class="hljs-number">0x04</span>&gt;;<br>     dmas = &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">50</span>&gt;,<br>     &lt;&amp;edma0 <span class="hljs-number">0</span> <span class="hljs-number">51</span>&gt;;<br>     dma-names = <span class="hljs-string">&quot;rx&quot;</span>,<span class="hljs-string">&quot;tx&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有时候使用的一些芯片在 Documentation&#x2F;devicetree&#x2F;bindings 目录下找不到对应的文档，这个时候就要咨询芯片的提供商，让他们给你提供参考的设备树文件。</p><h3 id="设备树常用-OF-操作函数"><a href="#设备树常用-OF-操作函数" class="headerlink" title="设备树常用 OF 操作函数"></a>设备树常用 OF 操作函数</h3><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p><h4 id="查找节点的OF函数"><a href="#查找节点的OF函数" class="headerlink" title="查找节点的OF函数"></a>查找节点的OF函数</h4><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.3.9.1 device_node 节点</span><br><span class="hljs-number">49</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> &#123;</span><br><span class="hljs-number">50</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 节点名字 */</span><br><span class="hljs-number">51</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type; <span class="hljs-comment">/* 设备类型 */</span><br><span class="hljs-number">52</span> phandle phandle;<br><span class="hljs-number">53</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *full_name; <span class="hljs-comment">/* 节点全名 */</span><br><span class="hljs-number">54</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span> <span class="hljs-title">fwnode</span>;</span><br><span class="hljs-number">55</span><br><span class="hljs-number">56</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">properties</span>;</span> <span class="hljs-comment">/* 属性 */</span><br><span class="hljs-number">57</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">deadprops</span>;</span> <span class="hljs-comment">/* removed 属性 */</span><br><span class="hljs-number">58</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">/* 父节点 */</span><br><span class="hljs-number">59</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">child</span>;</span> <span class="hljs-comment">/* 子节点 */</span><br><span class="hljs-number">60</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">sibling</span>;</span><br><span class="hljs-number">61</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-number">62</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<br><span class="hljs-number">63</span> <span class="hljs-type">void</span> *data;<br><span class="hljs-number">64</span> <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SPARC)</span><br><span class="hljs-number">65</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path_component_name;<br><span class="hljs-number">66</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<br><span class="hljs-number">67</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_irq_controller</span> *<span class="hljs-title">irq_trans</span>;</span><br><span class="hljs-number">68</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">69</span> &#125;;<br></code></pre></td></tr></table></figure><p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p><h5 id="of-find-node-by-name"><a href="#of-find-node-by-name" class="headerlink" title="of_find_node_by_name"></a>of_find_node_by_name</h5><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>name</strong>：要查找的节点名字。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败。</p><h5 id="of-find-node-by-type"><a href="#of-find-node-by-type" class="headerlink" title="of_find_node_by_type"></a>of_find_node_by_type</h5><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败。</p><h5 id="of-find-compatible-node"><a href="#of-find-compatible-node" class="headerlink" title="of_find_compatible_node"></a>of_find_compatible_node</h5><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_compatible_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compatible)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>type</strong>：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。<br><strong>compatible</strong>：要查找的节点所对应的 compatible 属性列表。<br><strong>返回值</strong>：找到的节点，如果为 NULL 表示查找失败</p><h5 id="of-find-matching-node-and-match"><a href="#of-find-matching-node-and-match" class="headerlink" title="of_find_matching_node_and_match"></a>of_find_matching_node_and_match</h5><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_matching_node_and_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *from,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id *matches,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> of_device_id **match)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>from：</strong>开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br><strong>matches：</strong>of_device_id 匹配表，也就是在此匹配表里面查找节点。<br><strong>match：</strong>找到的匹配的 of_device_id。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败</p><h5 id="of-find-node-by-path-函数"><a href="#of-find-node-by-path-函数" class="headerlink" title="of_find_node_by_path 函数"></a>of_find_node_by_path 函数</h5><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_find_node_by_path</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>path：</strong>带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个节点的全路径。<br><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败</p><h4 id="查找父-子节点的OF函数"><a href="#查找父-子节点的OF函数" class="headerlink" title="查找父&#x2F;子节点的OF函数"></a>查找父&#x2F;子节点的OF函数</h4><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p><h5 id="of-get-parent"><a href="#of-get-parent" class="headerlink" title="of_get_parent"></a>of_get_parent</h5><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_parent</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>node：</strong>要查找的父节点的节点。<br><strong>返回值：</strong>找到的父节点。</p><h5 id="of-get-next-child"><a href="#of-get-next-child" class="headerlink" title="of_get_next_child"></a>of_get_next_child</h5><p>of_get_next_child 函数用迭代的方式查找子节点，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device_node *<span class="hljs-title function_">of_get_next_child</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *node,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> device_node *prev)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>node：</strong>父节点。<br><strong>prev：</strong>前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。<br><strong>返回值：</strong>找到的下一个子节点。</p><h4 id="提取属性值的-OF-函数"><a href="#提取属性值的-OF-函数" class="headerlink" title="提取属性值的 OF 函数"></a>提取属性值的 OF 函数</h4><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件include&#x2F;linux&#x2F;of.h 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.3.1 property 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> &#123;</span><br><span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 属性名字 */</span><br><span class="hljs-type">int</span> length; <span class="hljs-comment">/* 属性长度 */</span><br><span class="hljs-type">void</span> *value; <span class="hljs-comment">/* 属性值 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/* 下一个属性 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> <span class="hljs-title">attr</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下。</p><h5 id="of-find-property"><a href="#of-find-property" class="headerlink" title="of_find_property"></a>of_find_property</h5><p>of_find_property 函数用于查找指定的属性，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">property *<span class="hljs-title function_">of_find_property</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> *lenp)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>name：</strong> 属性名字。<br><strong>lenp：</strong>属性值的字节数<br><strong>返回值：</strong>找到的属性。</p><h5 id="of-property-count-elems-of-size"><a href="#of-property-count-elems-of-size" class="headerlink" title="of_property_count_elems_of_size"></a>of_property_count_elems_of_size</h5><p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_count_elems_of_size</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">int</span> elem_size)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 需要统计元素数量的属性名字。<br><strong>elem_size：</strong>元素长度。<br><strong>返回值：</strong>得到的属性元素数量。</p><h5 id="of-property-read-u32-index"><a href="#of-property-read-u32-index" class="headerlink" title="of_property_read_u32_index"></a>of_property_read_u32_index</h5><p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值(无符号 32位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_index</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u32 index,  u32 *out_value)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>index：</strong>要读取的值标号。<br><strong>out_value：</strong>读取到的值<br><strong>返回值：</strong>0 读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><h5 id="of-property-read-u8-array-of-property-read-u16-array-of-property-read-u32-array-of-property-read-u64-array"><a href="#of-property-read-u8-array-of-property-read-u16-array-of-property-read-u32-array-of-property-read-u64-array" class="headerlink" title="of_property_read_u8_array  of_property_read_u16_array of_property_read_u32_array of_property_read_u64_array"></a>of_property_read_u8_array  of_property_read_u16_array of_property_read_u32_array of_property_read_u64_array</h5><p>这 4 个函数分别是读取属性中 u8、u16、u32 和 u64 类型的数组数据，比如大多数的 reg 属性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据。这四个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u8 *out_values, <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u16 *out_values,  <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u32 *out_values, <span class="hljs-type">size_t</span> sz)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname,  u64 *out_values, <span class="hljs-type">size_t</span> sz)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_value：</strong>读取到的数组值，分别为 u8、u16、u32 和 u64。<br><strong>sz：</strong>要读取的数组元素数量。<br><strong>返回值：</strong>0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><h5 id="of-property-read-u8-of-property-read-u16-of-property-read-u32-of-property-read-u64"><a href="#of-property-read-u8-of-property-read-u16-of-property-read-u32-of-property-read-u64" class="headerlink" title="of_property_read_u8 of_property_read_u16 of_property_read_u32 of_property_read_u64"></a>of_property_read_u8 of_property_read_u16 of_property_read_u32 of_property_read_u64</h5><p>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，分别用于读取 u8、u16、u32 和 u64 类型属性值，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u8</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u8 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u16</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u16 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u32 *out_value)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_u64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, u64 *out_value)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_value：</strong>读取到的数组值。<br><strong>返回值：</strong>0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。</p><h5 id="of-property-read-string"><a href="#of-property-read-string" class="headerlink" title="of_property_read_string"></a>of_property_read_string</h5><p>of_property_read_string 函数用于读取属性中字符串值，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_property_read_string</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **out_string)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>proname：</strong> 要读取的属性名字。<br><strong>out_string：</strong>读取到的字符串值。<br><strong>返回值：</strong>0，读取成功，负值，读取失败。</p><h5 id="of-n-addr-cells"><a href="#of-n-addr-cells" class="headerlink" title="of_n_addr_cells"></a>of_n_addr_cells</h5><p>of_n_addr_cells 函数用于获取#address-cells 属性值，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_addr_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>返回值：</strong>获取到的#address-cells 属性值。</p><h5 id="of-n-size-cells"><a href="#of-n-size-cells" class="headerlink" title="of_n_size_cells"></a>of_n_size_cells</h5><p>of_size_cells 函数用于获取#size-cells 属性值，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_n_size_cells</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>返回值：</strong>获取到的#size-cells 属性值。</p><h4 id="其他常用的OF函数"><a href="#其他常用的OF函数" class="headerlink" title="其他常用的OF函数"></a>其他常用的OF函数</h4><h5 id="of-device-is-compatible"><a href="#of-device-is-compatible" class="headerlink" title="of_device_is_compatible"></a>of_device_is_compatible</h5><p>of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_device_is_compatible</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device_node *device, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *compat)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>device：</strong>设备节点。<br><strong>compat：</strong>要查看的字符串。<br><strong>返回值：</strong>0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，节点的 compatible属性中包含 compat 指定的字符串。</p><h5 id="of-get-address"><a href="#of-get-address" class="headerlink" title="of_get_address"></a>of_get_address</h5><p>of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性值，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> __be32 *<span class="hljs-title function_">of_get_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">int</span> index, u64 *size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>index：</strong>要读取的地址标号。<br><strong>size：</strong>地址长度。<br><strong>flags：</strong>参数，比如 IORESOURCE_IO、IORESOURCE_MEM 等<br><strong>返回值：</strong>读取到的地址数据首地址，为 NULL 的话表示读取失败。</p><h5 id="of-translate-address"><a href="#of-translate-address" class="headerlink" title="of_translate_address"></a>of_translate_address</h5><p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u64 <span class="hljs-title function_">of_translate_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">const</span> __be32 *in_addr)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>in_addr：</strong>要转换的地址。<br><strong>返回值：</strong>得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</p><h5 id="of-address-to-resource"><a href="#of-address-to-resource" class="headerlink" title="of_address_to_resource"></a>of_address_to_resource</h5><p>IIC、SPI、GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间，Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息，resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.4.1 resource 结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><br>    <span class="hljs-type">resource_size_t</span> start;<br>    <span class="hljs-type">resource_size_t</span> end;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于 32 位的 SOC 来说，resource_size_t 是 u32 类型的。其中 start 表示开始地址，end 表示结束地址，name 是这个资源的名字，flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例代码 43.9.4.2 资源标志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PREFETCH 0x00002000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_READONLY 0x00004000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_STARTALIGN 0x00080000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM_64 0x00100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_WINDOW 0x00200000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MUXED 0x00400000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DISABLED 0x10000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_UNSET 0x20000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_AUTO 0x40000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUSY 0x80000000</span><br></code></pre></td></tr></table></figure><p>大 家 一 般 最 常 见 的 资 源 标 志 就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ 等。接下来我们回到 of_address_to_resource 函数，此函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">of_address_to_resource</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *dev,  <span class="hljs-type">int</span> index, <span class="hljs-keyword">struct</span> resource *r)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>dev：</strong>设备节点。<br><strong>index：</strong>地址资源标号。<br><strong>r：</strong>得到的 resource 类型的资源值。<br><strong>返回值：</strong>0，成功；负值，失败。</p><h5 id="of-iomap"><a href="#of-iomap" class="headerlink" title="of_iomap"></a>of_iomap</h5><p>of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。当然了，你也可以使用 ioremap 函数来完成物理地址到虚拟地址的内存映射，只是在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段，of_iomap 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __iomem *<span class="hljs-title function_">of_iomap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">int</span> index)</span><br></code></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br><strong>np：</strong>设备节点。<br><strong>index：</strong>reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。<br><strong>返回值：</strong>经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</p><p>关于设备树常用的 OF 函数就先讲解到这里，Linux 内核中关于设备树的 OF 函数不仅仅只有前面讲的这几个，还有很多 OF 函数我们并没有讲解，这些没有讲解的 OF 函数要结合具体的驱动，比如获取中断号的 OF 函数、获取 GPIO 的 OF 函数等等。</p><p>关于设备树就讲解到这里，关于设备树我们重点要了解一下几点内容：</p><ul><li>DTS、DTB 和 DTC 之间的区别，如何将.dts 文件编译为.dtb 文件。</li><li>设备树语法，这个是重点，因为在实际工作中我们是需要修改设备树的。</li><li>设备树的几个特殊子节点。</li><li>关于设备树的 OF 操作函数，也是重点，因为设备树最终是被驱动文件所使用的，而驱动文件必须要读取设备树中的属性信息，比如内存信息、GPIO 信息、中断信息等等。要想在驱动中读取设备树的属性值，那么就必须使用 Linux 内核提供的众多的 OF 函数。</li></ul><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>device tree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>device tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>platform框架</title>
    <link href="/platform/platform%E6%A1%86%E6%9E%B6/"/>
    <url>/platform/platform%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="platform平台设备驱动框架"><a href="#platform平台设备驱动框架" class="headerlink" title="platform平台设备驱动框架"></a>platform平台设备驱动框架</h2><h3 id="linux驱动分层与分离"><a href="#linux驱动分层与分离" class="headerlink" title="linux驱动分层与分离"></a>linux驱动分层与分离</h3><h4 id="驱动的分层与分离"><a href="#驱动的分层与分离" class="headerlink" title="驱动的分层与分离"></a>驱动的分层与分离</h4><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。</p><p>假如现在有三个平台 A、B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个 I2C接口的六轴传感器，按照我们写裸机 I2C 驱动的时候的思路，每个平台都有一个 MPU6050的驱动，因此编写出来的最简单的驱动框架如图所示：</p><img src="/platform/platform%E6%A1%86%E6%9E%B6/a.png" class="" title="a"><p>可以看出，每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序即可。如果再来几个 I2C 设备，比如 AT24C02、FT5206(电容触摸屏)等，如果按照图中的写法，那么设备端的驱动将会重复的编写好几次。显然在 Linux 驱动程序中这种写法是不推荐的，最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的 I2C接口驱动来访问，这样就可以大大简化驱动文件，比如 54.1.1 中三种平台下的 MPU6050 驱动框架就可以简化为下图所示：</p><img src="/platform/platform%E6%A1%86%E6%9E%B6/b.png" class="" title="b"><p>实际的 I2C 驱动设备肯定有很多种，不止 MPU6050 这一个，那么实际的驱动架构如下图所示：</p><img src="/platform/platform%E6%A1%86%E6%9E%B6/c.png" class="" title="c"><p>这个就是驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥，如图所示：</p><img src="/platform/platform%E6%A1%86%E6%9E%B6/d.png" class="" title="d"><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，而platform 驱动就是这一思想下的产物。</p><h3 id="platform平台驱动模型简介"><a href="#platform平台驱动模型简介" class="headerlink" title="platform平台驱动模型简介"></a>platform平台驱动模型简介</h3><p>设备驱动的分离，分出了总线(bus)、驱动(driver)和设备(device)模型。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p><h4 id="platform总线"><a href="#platform总线" class="headerlink" title="platform总线"></a>platform总线</h4><p>Linux系统内核使用bus_type 结构体表示总线，此结构体定义在文件 include&#x2F;linux&#x2F;device.h，bus_type 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">/* 总线名字 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev_root</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_attribute</span> *<span class="hljs-title">dev_attrs</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">bus_groups</span>;</span> <span class="hljs-comment">/* 总线属性 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span> <span class="hljs-comment">/* 设备属性 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">drv_groups</span>;</span> <span class="hljs-comment">/* 驱动属性 */</span><br><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv);<br>    <span class="hljs-type">int</span> (*uevent)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> kobj_uevent_env *env);<br>    <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> device *dev);<br><br>    <span class="hljs-type">int</span> (*online)(<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">int</span> (*offline)(<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);<br>    <span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_ops</span> *<span class="hljs-title">iommu_ops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> <span class="hljs-title">lock_key</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>第 10 行，match 函数，此函数很重要，match 的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。<strong>match 函数有两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。</strong></p><p>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers&#x2F;base&#x2F;platform.c，platform 总线定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;platform&quot;</span>,<br>    .dev_groups = platform_dev_groups,<br>    .match = platform_match,<br>    .uevent = platform_uevent,<br>    .pm = &amp;platform_dev_pm_ops,<br>&#125;;<br></code></pre></td></tr></table></figure><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。我们来看一下驱动和设备是如何匹配的，platform_match 函数定义在文件 drivers&#x2F;base&#x2F;platform.c 中，函数内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);<br><br>    <span class="hljs-comment">/*When driver_override is set,only bind to the matching driver*/</span><br>    <span class="hljs-keyword">if</span> (pdev-&gt;driver_override)<br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);<br><br>    <span class="hljs-comment">/* Attempt an OF style match first */</span><br>    <span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Then try ACPI style match */</span><br>    <span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Then try to match against the id table */</span><br>    <span class="hljs-keyword">if</span> (pdrv-&gt;id_table)<br>    <span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* fall-back to driver name match */</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>驱动和设备的匹配有四种方法，我们依次来看一下：<br>第 11-12 行，第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include&#x2F;linux&#x2F;of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后 probe 函数就会执行。<br>第 15-16 行，第二种匹配方式，ACPI 匹配方式。<br>第 19-20 行，第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。<br>第 23 行，第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。<br>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。</p><h4 id="platform驱动"><a href="#platform驱动" class="headerlink" title="platform驱动"></a>platform驱动</h4><p>platform_driver 结构体表示 platform 驱动，此结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> &#123;</span><br>    <span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> platform_device *);<br>    <span class="hljs-type">int</span> (*remove)(<span class="hljs-keyword">struct</span> platform_device *);<br>    <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> platform_device *);<br>    <span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> platform_device *, <span class="hljs-type">pm_message_t</span> state);<br>    <span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> platform_device *);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_table</span>;</span><br>    <span class="hljs-type">bool</span> prevent_deferred_probe;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第 2 行，<strong>probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行</strong>，非常重要的函数！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。<br>第 7 行，driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。<br>第 8 行，id_table 表，也就是我们上一小节讲解 platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表( 也就是数组) ，每个元素的类型为 platform_device_id，platform_device_id 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> &#123;</span><br>    <span class="hljs-type">char</span> name[PLATFORM_NAME_SIZE];<br>    <span class="hljs-type">kernel_ulong_t</span> driver_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>device_driver 结构体定义在 include&#x2F;linux&#x2F;device.h，device_driver 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> *<span class="hljs-title">bus</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name; <span class="hljs-comment">/* used for built-in modules */</span><br><br>    <span class="hljs-type">bool</span> suppress_bind_attrs; <span class="hljs-comment">/* disables bind/unbind via sysfs */</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">of_match_table</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_device_id</span> *<span class="hljs-title">acpi_match_table</span>;</span><br><br>    <span class="hljs-type">int</span> (*probe) (<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">int</span> (*remove) (<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">void</span> (*shutdown) (<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">int</span> (*suspend) (<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">pm_message_t</span> state);<br>    <span class="hljs-type">int</span> (*resume) (<span class="hljs-keyword">struct</span> device *dev);<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">driver_private</span> *<span class="hljs-title">p</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>第 10 行，of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include&#x2F;linux&#x2F;mod_devicetable.h 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">char</span> type[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">char</span> compatible[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第 4 行的 compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。<br>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。</p><p>当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，platform_driver_register 函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_driver_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *driver)</span><br></code></pre></td></tr></table></figure><p>​函数参数和返回值含义如下：<br>​<strong>driver：</strong>要注册的 platform 驱动。<br>​<strong>返回值：</strong>负数，失败；0，成功。</p><p>还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动，platform_driver_unregister 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_driver_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *drv)</span><br></code></pre></td></tr></table></figure><p>​函数参数和返回值含义如下：<br>​<strong>drv：</strong>要卸载的 platform 驱动。<br>​<strong>返回值：</strong>无。</p><p>platform 驱动框架如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span>&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span><br>  <span class="hljs-comment">/* 设备结构体其他具体内容 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> <span class="hljs-title">xxxdev</span>;</span> <span class="hljs-comment">/* 定义个设备结构体变量 */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123; <br>    <span class="hljs-comment">/* 函数具体内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">xxx_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>    <span class="hljs-comment">/* 函数具体内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 字符设备驱动操作集</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_fops</span> =</span> &#123;<br>    .owner = THIS_MODULE,<br>    .open = xxx_open,<br>    .write = xxx_write,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* platform 驱动的 probe 函数</span><br><span class="hljs-comment">* 驱动与设备匹配成功以后此函数就会执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123; <br>    ......<br>    cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); <span class="hljs-comment">/* 注册字符设备驱动 */</span><br>    <span class="hljs-comment">/* 函数具体内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;<br>    ......<br>    cdev_del(&amp;xxxdev.cdev);<span class="hljs-comment">/* 删除 cdev */</span><br>    <span class="hljs-comment">/* 函数具体内容 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 匹配列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">xxx_of_match</span>[] =</span> &#123;<br>    &#123; .compatible = <span class="hljs-string">&quot;xxx-gpio&quot;</span> &#125;,<br>    &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">* platform 平台驱动结构体</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">xxx_driver</span> =</span> &#123;<br>    .driver = &#123;<br>        .name = <span class="hljs-string">&quot;xxx&quot;</span>,<br>        .of_match_table = xxx_of_match,<br>    &#125;,<br>    .probe = xxx_probe,<br>    .remove = xxx_remove,<br>&#125;;<br> <br><span class="hljs-comment">/* 驱动模块加载 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> platform_driver_register(&amp;xxx_driver);<br>&#125;<br><br><span class="hljs-comment">/* 驱动模块卸载 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxxdriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    platform_driver_unregister(&amp;xxx_driver);<br>&#125;<br><br>module_init(xxxdriver_init);<br>module_exit(xxxdriver_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;TomWithKernel&quot;</span>);<br></code></pre></td></tr></table></figure><p>第 1-27 行，传统的字符设备驱动，所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动。platform 只是为了驱动的分离与分层而提出来的一种框架，其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动。<br>第 33-39 行，xxx_probe 函数，当驱动和设备匹配成功以后此函数就会执行，以前在驱动入口 init 函数里面编写的字符设备驱动程序就全部放到此 probe 函数里面。比如注册字符设备驱动、添加 cdev、创建类等等。<br>第 41-47 行，xxx_remove 函数，platform_driver 结构体中的 remove 成员变量，当关闭 platform设备驱动的时候此函数就会执行，以前在驱动卸载 exit 函数里面要做的事情就放到此函数中来。比如，使用 iounmap 释放内存、删除 cdev，注销设备号等等。<br>第 50-53 行，xxx_of_match 匹配表，如果使用设备树的话将通过此匹配表进行驱动和设备的匹配。第 51 行设置了一个匹配项，此匹配项的 compatible 值为“xxx-gpio”，因此当设备树中设备节点的 compatible 属性值为“xxx-gpio”的时候此设备就会与此驱动匹配。第 52 行是一个标记，of_device_id 表最后一个匹配项必须是空的。<br>第 58-65 行，定义一个 platform_driver 结构体变量 xxx_driver，表示 platform 驱动，第 59-62行设置 paltform_driver 中的 device_driver 成员变量的 name 和 of_match_table 这两个属性。其中name 属性用于传统的驱动与设备匹配，也就是检查驱动和设备的 name 字段是不是相同。of_match_table 属性就是用于设备树下的驱动与设备检查。对于一个完整的驱动程序，必须提供有设备树和无设备树两种匹配方法。最后 63 和 64 这两行设置 probe 和 remove 这两成员变量。<br>第68-71行，驱动入口函数，调用platform_driver_register函数向Linux内核注册一个platform驱动，也就是上面定义的 xxx_driver 结构体变量。<br>第 74-77 行，驱动出口函数，调用 platform_driver_unregister 函数卸载前面注册的 platform驱动。<br>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。</p><h4 id="platform设备"><a href="#platform设备" class="headerlink" title="platform设备"></a>platform设备</h4><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，这里我们要注意，<strong>如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了</strong>。当然了，你如果一定要用 platform_device 来描述设备信息的话也是可以的。platform_device 结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <br>    <span class="hljs-type">int</span> id; <br>    <span class="hljs-type">bool</span> id_auto;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><br>    u32 num_resources; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">resource</span>;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_entry</span>;</span><br>    <span class="hljs-type">char</span> *driver_override; <span class="hljs-comment">/* Driver name to force a match */</span><br><br>    <span class="hljs-comment">/* MFD cell pointer */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mfd_cell</span> *<span class="hljs-title">mfd_cell</span>;</span><br><br>    <span class="hljs-comment">/* arch specific additions */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pdev_archdata</span> <span class="hljs-title">archdata</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>第 2 行，name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话设备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。<br>第 6 行，num_resources 表示资源数量，一般为第 7 行 resource 资源的大小。<br>第 7 行，resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源，resource 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><br>    <span class="hljs-type">resource_size_t</span> start;<br>    <span class="hljs-type">resource_size_t</span> end;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include&#x2F;linux&#x2F;ioport.h 里面，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BITS 0x000000ff<span class="hljs-comment">/* Bus-specific bits */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00<span class="hljs-comment">/* Resource type */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IO 0x00000100<span class="hljs-comment">/* PCI/ISA I/O ports */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_MEM 0x00000200</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_REG 0x00000300<span class="hljs-comment">/* Register offsets */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_IRQ 0x00000400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_DMA 0x00000800</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_BUS 0x00001000</span><br>......<br><span class="hljs-comment">/* PCI control bits. Shares IORESOURCE_BITS with above PCI ROM. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IORESOURCE_PCI_FIXED (1&lt;&lt;4)<span class="hljs-comment">/* Do not move resource */</span></span><br></code></pre></td></tr></table></figure><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，此函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br></code></pre></td></tr></table></figure><p>​函数参数和返回值含义如下：<br>​<strong>pdev</strong>：要注册的 platform 设备。<br>​<strong>返回值：</strong>负数，失败；0，成功。</p><p>如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform设备，platform_device_unregister 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br></code></pre></td></tr></table></figure><p>​函数参数和返回值含义如下：<br>​<strong>pdev</strong>：要注销的 platform 设备。<br>​<strong>返回值：</strong>无。</p><p>platform 设备信息框架如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 寄存器地址定义*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH1_REGISTER_BASE (0X20000000) <span class="hljs-comment">/* 外设 1 寄存器首地址 */</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH2_REGISTER_BASE (0X020E0068) <span class="hljs-comment">/* 外设 2 寄存器首地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH 4</span><br><br><span class="hljs-comment">/* 资源 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">xxx_resources</span>[] =</span> &#123;<br>    [<span class="hljs-number">0</span>] = &#123;<br>        .start = PERIPH1_REGISTER_BASE,<br>        .end = (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>        .flags = IORESOURCE_MEM,<br>    &#125;, <br>    [<span class="hljs-number">1</span>] = &#123;<br>        .start = PERIPH2_REGISTER_BASE,<br>        .end = (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>        .flags = IORESOURCE_MEM,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* platform 设备结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">xxxdevice</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;xxx-gpio&quot;</span>,<br>    .id = <span class="hljs-number">-1</span>,<br>    .num_resources = ARRAY_SIZE(xxx_resources),<br>    .resource = xxx_resources,<br>&#125;;<br><br><span class="hljs-comment">/* 设备模块加载 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxdevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> platform_device_register(&amp;xxxdevice);<br>&#125;<br><br><span class="hljs-comment">/* 设备模块注销 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_resourcesdevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    platform_device_unregister(&amp;xxxdevice);<br>&#125;<br><br>module_init(xxxdevice_init);<br>module_exit(xxxdevice_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;TomWithKernel&quot;</span>);<br></code></pre></td></tr></table></figure><p>第 7-18 行，数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。<br>第 21-26 行，platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。<br>第 29-32 行，设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注册 platform 设备。<br>第 35-38 行，设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。<br>此代码主要是在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了，感兴趣的可以去看一下，网上也有很多博客详细的讲解了整个过程。</p>]]></content>
    
    
    <categories>
      
      <category>platform</category>
      
    </categories>
    
    
    <tags>
      
      <tag>platform</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>udev</title>
    <link href="/usb/udev/"/>
    <url>/usb/udev/</url>
    
    <content type="html"><![CDATA[<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>udev 是一个用户空间系统，它使操作系统管理员能够为事件注册用户空间处理程序。udev 守护程序接收的事件主要由 （Linux） 内核生成，以响应与外围设备相关的物理事件。因此，udev的主要目的是对外设检测和热插拔采取行动，包括将控制权返回给内核的操作，udev 可提供所需的基础结构来动态维护 &#x2F;dev 目录中的设备节点文件和符号链接。udev 规则提供了将外部工具插入内核设备事件处理的方式。</p><h3 id="udevadm-命令介绍"><a href="#udevadm-命令介绍" class="headerlink" title="udevadm 命令介绍"></a>udevadm 命令介绍</h3><h4 id="主命令"><a href="#主命令" class="headerlink" title="主命令"></a>主命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">info#查询sysfs或者udev的数据库<br>trigger#从内核请求events<br>settle#查看udev事件队列，如果所有的events已处理则退出<br>control#修改udev后台的内部状态信息<br>monitor#监控内核的uevents<br>hwdb#处理硬件数据库索引<br>test#调试<br></code></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="查看设备信息："><a href="#查看设备信息：" class="headerlink" title="查看设备信息："></a>查看设备信息：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm info --query=all --name=sda #查询sda的所有信息<br>udevadm info --query=path --name=sda #查看sda的path<br>udevadm info --attribute-walk --name=/dev/nvme0n1  #查看nvme0n1的所有父设备一直到sysfs的根节点<br>--query=type#从数据库中查询指定类型的设备。需要--path和--name来指定设备。合法的查询文件是：设备名，链接，路径，属性<br>--path=devpath#设备的路径<br>--name=file#设备节点或者链接<br>--attribute-walk#打印指定设备的所有sysfs记录的属性，以用来udev规则匹配特殊的设备。该选项打印链上的所有设备信息，最大可能到sys目录。<br>--device-id-of-file=file#打印主/从设备号<br>--export-db#输出udev数据库中的内容<br></code></pre></td></tr></table></figure><h5 id="监控设备事件："><a href="#监控设备事件：" class="headerlink" title="监控设备事件："></a>监控设备事件：</h5><p>udevadm monitor [options] 监听内核事件和udev发送的events事件。打印事件发出的设备。可以通过比较内核或者udev事件的时间戳来分析事件时序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm monitor --property#输出事件的属性<br>udevadm monitor --kernel --property --subsystem-match=usb    #过滤监听符合条件的时间<br>--kernel#输出内核事件<br>--udev#输出udev规则执行时的udev事件<br>--property#输出事件的属性<br>--subsystem-match=string#通过子系统或者设备类型过滤事件。只有匹配了子系统值的udev设备事件通过。<br>--tag-match=string#通过属性过滤事件，只有匹配了标签的udev事件通过。<br></code></pre></td></tr></table></figure><h5 id="模拟一个udev事件"><a href="#模拟一个udev事件" class="headerlink" title="模拟一个udev事件"></a>模拟一个udev事件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm test [options] devpath#模拟一个udev事件，打印出debug信息<br></code></pre></td></tr></table></figure><h5 id="接收内核发送来的设备事件"><a href="#接收内核发送来的设备事件" class="headerlink" title="接收内核发送来的设备事件"></a>接收内核发送来的设备事件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm trigger [options]#接收内核发送来的设备事件。主要用于重放coldplug事件信息<br><span class="hljs-meta prompt_">#</span><span class="language-bash">（内核在启动时已经检测到了系统的硬件设备，并把硬件设备信息通过sysfs内核虚拟文件系统导出。udev扫描sysfs文件系统，根据硬件设备信息生成热插拔（hotplug）事件，udev再读取这些事件，生成对应的硬件设备文件。由于没有实际的硬件插拔动作，所以这一过程被称为coldplug。）</span><br>--verbose#输出将要被触发的设备列表。<br>--dry-run#不真的触发事件<br>--type=type#触发一个特殊的设备。合法的类型：devices,subsystem,failed.默认是devices<br>--action=action#被触发的事件，默认是change<br>--subsystem-match=subsystem#触发匹配子系统的设备事件。这个选项可以被多次指定，并且支持shell模式匹配。<br>--attr-match=attribute=value#触发匹配sysfs属性的设备事件。如果属性值和属性一起指定，属性的值可以使用shell模式匹配。如果没有指定值，会重新确认现有属性。这个选项可以被多次指定。<br>--attr-nomatch=attribute=value#不要触发匹配属性的设备事件。如果可以使用模式匹配。也可以多次指定<br>--property-match=property=value#匹配属性吻合的设备。可以多次指定支持模式匹配<br>--tag-match=property#匹配标签吻合的设备。可以多次指定。<br>--sysname-match=name#匹配sys设备名相同的设备。可以多次指定支持模式匹配。<br><br></code></pre></td></tr></table></figure><h5 id="查看udev事件队列"><a href="#查看udev事件队列" class="headerlink" title="查看udev事件队列"></a>查看udev事件队列</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm settle [options]#查看udev事件队列，如果所有事件全部处理完就退出。<br>--timeout=seconds#等待事件队列空的最大时间。默认是180秒。如果是0则立即退出。<br>--seq-start=seqnum#只等待到给定的顺序号。<br>--seq-end=seqnum#只等待到给定顺序号之前。<br>--exit-if-exists=file#如果文件存在就退出<br>--quiet#不输出任何信息<br></code></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">udev 规则支持使用占位符和替换项。请按照在其他任何脚本中的相同方式使用。在 udev 规则中可使用以下替换项：</span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">r、<span class="hljs-variable">$root</span><span class="hljs-comment">#设备目录 /dev（默认）</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">p、<span class="hljs-variable">$devpath</span><span class="hljs-comment">#DEVPATH 的值</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">k、<span class="hljs-variable">$kernel</span><span class="hljs-comment">#KERNEL 的值或内部设备名称</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">n、<span class="hljs-variable">$number</span><span class="hljs-comment">#设备号</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">N、<span class="hljs-variable">$tempnode</span><span class="hljs-comment">#设备文件的临时名称</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">M、<span class="hljs-variable">$major</span><span class="hljs-comment">#设备的主编号</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">m、<span class="hljs-variable">$minor</span><span class="hljs-comment">#设备的次编号</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">s&#123;ATTRIBUTE&#125;, <span class="hljs-variable">$attr</span>&#123;ATTRIBUTE&#125;<span class="hljs-comment">#sysfs 属性的值（通过 ATTRIBUTE 指定）</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">E&#123;VARIABLE&#125;, <span class="hljs-variable">$env</span>&#123;VARIABLE&#125;<span class="hljs-comment">#环境变量的值（通过 VARIABLE 指定）</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">c、<span class="hljs-variable">$result</span><span class="hljs-comment">#PROGRAM 的输出</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">%<span class="hljs-comment">#% 字符</span></span><br><br></code></pre></td></tr></table></figure><p>规则文件中的每个非注释行都由一个或多个键值对的列表组成，这些键值对由逗号分隔。有两种类型的键：</p><ul><li><p>匹配键：</p><ul><li>ACTION：匹配事件操作的名称.如 add 或 remove（添加或删除设备时。<br>DEVPATH：匹配事件设备的开发路径.如 DEVPATH&#x3D;&#x2F;bus&#x2F;pci&#x2F;drivers&#x2F;ipw3945，用于搜索与 ipw3945 驱动程序有关的所有事件。<br>KERNEL：匹配事件设备的名称。<br>KERNELS：让 udev 向上搜索设备路径，以查找匹配的设备名称。<br>SUBSYSTEM：匹配事件设备的子系统.如 SUBSYSTEM&#x3D;usb（用于与 USB 设备有关的所有事件）。<br>SUBSYSTEMS：让 udev 向上搜索设备路径，以查找匹配的设备子系统名称。<br>ENV{KEY}：环境变量的值，如 ENV{ID_BUS}&#x3D;”ieee1394，用于搜索与该 FireWire 总线 ID 有关的所有事件。<br>ATTR{FILENAME}：事件设备的 sysfs 属性。例如，要匹配 vendor 属性文件名中包含的字符串，可以使用 ATTR{vendor}&#x3D;&#x3D;“On[sS]tream”。<br>ATTRS{FILENAME}：让 udev 向上搜索设备路径，以查找与 sysfs 属性值匹配的设备。<br>TEST{octal mode mask}：测试文件是否存在。您可以指定八进制模式掩码。</li></ul></li><li><p>分配键：</p><ul><li>NAME：用于网络接口的名称。Udev 无法更改设备节点的名称，只能创建其他符号链接.<br>SYMLINK：面向节点的符号链接的名称<br>OWNER, GROUP, MODE：设备节点的权限<br>ATTR{KEY}：指定要写入事件设备的 sysfs 属性的值。如果使用 &#x3D;&#x3D; 运算符，也将使用该键匹配 sysfs 属性的值。<br>ENV{KEY}：告知 udev 将变量导出到环境。如果使用 &#x3D;&#x3D; 运算符，也将使用该键匹配环境变量。<br>RUN：告知 udev 向程序列表添加要为该设备执行的程序。请记住，将此程序限制于很短的任务，以免妨碍此设备的后续事件。<br>OPTIONS：规则和设备选项。</li></ul></li></ul><p>如果所有匹配键都匹配其各自的值，则应用规则并为分配键分配指定的值。每个键都有不同的操作，具体取决于运算符。有效运算符包括：</p><table><thead><tr><th>&#x3D;&#x3D;</th><th>比较相等</th></tr></thead><tbody><tr><td>!&#x3D;</td><td>比较不等式</td></tr><tr><td>&#x3D;</td><td>为键赋值</td></tr><tr><td>+&#x3D;</td><td>将值添加到键的当前值中</td></tr><tr><td>:&#x3D;</td><td>将最终值分配给键。禁止任何后续规则进行任何后续更改。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>修改网卡名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">KERNEL==&quot;eth0&quot;, SUBSYSTEM==&quot;net&quot;, SUBSYSTEMS==&quot;platform&quot;, DRIVERS==&quot;fec&quot;, NAME+=&quot;eth10&quot;<br></code></pre></td></tr></table></figure><p>创建符号链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SUBSYSTEM==&quot;tty&quot;, ATTRS&#123;idVendor&#125;==&quot;XXXX&quot;, ATTRS&#123;idProduct&#125;==&quot;XXXX&quot;, SYMLINK+=&quot;myUSB&quot;<br></code></pre></td></tr></table></figure><p>禁用usb设备唤醒功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACTION==&quot;add&quot;, SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;XXXX&quot;, ATTR&#123;idProduct&#125;==&quot;XXXX&quot;, ATTR&#123;power/wakeup&#125;=&quot;disabled&quot;<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/weixin_42330983/article/details/126767290">https://blog.csdn.net/weixin_42330983/article/details/126767290</a></li><li><a href="https://blog.csdn.net/li_wen01/article/details/89435306">https://blog.csdn.net/li_wen01/article/details/89435306</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>usb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usb</tag>
      
      <tag>udev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>usb-wakeup</title>
    <link href="/usb/wakeup/"/>
    <url>/usb/wakeup/</url>
    
    <content type="html"><![CDATA[<h3 id="usb设备唤醒功能"><a href="#usb设备唤醒功能" class="headerlink" title="usb设备唤醒功能"></a>usb设备唤醒功能</h3><p>drivers&#x2F;hid&#x2F;usbhid&#x2F;hid-core.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usbhid_start</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hid_device *hid)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface</span> *<span class="hljs-title">intf</span> =</span> to_usb_interface(hid-&gt;dev.parent);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">interface</span> =</span> intf-&gt;cur_altsetting;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">dev</span> =</span> interface_to_usbdev(intf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usbhid_device</span> *<span class="hljs-title">usbhid</span> =</span> hid-&gt;driver_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n, insize = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret;<br><br>mutex_lock(&amp;usbhid-&gt;mutex);<br><br>clear_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl);<br><br>usbhid-&gt;bufsize = HID_MIN_BUFFER_SIZE;<br>hid_find_max_report(hid, HID_INPUT_REPORT, &amp;usbhid-&gt;bufsize);<br>hid_find_max_report(hid, HID_OUTPUT_REPORT, &amp;usbhid-&gt;bufsize);<br>hid_find_max_report(hid, HID_FEATURE_REPORT, &amp;usbhid-&gt;bufsize);<br><br><span class="hljs-keyword">if</span> (usbhid-&gt;bufsize &gt; HID_MAX_BUFFER_SIZE)<br>usbhid-&gt;bufsize = HID_MAX_BUFFER_SIZE;<br><br>hid_find_max_report(hid, HID_INPUT_REPORT, &amp;insize);<br><br><span class="hljs-keyword">if</span> (insize &gt; HID_MAX_BUFFER_SIZE)<br>insize = HID_MAX_BUFFER_SIZE;<br><br><span class="hljs-keyword">if</span> (hid_alloc_buffers(dev, hid)) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br><span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; interface-&gt;desc.bNumEndpoints; n++) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> *<span class="hljs-title">endpoint</span>;</span><br><span class="hljs-type">int</span> pipe;<br><span class="hljs-type">int</span> interval;<br><br>endpoint = &amp;interface-&gt;endpoint[n].desc;<br><span class="hljs-keyword">if</span> (!usb_endpoint_xfer_int(endpoint))<br><span class="hljs-keyword">continue</span>;<br><br>interval = endpoint-&gt;bInterval;<br><br><span class="hljs-comment">/* Some vendors give fullspeed interval on highspeed devides */</span><br><span class="hljs-keyword">if</span> (hid-&gt;quirks &amp; HID_QUIRK_FULLSPEED_INTERVAL &amp;&amp;<br>    dev-&gt;speed == USB_SPEED_HIGH) &#123;<br>interval = fls(endpoint-&gt;bInterval*<span class="hljs-number">8</span>);<br>pr_info(<span class="hljs-string">&quot;%s: Fixing fullspeed to highspeed interval: %d -&gt; %d\n&quot;</span>,<br>hid-&gt;name, endpoint-&gt;bInterval, interval);<br>&#125;<br><br><span class="hljs-comment">/* Change the polling interval of mice, joysticks</span><br><span class="hljs-comment"> * and keyboards.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (hid-&gt;collection-&gt;usage) &#123;<br><span class="hljs-keyword">case</span> HID_GD_MOUSE:<br><span class="hljs-keyword">if</span> (hid_mousepoll_interval &gt; <span class="hljs-number">0</span>)<br>interval = hid_mousepoll_interval;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> HID_GD_JOYSTICK:<br><span class="hljs-keyword">if</span> (hid_jspoll_interval &gt; <span class="hljs-number">0</span>)<br>interval = hid_jspoll_interval;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> HID_GD_KEYBOARD:<br><span class="hljs-keyword">if</span> (hid_kbpoll_interval &gt; <span class="hljs-number">0</span>)<br>interval = hid_kbpoll_interval;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = -ENOMEM;<br><span class="hljs-keyword">if</span> (usb_endpoint_dir_in(endpoint)) &#123;<br><span class="hljs-keyword">if</span> (usbhid-&gt;urbin)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!(usbhid-&gt;urbin = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL)))<br><span class="hljs-keyword">goto</span> fail;<br>pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);<br>usb_fill_int_urb(usbhid-&gt;urbin, dev, pipe, usbhid-&gt;inbuf, insize,<br> hid_irq_in, hid, interval);<br>usbhid-&gt;urbin-&gt;transfer_dma = usbhid-&gt;inbuf_dma;<br>usbhid-&gt;urbin-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (usbhid-&gt;urbout)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!(usbhid-&gt;urbout = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL)))<br><span class="hljs-keyword">goto</span> fail;<br>pipe = usb_sndintpipe(dev, endpoint-&gt;bEndpointAddress);<br>usb_fill_int_urb(usbhid-&gt;urbout, dev, pipe, usbhid-&gt;outbuf, <span class="hljs-number">0</span>,<br> hid_irq_out, hid, interval);<br>usbhid-&gt;urbout-&gt;transfer_dma = usbhid-&gt;outbuf_dma;<br>usbhid-&gt;urbout-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br>&#125;<br>&#125;<br><br>usbhid-&gt;urbctrl = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!usbhid-&gt;urbctrl) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br>usb_fill_control_urb(usbhid-&gt;urbctrl, dev, <span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *) usbhid-&gt;cr,<br>     usbhid-&gt;ctrlbuf, <span class="hljs-number">1</span>, hid_ctrl, hid);<br>usbhid-&gt;urbctrl-&gt;transfer_dma = usbhid-&gt;ctrlbuf_dma;<br>usbhid-&gt;urbctrl-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br><br>set_bit(HID_STARTED, &amp;usbhid-&gt;iofl);<br><br><span class="hljs-keyword">if</span> (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL) &#123;<br>ret = usb_autopm_get_interface(usbhid-&gt;intf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> fail;<br>set_bit(HID_IN_POLLING, &amp;usbhid-&gt;iofl);<br>usbhid-&gt;intf-&gt;needs_remote_wakeup = <span class="hljs-number">1</span>;<br>ret = hid_start_in(hid);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>dev_err(&amp;hid-&gt;dev,<br><span class="hljs-string">&quot;failed to start in urb: %d\n&quot;</span>, ret);<br>&#125;<br>usb_autopm_put_interface(usbhid-&gt;intf);<br>&#125;<br><br><span class="hljs-comment">/* Some keyboards don&#x27;t work until their LEDs have been set.</span><br><span class="hljs-comment"> * Since BIOSes do set the LEDs, it must be safe for any device</span><br><span class="hljs-comment"> * that supports the keyboard boot protocol.</span><br><span class="hljs-comment"> * In addition, enable remote wakeup by default for all keyboard</span><br><span class="hljs-comment"> * devices supporting the boot protocol.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (interface-&gt;desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) &#123;<br><span class="hljs-keyword">if</span> (interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD) &#123;<span class="hljs-comment">//设置键盘默认唤醒功能</span><br>usbhid_set_leds(hid);<br>device_set_wakeup_enable(&amp;dev-&gt;dev, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) &#123;<span class="hljs-comment">//设置鼠标默认唤醒功能</span><br>            <span class="hljs-comment">//一般不建议开启鼠标唤醒功能，部分游戏鼠标，尤其是使用USB接收器的无线鼠标，每隔一段时间它们会定期发送信号给电脑，以确认设备的持续连接状态，并保持接收器的供电。</span><br>device_set_wakeup_enable(&amp;dev-&gt;dev, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br>mutex_unlock(&amp;usbhid-&gt;mutex);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>fail:<br>usb_free_urb(usbhid-&gt;urbin);<br>usb_free_urb(usbhid-&gt;urbout);<br>usb_free_urb(usbhid-&gt;urbctrl);<br>usbhid-&gt;urbin = <span class="hljs-literal">NULL</span>;<br>usbhid-&gt;urbout = <span class="hljs-literal">NULL</span>;<br>usbhid-&gt;urbctrl = <span class="hljs-literal">NULL</span>;<br>hid_free_buffers(dev, hid);<br>mutex_unlock(&amp;usbhid-&gt;mutex);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查看usb设备唤醒功能脚本"><a href="#查看usb设备唤醒功能脚本" class="headerlink" title="查看usb设备唤醒功能脚本"></a>查看usb设备唤醒功能脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      author: TomWithKernel</span><br><br>fileName=&quot;&quot;<br>productName=&quot;&quot;<br><br>for file in /sys/bus/usb/devices/*/uevent; do<br>        content=$(cat &quot;$file&quot;)<br>        if echo &quot;$content&quot; | grep -q &quot;BUSNUM=$1&quot; &amp;&amp; echo &quot;$content&quot; | grep -q &quot;DEVNUM=$2&quot;; then<br>                fileName=&quot;$&#123;file%/*&#125;/power/wakeup&quot;<br>                productName=&quot;$&#123;file%/*&#125;/product&quot;<br><br>                if [ -f &quot;$fileName&quot; ]; then<br>                        busnum=$(echo &quot;$content&quot; | grep -oE &#x27;BUSNUM=([0-9]+)&#x27; | grep -oE &#x27;[0-9]+&#x27;)<br>                        devnum=$(echo &quot;$content&quot; | grep -oE &#x27;DEVNUM=([0-9]+)&#x27; | grep -oE &#x27;[0-9]+&#x27;)<br><br>                        result=$(cat &quot;$fileName&quot;)<br>                        productName=$(cat &quot;$productName&quot;)<br>                        printf &quot;Bus %3s Device %3s : %-30s power wakeup: %10s (路径: %s)\n&quot; $busnum $devnum &quot;$productName&quot; $result &quot;$&#123;file%/*&#125;/product&quot;<br>                fi<br>        fi<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取用户输入的设备节点和开关状态</span><br>read -p &quot;请输入你要修改的设备的节点（例如 1-4.4.2 表示 BusNum-Port.Port.DevNum）: &quot; modify_device<br>read -p &quot;请输入 enabled 或 disabled: &quot; switch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查用户输入的开关状态是否正确</span><br>if [[ &quot;$switch&quot; != &quot;enabled&quot; &amp;&amp; &quot;$switch&quot; != &quot;disabled&quot; ]]; then<br>    echo &quot;无效输入。请输入 &#x27;enabled&#x27; 或 &#x27;disabled&#x27;。&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构造设备路径</span><br>device_path=&quot;/sys/bus/usb/devices/$modify_device/power/wakeup&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查设备路径是否存在</span><br>if [ ! -f &quot;$device_path&quot; ]; then<br>    echo &quot;设备路径不存在或无效: $device_path&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改设备的 power wakeup 状态</span><br>echo $switch | sudo tee &quot;$device_path&quot; &gt; /dev/null<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确认修改结果</span><br>new_result=$(cat &quot;$device_path&quot;)<br>echo &quot;设备 $modify_device 的 power wakeup 状态已设置为: $new_result&quot;<br><br></code></pre></td></tr></table></figure><img src="/usb/wakeup/usb-wakeup.png" class="" title="usb-wakeup"><p>效果如图，根据自行需要进行修改usb设备唤醒功能</p>]]></content>
    
    
    <categories>
      
      <category>usb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Power Management</tag>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dynamic debug</title>
    <link href="/debug/dynamic/"/>
    <url>/debug/dynamic/</url>
    
    <content type="html"><![CDATA[<h3 id="Dynamic-debug"><a href="#Dynamic-debug" class="headerlink" title="Dynamic debug"></a>Dynamic debug</h3><p>Dynamic debug(dyndbg) 功能，就是允许用户空间通过 debugfs 导出的文件节点 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;dynamic_debug&#x2F;control，动态的、在运行时控制 Linux 内核 KERN_DEBUG 类型日志的开启和关闭。</p><h3 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_DYNAMIC_DEBUG=y<br>CONFIG_DEBUG_FS=y<br></code></pre></td></tr></table></figure><p>当打开了内核配置选项<code>CONFIG_DYNAMIC_DEBUG</code>， 内核中的<code>pr_debug()/dev_dbg()</code>和<code>print_hex_dump_debug()/print_hex_dump_bytes()</code>就使用了<code>Dynamic debug</code>特性。</p><p>当未打开了内核配置选项<code>CONFIG_DYNAMIC_DEBUG</code>:</p><ul><li><code>printk</code>就退化成<code>printk(KERN_DEBUG)</code></li><li><code>print_hex_dump_debug()</code> 就退化成<code>print_hex_dump(KERN_DEBUG)</code></li><li><code>dev_dbg</code>就退化为空。</li></ul><p><code>Dynamic debug</code>在<code>debugfs</code>中有个控制文件节点：<code>/sys/kernel/debug/dynamic_debug/control</code>。它记录了所有使用<code>Dynamic debug</code>技术的文件路径、行号、模块名称、函数名称和要打印的语句。</p><h3 id="查看dynamic-debug的行为"><a href="#查看dynamic-debug的行为" class="headerlink" title="查看dynamic debug的行为"></a>查看dynamic debug的行为</h3><p>我们可以通过向读文件<code>/sys/kernel/debug/dynamic_debug/control</code>来查看目前系统上<code>Dynamic debug</code>的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo cat /sys/kernel/debug/dynamic_debug/control | head                                                                                              [14:27:15]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">filename:lineno [module]<span class="hljs-keyword">function</span> flags format</span><br>drivers/usb/storage/usb.c:1131 [usb_storage]storage_probe =_ &quot;Use Bulk-Only transport with the Transparent SCSI protocol for dynamic id: 0x%04x 0x%04x\012&quot;<br>drivers/usb/storage/usb.c:1067 [usb_storage]usb_stor_probe2 =_ &quot;waiting for device to settle before scanning\012&quot;<br>drivers/usb/storage/usb.c:917 [usb_storage]usb_stor_scan_dwork =_ &quot;scan complete\012&quot;<br>drivers/usb/storage/usb.c:899 [usb_storage]usb_stor_scan_dwork =_ &quot;starting scan\012&quot;<br>drivers/usb/storage/sierra_ms.c:110 [usb_storage]truinst_show =_ &quot;SWIMS: failed SWoC query\012&quot;<br>drivers/usb/storage/sierra_ms.c:89 [usb_storage]debug_swoc =_ &quot;SWIMS: Linux Version: %04X\012&quot;<br>drivers/usb/storage/sierra_ms.c:88 [usb_storage]debug_swoc =_ &quot;SWIMS: Linux SKU: %04X\012&quot;<br>drivers/usb/storage/sierra_ms.c:87 [usb_storage]debug_swoc =_ &quot;SWIMS: SWoC Rev: %02d\012&quot;<br>drivers/usb/storage/sierra_ms.c:69 [usb_storage]sierra_get_swoc_info =_ &quot;SWIMS: Attempting to get TRU-Install info\012&quot;<br></code></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>控制打印时，还可以使用flags更来定义更详细的输出信息，目前支持的flags如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">p    enables the pr_debug() callsite.<br>f    Include the function name in the printed message<br>l    Include line number in the printed message<br>m    Include module name in the printed message<br>t    Include thread ID in messages not generated from interrupt context<br>_    No flags are set. (Or&#x27;d with others on input)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使能文件svcsock.c中1603行的输出</span><br>echo -n &quot;file svcsock.c line 1603 +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开函数svc_process中所有的动态输出</span><br>echo -n &#x27;func svc_process +p&#x27; &gt; /sys/kernel/debug/dynamic_debug/control<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开启文件中的pr_debug或dev_dbg</span><br>echo -n &#x27;file $file_name +p&#x27; &gt; /sys/kernel/debug/dynaminc_debug/control<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭文件中的打印</span><br>echo -n &#x27;file $file_name -p&#x27; &gt; /sys/kernel/debug/dynaminc_debug/control<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">打开模块中的打印</span><br>echo -n &#x27;module $mod_name +p&#x27; &gt; /sys/kernel/debug/dynaminc_debug/control<br></code></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://linux.laoqinren.net/kernel/kernel-dynamic-debug/">https://linux.laoqinren.net/kernel/kernel-dynamic-debug/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kernel boot</title>
    <link href="/boot/boot/"/>
    <url>/boot/boot/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核Kernel启动过程"><a href="#Linux内核Kernel启动过程" class="headerlink" title="Linux内核Kernel启动过程"></a>Linux内核Kernel启动过程</h1><h2 id="内核启动的基本流程"><a href="#内核启动的基本流程" class="headerlink" title="内核启动的基本流程"></a>内核启动的基本流程</h2><img src="/boot/boot/boot1.png" class="" title="boot1"><h3 id="启动加载程序-Bootloader"><a href="#启动加载程序-Bootloader" class="headerlink" title="启动加载程序 (Bootloader)"></a>启动加载程序 (Bootloader)</h3><p>启动加载程序（如GRUB、LILO、syslinux等）负责将内核映像从存储设备加载到内存中，并准备好内核启动所需的环境。</p><ul><li><strong>加载内核映像</strong>：启动加载程序将压缩的内核映像（如vmlinuz）从硬盘加载到内存中。内核映像通常是一个gzip或其他格式压缩的二进制文件。</li><li><strong>加载initrd&#x2F;initramfs</strong>：如果使用initrd（初始RAM盘）或initramfs（初始RAM文件系统），启动加载程序也会将这些文件加载到内存中，以便内核在启动时使用。</li></ul><h3 id="内核解压阶段"><a href="#内核解压阶段" class="headerlink" title="内核解压阶段"></a>内核解压阶段</h3><p>在内核映像的开头，有一个小的解压缩程序，它负责解压内核的主体部分。</p><ul><li><strong>解压内核</strong>：内核映像被加载到内存后，解压缩程序会运行并将压缩的内核映像解压到适当的内存位置。</li><li><strong>跳转到解压后的内核</strong>：一旦解压完成，控制权会被移交给解压后的内核代码的入口点。</li></ul><h3 id="内核启动（kernel-startup）"><a href="#内核启动（kernel-startup）" class="headerlink" title="内核启动（kernel startup）"></a>内核启动（kernel startup）</h3><p>解压后的内核代码会从一个固定的入口点开始执行，这个入口点是平台和架构相关的。对于x86架构，通常是startup_32或startup_64函数。</p><ul><li><strong>架构特定的初始化</strong>：根据具体的硬件架构，内核会执行一些必要的初始化步骤，比如设置CPU的运行模式，初始化分页机制，建立基本的内存映射等。</li><li><strong>初始化内核堆栈</strong>：内核设置好自己的堆栈，以便后续的函数调用和操作。</li><li><strong>调用<code>start_kernel</code>函数</strong>：完成基础的硬件初始化后，内核会调用start_kernel函数，这是内核初始化的核心部分。</li></ul><h3 id="start-kernel函数"><a href="#start-kernel函数" class="headerlink" title="start_kernel函数"></a>start_kernel函数</h3><p>start_kernel函数位于init&#x2F;main.c文件中，负责完成大部分内核的初始化工作。</p><ul><li>初始化控制台：设置内核的打印机制，以便后续的输出可以显示出来。</li><li>初始化内存管理子系统：建立初始的内存管理结构，准备好内存分配机制。</li><li>检测和初始化硬件设备：内核会检测并初始化系统中的各种硬件设备和驱动程序。</li><li>启动中断处理机制：设置和启动中断处理机制，使得内核可以响应硬件中断。</li><li>初始化内核调度器：初始化内核调度器，以便管理进程调度。</li><li>加载初始进程：内核创建并启动第一个用户空间进程，通常是&#x2F;sbin&#x2F;init。</li></ul><h3 id="启动初始进程"><a href="#启动初始进程" class="headerlink" title="启动初始进程"></a>启动初始进程</h3><p>init进程是用户空间的第一个进程，负责进一步的系统初始化工作，包括启动系统服务和守护进程。</p><ul><li>init进程的初始化：init进程执行系统初始化脚本，设置各种系统参数和启动服务。</li><li>启动用户空间服务：最终，init进程启动配置的所有用户空间服务和守护进程，从而完成系统的启动过程。</li></ul><h2 id="内核文件加载及解压缩"><a href="#内核文件加载及解压缩" class="headerlink" title="内核文件加载及解压缩"></a>内核文件加载及解压缩</h2><h3 id="为什么是压缩文件"><a href="#为什么是压缩文件" class="headerlink" title="为什么是压缩文件"></a>为什么是压缩文件</h3><p>Linux内核映像通常是一个压缩文件，主要有以下原因：</p><ul><li><strong>减少存储空间</strong>: 压缩内核映像可以显著减少其在存储设备上的占用空间。这对嵌入式系统、存储资源有限的设备以及需要快速分发和更新内核的环境尤其重要</li><li><strong>加快加载速度</strong>: 压缩文件占用的空间更小，这意味着启动加载程序从磁盘读取文件到内存中的时间会更短。虽然解压缩内核映像需要一些时间，但现代处理器的解压缩速度非常快，通常解压缩的时间比从存储设备读取更多数据的时间要少。这会整体上加快启动过程。</li><li><strong>提高传输效率</strong>: 在网络上传输内核映像时，压缩文件可以显著减少带宽使用量。这对于需要远程更新内核的系统（OTA）非常有利。</li><li><strong>便于管理和分发</strong>: 压缩内核映像更便于在各种介质上分发，比如光盘、U盘等。一个较小的文件更容易管理、备份和分发。</li><li><strong>标准化处理</strong>: 使用压缩内核映像是一种标准做法，启动加载程序（如GRUB）已经能够很好地支持这种格式，能自动识别并处理压缩的内核映像。这使得系统启动过程更简单可靠。</li></ul><h3 id="文件类型vmlinuz和bzimage"><a href="#文件类型vmlinuz和bzimage" class="headerlink" title="文件类型vmlinuz和bzimage"></a>文件类型vmlinuz和bzimage</h3><p>在连接压缩映像文件之前，我们先来了解一下未经压缩的编译文件<code>vmlinux</code>。</p><h4 id="什么是vmlinux"><a href="#什么是vmlinux" class="headerlink" title="什么是vmlinux"></a>什么是vmlinux</h4><p><code>vmlinux</code>是<code>内核编译过程</code>中生成的一个包含所有内核代码和数据的<code>二进制文件</code>。它是未经压缩和未经过处理的内核映像，通常位于内核源码目录的根目录下,特性如下：</p><ul><li><strong>未压缩</strong>：vmlinux 是内核的未压缩映像。它包含所有内核代码、内核模块以及相关的数据结构。</li><li><strong>ELF 格式</strong>：vmlinux 通常是一个 ELF（Executable and Linkable Format）文件，这是一个标准的可执行文件格式，用于存储可执行文件、目标代码和共享库等。</li><li><strong>符号信息</strong>：vmlinux 文件中包含调试符号和符号表信息，这些信息对内核调试和分析非常重要。</li><li><strong>没有文件后缀</strong>：虽然 vmlinux 通常没有文件后缀，但它是一个标准的 ELF 文件，可以通过文件头信息识别其格式。</li></ul><h4 id="vmlinux的生成过程"><a href="#vmlinux的生成过程" class="headerlink" title="vmlinux的生成过程"></a>vmlinux的生成过程</h4><p>编译Linux内核时，vmlinux是在链接阶段生成的。以下是一个简化的生成过程：</p><ul><li><strong>编译各个源文件</strong>：内核的各个源文件（<code>.c</code> 和 <code>.S</code> 文件）首先被编译为目标文件（.o 文件）。</li><li><strong>链接目标文件</strong>：所有目标文件通过链接器（如<code>ld</code>）链接在一起，生成一个完整的内核映像，这个映像就是 vmlinux。</li></ul><blockquote><p>链接命令举例:<code>ld -o vmlinux [object files] [linker scripts]</code></p></blockquote><h4 id="vmlinuz和bzimage的生成过程"><a href="#vmlinuz和bzimage的生成过程" class="headerlink" title="vmlinuz和bzimage的生成过程"></a>vmlinuz和bzimage的生成过程</h4><p>在获得编译文件vmlinux后，通常使用压缩工具做进一步处理。</p><ul><li><strong>压缩内核映像</strong>：将 vmlinux 压缩生成 vmlinuz。通常使用 gzip 或其他压缩工具。</li></ul><blockquote><p>压缩命令: <code>gzip -c vmlinux &gt; vmlinuz</code></p></blockquote><ul><li><strong>生成引导加载程序格式的内核映像</strong>：一些系统需要特定格式的内核映像，例如 bzImage（适用于 x86 架构）。</li></ul><blockquote><p>生成命令：<code>make bzImage</code></p></blockquote><h4 id="其他压缩格式"><a href="#其他压缩格式" class="headerlink" title="其他压缩格式"></a>其他压缩格式</h4><p><code>vmlinuz</code>、<code>bzImage</code>、<code>zImage</code> 和 <code>uImage</code> 都是不同的 Linux 内核映像文件格式，它们各自有不同的用途和特性。</p><ul><li><strong>vmlinuz</strong>：通用的压缩内核映像名称，主要用于各种 Linux 发行版。通常使用 gzip 压缩。</li><li><strong>bzImage</strong>：大内核映像，解决了早期 zImage 的内存限制问题。用于 x86 架构，支持较大的内核映像。</li><li><strong>zImage</strong>：较老的内核映像格式，适用于小内核映像，受限于低内存地址空间。</li><li><strong>uImage</strong>：U-Boot 使用的内核映像格式，广泛用于嵌入式系统。包含 U-Boot 头部信息，支持多种压缩算法。</li></ul><h4 id="Android系统文件"><a href="#Android系统文件" class="headerlink" title="Android系统文件"></a>Android系统文件</h4><p>在 Android 系统中，内核的压缩文件格式通常是<code>zImage</code>或<code>Image.gz</code>，具体取决于所使用的启动加载程序和设备的要求。</p><ul><li><strong>zImage</strong>：在一些早期的 Android 设备上，内核映像可能采用 zImage 格式。这种格式的内核映像通常会被启动加载程序直接加载并解压，然后启动内核。</li><li><strong>Image.gz</strong>：Image.gz 是指经过 gzip 压缩的内核映像。这种格式的内核映像通常是 Linux 内核编译过程中生成的 vmlinuz 文件，只是在 Android 系统中可能被重新命名为 Image.gz。启动加载程序会加载这个压缩的内核映像，并在加载到内存后解压缩，然后启动内核。</li></ul><h3 id="内核加载过程"><a href="#内核加载过程" class="headerlink" title="内核加载过程"></a>内核加载过程</h3><img src="/boot/boot/boot2.png" class="" title="boot2"><h4 id="内核映像加载到内存中"><a href="#内核映像加载到内存中" class="headerlink" title="内核映像加载到内存中"></a>内核映像加载到内存中</h4><p>启动加载程序（Bootloader）负责将压缩的内核映像加载到内存中，并准备好启动内核的环境。</p><ul><li><strong>加载内核和initrd</strong>：GRUB 会根据配置文件（通常是 grub.cfg）加载压缩的内核映像和可选的 initrd&#x2F;initramfs 文件。</li><li><strong>设置内核参数</strong>：GRUB 会设置内核启动参数，这些参数可以通过命令行传递给内核。</li><li><strong>跳转到内核入口点</strong>：GRUB 将控制权转移到内核映像的入口点。对于 x86 架构，这个入口点通常在内核映像的开头。</li></ul><h5 id="启动BootLoader"><a href="#启动BootLoader" class="headerlink" title="启动BootLoader"></a>启动BootLoader</h5><p>以BIOS为例</p><ul><li>CPU在重置后执行的第一条指令的内存地址<code>0xfffffff0</code>，它包含一个 jump 指令，这个指令通常指向BIOS入口点。</li><li>BIOS会进行一系列硬件初始化和自检，然后根据设置（例如启动顺序）选择一个启动设备（如硬盘、光盘、USB 等）</li><li>将控制权转移到启动设备的启动扇区代码。</li></ul><h5 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件"></a>加载内核文件</h5><ul><li>启动设备的启动扇区代码被执行，通常这段代码非常小，只占用一个扇区（512字节）。</li><li>启动扇区代码负责完成一些基本的初始化操作，然后跳转到更复杂的引导加载程序，如 GRUB 的核心映像（<code>core image</code>）。</li><li>核心映像开始执行，它负责进一步的初始化操作，如加载GRUB的模块和配置文件（grub.cfg）。</li><li>根据<code>grub.cfg</code>文件中的配置，GRUB加载压缩的内核映像（<code>vmlinuz</code>）和可选的<code>initrd/initramfs</code>文件。</li><li>内核映像加载完成后，GRUB 将控制权转移给内核的入口点代码，完成控制权从 BIOS 到内核的转移。</li></ul><h4 id="内核解压"><a href="#内核解压" class="headerlink" title="内核解压"></a>内核解压</h4><p>以下以x86系统为例</p><h5 id="关键文件和代码路径"><a href="#关键文件和代码路径" class="headerlink" title="关键文件和代码路径"></a>关键文件和代码路径</h5><ul><li>arch&#x2F;x86&#x2F;boot&#x2F;header.S：启动代码的汇编部分，定义了内核入口点。</li><li>arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;head_64.S 和 arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;misc.c：解压缩代码。</li><li>arch&#x2F;x86&#x2F;kernel&#x2F;head_64.S 和 arch&#x2F;x86&#x2F;kernel&#x2F;head.c：解压后的内核启动代码。</li></ul><h5 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h5><h6 id="启动加载程序跳转到内核入口点"><a href="#启动加载程序跳转到内核入口点" class="headerlink" title="启动加载程序跳转到内核入口点"></a>启动加载程序跳转到内核入口点</h6><ul><li>BootLoader根据<code>grub.cfg</code>文件中的配置加载内核映像（<code>vmlinuz</code>）到内存，并跳转到内核映像的入口点，即内核代码的起始地址。</li></ul><h6 id="解压缩程序的初始化"><a href="#解压缩程序的初始化" class="headerlink" title="解压缩程序的初始化"></a>解压缩程序的初始化</h6><ul><li>内核入口点代码（在 header.S 中）会设置初始的 CPU 状态和内存环境，然后跳转到解压缩代码的入口。</li><li>32位方法<code>startup_32</code>，64位方法<code>startup_64</code>。（长模式的32到64转换这里不做讨论，有兴趣的可以自行查阅资料）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTRY(startup_32)<br>// 设置 CPU 状态和内存环境<br>jmp decompress_kernel // 跳转到解压缩代码<br></code></pre></td></tr></table></figure><h6 id="解压缩代码执行"><a href="#解压缩代码执行" class="headerlink" title="解压缩代码执行"></a>解压缩代码执行</h6><ul><li>解压缩代码的入口点在 arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;head_64.S 中。</li><li>arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;head_64.S 会设置解压环境，如设置段寄存器、建立临时堆栈等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTRY(decompress_kernel)<br>// 设置硬件环境<br>// 调用解压缩函数入口方法<br>jmp decompress_kernel_method<br></code></pre></td></tr></table></figure><h6 id="解压缩完成后跳转到内核入口"><a href="#解压缩完成后跳转到内核入口" class="headerlink" title="解压缩完成后跳转到内核入口"></a>解压缩完成后跳转到内核入口</h6><ul><li>解压完成后，解压缩代码会跳转到解压后的内核入口点。</li><li>arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;head_64.S中定义了一个跳转指令，内核入口点的地址加载到寄存器中（例如 %eax），通常是内核主函数（<code>start_kernel</code>），跳转后即将控制权转移到解压后的内核代码。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp *%eax<br></code></pre></td></tr></table></figure><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><h6 id="跳转入口点和控制权转移"><a href="#跳转入口点和控制权转移" class="headerlink" title="跳转入口点和控制权转移"></a>跳转入口点和控制权转移</h6><ul><li>在技术实现上跳抓入口点和控制权转移是一致的，都是通过改变程序计数器（Program Counter，PC）或指令指针（Instruction Pointer，IP）的值来实现的。</li></ul><blockquote><p>程序计数器或指令指针是一个特殊的寄存器，用于存储正在执行的指令的内存地址。当处理器执行一条指令时，程序计数器会自动递增到下一条指令的地址，从而控制执行流程。这样就实现了执行流程的转移，从而使得程序执行从一个代码段转移到另一个代码段。</p></blockquote><ul><li>“跳转到入口点”强调了执行流程从某个特定的位置（入口点）开始执行，而”控制权转移”则更加广泛地描述了执行流程从一个执行上下文到另一个执行上下文的转移过程。</li><li>在内核加载和启动的上下文中，这两个术语通常可以互换使用，因为在设置了内核入口点后，执行流程的转移也意味着控制权的转移。</li></ul><h6 id="initrd-initramfs文件"><a href="#initrd-initramfs文件" class="headerlink" title="initrd&#x2F;initramfs文件"></a>initrd&#x2F;initramfs文件</h6><p>加载 vmlinuz（Linux 内核映像）时，通常还会加载 initrd（initial ramdisk）或 initramfs（initial ram filesystem）文件。initrd 和 initramfs 文件的主要作用是在内核启动的早期阶段提供一个临时的根文件系统，帮助内核完成启动过程。</p><p><strong>特性如下</strong>：</p><ul><li>硬件驱动支持： 在系统启动时，内核可能需要加载某些硬件驱动程序（如文件系统驱动、磁盘驱动、网络驱动等）来访问根文件系统。这些驱动程序可能并未内置在内核映像中，而是作为模块存在。initrd&#x2F;initramfs 提供了一个早期的文件系统，内核可以从中加载必要的模块。</li><li>根文件系统挂载：在一些复杂的存储配置中，如 LVM（Logical Volume Manager）、RAID、加密文件系统等，内核需要在挂载实际根文件系统之前进行一些初始化操作。这些操作通常通过 initrd&#x2F;initramfs 中的脚本完成。</li><li>通用内核：发行版通常提供通用内核以支持多种硬件配置。使用 initrd&#x2F;initramfs 可以在启动时动态加载适配不同硬件配置的模块，而无需为每种硬件配置编译一个特定的内核。</li></ul><p><strong>加载过程</strong>：</p><ul><li>启动加载程序(BootLoader)将内核映像和initrd&#x2F;initramfs文件加载到内存中，并将控制权交给内核。</li><li>内核启动时会识别并加载initrd&#x2F;initramfs文件，将其作为初始根文件系统挂载。</li><li>内核从临时根文件系统中加载必要的模块并运行初始化脚本。</li><li>初始化脚本完成必要的硬件初始化和配置后，会挂载实际的根文件系统（如 &#x2F;dev&#x2F;sda1）。</li><li>初始化脚本切换到实际根文件系统，然后移除initrd&#x2F;initramfs文件。</li></ul><h2 id="内核启动（start-kernel）"><a href="#内核启动（start-kernel）" class="headerlink" title="内核启动（start_kernel）"></a>内核启动（start_kernel）</h2><p><code>start_kernel</code>是Linux内核中非常重要的一个函数，它是整个内核初始化的核心函数，负责初始化内核的各个子系统、驱动程序以及其他关键组件，并最终将控制权转移到用户空间。</p><h3 id="start-kernel方法介绍"><a href="#start-kernel方法介绍" class="headerlink" title="start_kernel方法介绍"></a>start_kernel方法介绍</h3><h4 id="第一个C函数的位置"><a href="#第一个C函数的位置" class="headerlink" title="第一个C函数的位置"></a>第一个C函数的位置</h4><p><code>start_kernel</code>方法的定义通常位于<code>init/main.c</code>文件中，也是Linux启动过程中执行的第一个C函数</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li><strong>初始化内核的基本设置</strong>：如内存管理、进程管理等。</li><li><strong>初始化各个子系统</strong>：如文件系统、网络子系统、设备驱动程序等。</li><li><strong>启动第一个用户进程</strong>：将控制权从内核转移到用户空间。</li></ul><h3 id="start-kernel源码"><a href="#start-kernel源码" class="headerlink" title="start_kernel源码"></a>start_kernel源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage __visible <span class="hljs-type">void</span> __init <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-type">char</span> *command_line;  <br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernel_param</span> __<span class="hljs-title">start___param</span>[], __<span class="hljs-title">stop___param</span>[];</span>  <br>  <br>    <span class="hljs-comment">/* ... 其他初始化代码 ... */</span>  <br>  <br>    <span class="hljs-comment">/* 设置页表和内存管理 */</span>  <br>    paging_init();  <br>    mem_init();  <br>    kmem_cache_init();  <br>  <br>    <span class="hljs-comment">/* 设备和驱动程序初始化 */</span>  <br>    driver_init();  <br>    init_irq_proc();  <br>    softirq_init();  <br>    time_init();  <br>    console_init();  <br>  <br>    <span class="hljs-comment">/* 文件系统初始化 */</span>  <br>    vfs_caches_init_early();  <br>    mnt_init();  <br>    init_rootfs();  <br>    init_mount_tree();  <br>  <br>    <span class="hljs-comment">/* 初始化进程 */</span>  <br>    pid_cache_init();  <br>    proc_caches_init();  <br>    <span class="hljs-comment">/* 启动 init 进程 */</span><br>    rest_init();  <br>  <br>    <span class="hljs-comment">/* ... 其他初始化代码 ... */</span>  <br>  <br>    <span class="hljs-comment">/* 调用内核参数解析函数 */</span>  <br>    kernel_param_init(karg_strings, num_args);  <br>  <br>    <span class="hljs-comment">/* ... 其他初始化代码 ... */</span>  <br>  <br>    <span class="hljs-comment">/* 永远不会返回 */</span>  <br>    cpu_idle();  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动初始进程（init-process）"><a href="#启动初始进程（init-process）" class="headerlink" title="启动初始进程（init process）"></a>启动初始进程（init process）</h2><h3 id="进程概念介绍"><a href="#进程概念介绍" class="headerlink" title="进程概念介绍"></a>进程概念介绍</h3><h4 id="内核进程（Kernel-Thread）和用户进程（User-Process）"><a href="#内核进程（Kernel-Thread）和用户进程（User-Process）" class="headerlink" title="内核进程（Kernel Thread）和用户进程（User Process）"></a>内核进程（Kernel Thread）和用户进程（User Process）</h4><h5 id="内核进程（Kernel-Thread）"><a href="#内核进程（Kernel-Thread）" class="headerlink" title="内核进程（Kernel Thread）"></a>内核进程（Kernel Thread）</h5><p>内核进程是由内核创建和调度的线程，运行在内核态，用于处理内核的各类任务。与用户进程不同，内核进程不直接与用户空间交互，主要用于执行内核内部的工作，如处理中断、管理设备、调度任务等。</p><ul><li><strong>运行空间</strong>：内核进程运行在内核地址空间，而普通用户进程运行在用户地址空间。</li><li><strong>权限</strong>：内核进程可以直接访问内核数据结构，而用户进程通过系统调用与内核交互。</li><li><strong>交互</strong>：内核进程通常不与用户交互，其生命周期完全由内核管理。</li><li><strong>创建方式</strong>：内核进程的创建通常通过kernel_thread函数实现。</li></ul><div class="note note-primary">            <p>注意内核进程是独立的，与0、1、2号进程无关</p>          </div><h5 id="用户进程（User-Process）"><a href="#用户进程（User-Process）" class="headerlink" title="用户进程（User Process）"></a>用户进程（User Process）</h5><p>用户进程是在用户空间中执行的进程，用户通过编写和执行应用程序来创建用户进程。用户进程通过系统调用与内核交互，进行资源分配、文件操作、网络通信等。</p><ul><li><strong>运行空间</strong>：用户进程运行在用户态，受限于用户空间的权限，不能直接访问硬件和内核数据结构。</li><li><strong>权限</strong>：内核线程运行在内核态，具有更高的权限，能够直接操作内核资源。</li></ul><h4 id="0号进程、1号进程、2号进程"><a href="#0号进程、1号进程、2号进程" class="headerlink" title="0号进程、1号进程、2号进程"></a>0号进程、1号进程、2号进程</h4><ul><li><code>0号进程</code>：是内核线程，运行在内核态，负责在系统空闲时执行。</li><li><code>1号进程</code>：是内核线程，后期会切换到用户进程（init进程），执行内核部分初始化工作及进行系统配置，并创建若干个用于高速缓存和虚拟主存管理的内核线程。</li><li><code>2号进程</code>：是内核进程，运行在内核态，负责创建和管理其他内核线程。这些内核线程通常用于执行内核中的异步任务，如磁盘I&#x2F;O、网络操作等。</li></ul><h5 id="0号进程（swapper-idle-空闲进程）"><a href="#0号进程（swapper-idle-空闲进程）" class="headerlink" title="0号进程（swapper&#x2F;idle&#x2F;空闲进程）"></a>0号进程（swapper&#x2F;idle&#x2F;空闲进程）</h5><ul><li>0号进程是Linux启动的第一个进程，它的task_struct的comm字段为”swapper”，也称为swapper进程、idel进程、空闲进程。</li><li>0号进程是在系统引导过程中由内核创建的第一个进程。它的任务是进入空闲循环，当系统中没有其他可运行的进程时，它会被调度执行，以避免CPU闲置。</li></ul><blockquote><p>0号进程（idle进程）是在系统引导过程中，由内核初始化代码创建的。在x86架构中，这个过程发生在汇编启动代码（通常在arch&#x2F;x86&#x2F;kernel&#x2F;head.S中），该代码会设置基本的CPU和内存环境，然后跳转到C语言的start_kernel函数。</p></blockquote><h5 id="1号进程（init进程）和2号进程（kthreadd进程）"><a href="#1号进程（init进程）和2号进程（kthreadd进程）" class="headerlink" title="1号进程（init进程）和2号进程（kthreadd进程）"></a>1号进程（init进程）和2号进程（kthreadd进程）</h5><ul><li>1号内核进程调用执行init函数演变成1号用户态进程（init进程），这里前者是init是函数，后者是进程</li><li>init（）函数在内核态运行，是内核代码</li><li>1号内核进程调用execve（）从文件&#x2F;etc&#x2F;inittab中加载执行init函数，这个过程并没有使用调用do_fork()，因此两个进程都是1号进程</li><li>1号进程和2号进程都是在<code>rest_init</code>函数中创建的</li><li>1号进程通过kernel_init创建</li><li>2号进程通过kthreadd创建</li></ul><p>0号进程-&gt;1号内核进程-&gt;1号用户进程（init进程）-&gt;getty进程-&gt;shell进程</p><img src="/boot/boot/boot3.png" class="" title="boot3"><h3 id="rest-init函数-初始化入口"><a href="#rest-init函数-初始化入口" class="headerlink" title="rest_init函数-初始化入口"></a><code>rest_init</code>函数-初始化入口</h3><p>rest_init函数负责创建初始进程并进行一些进一步的初始化工作。其代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> noinline <span class="hljs-type">void</span> __ref <span class="hljs-title function_">rest_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 通知RCU（Read-Copy Update）子系统，调度器即将开始。这是确保RCU在调度器开始运行前正确初始化的关键步骤。</span><br>    rcu_scheduler_starting();<br>    <span class="hljs-comment">// 创建pid=1的1号进程</span><br>    pid = kernel_thread(kernel_init, <span class="hljs-literal">NULL</span>, CLONE_FS);<br>    <span class="hljs-comment">/** 处理1号进程相关代码 **/</span><br>    <br>    <span class="hljs-comment">// 创建pid=2的2号进程</span><br>    pid = kernel_thread(kthreadd, <span class="hljs-literal">NULL</span>, CLONE_FS | CLONE_FILES);<br>    <span class="hljs-comment">/** 处理2号进程相关代码 **/</span><br>    <span class="hljs-comment">/** 其他初始化代码 **/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kernel-thread函数"><a href="#kernel-thread函数" class="headerlink" title="kernel_thread函数"></a><code>kernel_thread</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kernel_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)fn,<br>                   (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)arg, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>do_fork</code>：这是内核中实现创建新进程（或线程）的核心函数。通过该函数，内核可以复制当前进程的上下文，生成一个新的进程（或线程）。</li></ul><h4 id="kernel-init函数-初始化1号进程（init）"><a href="#kernel-init函数-初始化1号进程（init）" class="headerlink" title="kernel_init函数 - 初始化1号进程（init）"></a><code>kernel_init</code>函数 - 初始化1号进程（init）</h4><p>kernel_init负责启动初始用户空间进程（&#x2F;sbin&#x2F;init或指定的init进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __ref <span class="hljs-title function_">kernel_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *unused)</span><br>&#123;<br>    <span class="hljs-comment">/** 其他初始化代码 **/</span><br>    <span class="hljs-comment">// 启动用户空间进程</span><br>    <span class="hljs-keyword">if</span> (ramdisk_execute_command) &#123;<br>        run_init_process(ramdisk_execute_command);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (execute_command) &#123;<br>        run_init_process(execute_command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h3><p>init进程启动后，通过后续工作完成了操作系统的加载和启动</p><h4 id="系统初始化脚本"><a href="#系统初始化脚本" class="headerlink" title="系统初始化脚本"></a>系统初始化脚本</h4><p>init进程读取系统的初始化脚本（如&#x2F;etc&#x2F;inittab、&#x2F;etc&#x2F;init.d&#x2F;脚本）或systemd的单元文件（unit files），执行系统初始化任务。这包括设置系统环境、挂载文件系统、启动网络服务、启动守护进程等。</p><h4 id="启动用户界面"><a href="#启动用户界面" class="headerlink" title="启动用户界面"></a>启动用户界面</h4><ul><li><code>图形登录管理器</code>：如果系统配置为使用图形界面，init进程会启动图形登录管理器（如GDM、LightDM、SDDM）。这些登录管理器负责提供图形化的登录界面，供用户输入用户名和密码。</li><li><code>启动桌面环境</code>：用户登录成功后，登录管理器会启动用户的桌面环境（如GNOME、KDE、Xfce）。桌面环境提供完整的图形用户界面，允许用户运行应用程序、管理文件、设置系统等。</li></ul><h4 id="图形界面启动流程（systemd示例）"><a href="#图形界面启动流程（systemd示例）" class="headerlink" title="图形界面启动流程（systemd示例）"></a>图形界面启动流程（systemd示例）</h4><ul><li><strong>systemd初始化</strong>：systemd作为init进程启动，读取其配置文件（通常在&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;和&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;）。</li><li><strong>启动目标（target）</strong>：systemd根据配置文件启动系统目标（如graphical.target）。graphical.target包含了启动图形界面所需的所有服务。</li><li><strong>启动显示管理器</strong>：systemd启动图形显示管理器服务（如gdm.service、lightdm.service）。</li><li><strong>显示管理器运行</strong>：显示管理器提供图形登录界面，用户登录后启动用户会话。</li><li><strong>启动桌面环境</strong>：用户会话启动后，显示管理器启动桌面环境，用户进入图形用户界面。</li></ul><p>参考链接：</p><ul><li><p><a href="https://www.cnblogs.com/anywherego/p/18217546">https://www.cnblogs.com/anywherego/p/18217546</a></p></li><li><p><a href="https://blog.csdn.net/Hyc_cheng/article/details/120771756">https://blog.csdn.net/Hyc_cheng/article/details/120771756</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断</title>
    <link href="/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD/"/>
    <url>/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断（interrupt）通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。<br>中断通常分为同步（synchronous）中断和异步（asynchronous）中断：</p><ul><li>同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li><li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li></ul><p>在Intel微处理器手册中，把同步和异步中断分别称为<strong>异常</strong>（exception）和<strong>中断</strong>（interrupt）。我们也采用这种分类，当然有时我们也用术语“中断信号”指这两种类型（同步及异步）。</p><p>中断是由间隔定时器和I&#x2F;O设备产生的，例如，用户的一次按键会引起一个中断。另一方面，异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个每个Unix程序员都熟悉的信号来处理异常。第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页，或对内核服务的一个请求（通过一条int或sysenter指令）。</p><h3 id="中断和异常-1"><a href="#中断和异常-1" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul><li><p>中断：</p><ul><li><p>可屏蔽中断</p><p>I&#x2F;O设备发出的所有中断请求（IRQ)都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的（masked）或非屏蔽的（unmasked）：一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</p></li><li><p>非屏蔽中断</p><p>只有几个危急事件（如硬件故障）才引起非屏蔽中断，非屏蔽中断总是由CPU辨认</p></li></ul></li><li><p>异常</p><ul><li><p>处理器探测异常</p><p>当CPU执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于CPU控制单元产生异常时保存在内核态堆栈eip寄存器（在 x86 指令集中，EIP 寄存器存储着 CPU 将要执行的下一条指令的内存地址）中的值。</p><ul><li><p>故障</p><p>通常可以纠正；一且纠正，程序就可以在不失连贯性的情况下重新开始。保存在eip中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行。我们将在“缺页异常处理程序”一节中看到，只要处理程序能纠正引起异常的反常条件，重新执行同一指令就是必要的。</p></li><li><p>陷阱</p><p>在陷指令执行后立即报告：内核把控制权返回给程序后就可以继续它的执行而不失连贯性。保存在eip中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱。陷阱的主要用途是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一旦用户检查到调试程序所提供的数据，她就可能要求被调试程序从下一条指令重新开始执行。</p></li><li><p>异常终止</p><p>发生一个严重的错误：控制单元出了问题，不能在eip寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</p></li><li><p>编程异常</p><p>在编程者发出请求时发生。是由int或int3指令触发的：当into（检查溢出）和bound（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷来处理。编程异常通常也叫做软中断（software interrupt）。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</p></li></ul></li></ul></li></ul><p>每个中断和异常是由0~255之间的一个数来标识。因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量（vector）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><h3 id="IRQ和中断"><a href="#IRQ和中断" class="headerlink" title="IRQ和中断"></a>IRQ和中断</h3><p>​每个能够发出中断请求的硬件设备控制器都有一条名为IRQ（Interrupt ReQuest）的输出线（复杂一些的设备有几条IRQ线，例知，PCI卡可能使用多达4条IRQ线）。所有现有的IRQ线（IRQ line）都与一个名为可编程中断控制器（Programmable Interrupt Controller，PIC)的硬件电路的输入引脚相连，可编程中断控制器执行下列动作：</p><pre><code class="hljs"> 1. 监视IRQ线，检查产生的信号（raised signal）。如果有条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线 2. 如果一个引发信号出现在IRQ线上：  - 把接收到的引发信号转换成对应的向量  - 把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读取此向量  - 把引发信号发送到处理器的INTR引脚，即产生一个中断  - 等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认他；当这种情况发生时，清INTR线 3. 返回到第一步</code></pre><p>​IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示成IRQ0。与IRQn关联的Intel的缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>​可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断是丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ</p><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>​中断描述符表（Interrupt Descriptor Table.IDT）是一个系统表，它与每一个中断或异常向量（异常向量是一组预定义的内存地址，用于存储处理器在发生异常时应该跳转到的位置）相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。内核在允许中断发生前，必须适当地初始化IDT.</p><p>​IDT包含三种类型的描述符：</p><p>​任务门：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p><p>​中断门：包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</p><p>​陷阱门：与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志。</p><p>​Linux利用中断门处理中断，利用陷阱门处理异常</p>]]></content>
    
    
    <categories>
      
      <category>irq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>irq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程</title>
    <link href="/%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B/"/>
    <url>/%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​进程是程序执行时的一个实例，从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体</p><p>​当一个进程创建时，它几乎与父进程相同。它接受父进程地址空间的一个（逻辑）拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。尽管父子进程可以共享含有程序代码（正文）的页，但是它们各自有独立的数据拷贝（栈和堆），因此子进程对一个内存单元的修改对父进程是不可见的（反之亦然）</p><p>​Linux使用轻量级进程（lightweight process）对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。只要其中一个修改共享资源，另一个就立即查看这种修改。当然，当两个线程访问共享资源时就必须同步它们自己。</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><img src="/%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B/process1.png" class="" title="process1"><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>state字段描述了进程当前所处的状态</p><p>可运行状态（TASK_RUNNING)<br>        进程要么在CPU上执行，要么准备执行。</p><p>可中断的等待状态（TASK_INTERRUPTIBLE)<br>        进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING).</p><p>不可中断的等待状态（TASK_UNINTERRUPTIBLE)<br>        与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</p><p>暂停状态（TASK_STOPPED)<br>        进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。</p><p>跟踪状态（TASK_TRACED)<br>        进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时（例如debugger执行ptrace（）系统调用监控一个测试程序），任何信号都可以把这个进程置于TASK_TRACED状态。</p><p>还有两个进程状态是既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段的名称可以看出，只有当进程的执行被终止时，进程的状态才会变为这两种状态中的一种：</p><p>僵死状态（EXIT_ZOMBIE）<br>        进程的执行被终止，但是，父进程还没有发布wait4（）或waitpid（）系统调用来返回有关死亡进程的信息。发布wait（）类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它</p><p>僵死撤消状态（EXIT_DEAD)<br>        最终状态：由于父进程刚发出 wait4（）或waitpid（）系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait（）类系统调用（这是一种竞争条件），而把进程的状态由優死（EXIT_ZOMBIE）状态改为死撤消状态(EXIT-DEAD）参见第五）。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（context switch）。</p><h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>尽管每个进程可以拥有属于自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程时的值。</p><p>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核态堆栈中。</p><p>进程切换只发生在内核态。在执行进程切换之前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上，这也包括ss和esp这对寄存器的内容（存储用户态堆栈指针的地址）。</p><h4 id="任务状态段（TSS）"><a href="#任务状态段（TSS）" class="headerlink" title="任务状态段（TSS）"></a>任务状态段（TSS）</h4><p>​存放硬件上下文</p>]]></content>
    
    
    <categories>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scsi子系统</title>
    <link href="/scsi/scsi%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/scsi/scsi%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="scsi子系统"><a href="#scsi子系统" class="headerlink" title="scsi子系统"></a>scsi子系统</h2><h3 id="硬件模型"><a href="#硬件模型" class="headerlink" title="硬件模型"></a>硬件模型</h3><img src="/scsi/scsi%E5%AD%90%E7%B3%BB%E7%BB%9F/scsi_dev.png" class="" title="scsi_hardware"> <p>上图为scsi子系统的硬件拓扑图：</p><ul><li><p>soc芯片内部有host(0),host(1)…host(k)这些有scsi功能的控制器</p></li><li><p>这些host分别连接着片外的scsi设备device(0)…device(k)外设</p></li><li><p>每个device内部有若干个channel，每个channel下面有若干个id，每个id下面有若干个lun</p></li><li><p>这些lun就是可以接受scsi命令的实体，例如可以是硬盘，cdrom，磁带等等，也可以是一些可以接收特殊scsi命令的wlun</p></li></ul><h4 id="Host-0-k"><a href="#Host-0-k" class="headerlink" title="Host(0-k)"></a>Host(0-k)</h4><ul><li>表示可以发送和接收scsi命令的控制器。图示中的host(0)，host(1)是一个示意图，框图以描述host(k)为主</li><li>一个控制器对应一个外设；也可以不接任何外设</li></ul><div class="note note-warning">            <p>注意：需要说明的是，现实硬件里看不到任何纯scsi控制器；例如ufs的scsi命令是ufs控制器通过upiu传送和接收的，upiu是在mipi总线上传送的物理信息，而scsi则是cmd upiu中的字段。再例如usb U盘，也是类似情况。</p>          </div><ul><li><p>在UFS设备中，虽然上层协议采用了SCSI命令集，但传输介质和方法并不直接依赖SCSI硬件控制器。UFS控制器通过<strong>UPIU（UFS Protocol Information Unit）</strong>来传输和接收SCSI命令。UPIU可以看作是一种封装结构，承载了SCSI命令。最终，UPIU在物理上通过<strong>MIPI（Mobile Industry Processor Interface）</strong>总线传输，而不是传统的SCSI总线。</p></li><li><p>UFS协议栈利用SCSI命令集来处理存储请求，但这些SCSI命令实际上通过UPIU载体在MIPI总线上进行传输。因此，SCSI命令只是协议的一部分，而实际的物理层由其他技术来完成。</p></li></ul><p>因此这里的host(0),host(1)…host(k)是一个控制器抽象描述，真实的控制器可以是ufs、usb上接着的硬盘控制器(这个应该画在soc外面)或者pcie上挂着的硬盘控制器(这个也应该画在soc外面)。</p><h4 id="device-0-k"><a href="#device-0-k" class="headerlink" title="device(0-k)"></a>device(0-k)</h4><p>图示中，例子device(0)是连接到host(0)控制器上的外设；device(k)是连接到host(k)控制器上的外设。外设可以是硬盘，光驱，ufs等。</p><p>Host和device之间的连接方式用了一个双箭头表示，它是一个抽象描述，代表scsi命令通道。</p><img src="/scsi/scsi%E5%AD%90%E7%B3%BB%E7%BB%9F/scsi_2.png" class="" title="scsi"> <p>Scsi只是一个协议，因此各种五花八门的控制器都可以使用scsi进行交互。因此这个“通道”是借助各种控制器的驱动来完成的。有点像协议分层，scsi类似于协议层，而物理层，链路层则交给了各种控制器去完成。</p><h4 id="channel-id"><a href="#channel-id" class="headerlink" title="channel + id"></a>channel + id</h4><h5 id="SCSI-channel"><a href="#SCSI-channel" class="headerlink" title="SCSI channel"></a>SCSI channel</h5><ul><li><p>scsi channel（通道）指的是设备之间数据传输的物理或逻辑路径。一个SCSI控制器可以有多个通道，每个通道能够连接多个设备，类似于一条“数据总线”。具体而言：</p><ul><li>一个SCSI通道可以看作是多个设备共用的连接“线路”，所有的设备通过这个通道与控制器进行通信。</li><li>在多通道的SCSI控制器中，通道可以分开管理，通常用于连接多个设备或分离设备组（例如硬盘、磁带机等）。</li></ul><p><strong>举例</strong>：某些高端服务器可能会配备双通道SCSI控制器，一个通道连接硬盘，另一个通道连接磁带机。</p></li></ul><h5 id="SCSI-id"><a href="#SCSI-id" class="headerlink" title="SCSI id"></a>SCSI id</h5><ul><li><p>scsi id是分配给每个SCSI设备的唯一标识符，用于区分同一通道上连接的不同设备。每个设备都需要有一个唯一的ID，以便主机能够识别它们。SCSI ID的作用类似于网络中的IP地址，是设备之间通信的基本标识。</p><ul><li>SCSI设备的ID范围通常为0到7（针对7设备的窄SCSI），或者0到15（针对15设备的宽SCSI），主机和每个设备都占用一个ID。</li><li><strong>主机</strong>（也就是SCSI控制器）通常默认使用ID 7（在窄SCSI中），因为它需要优先管理与其他设备的通信。</li><li>每个设备（例如硬盘、光驱）都有唯一的SCSI ID，控制器通过这个ID与设备进行通信。</li></ul><p><strong>举例</strong>： 在窄SCSI中，假设主机的SCSI ID为7，三个硬盘的SCSI ID分别为0、1、2。主机在通过通道发送数据时，会根据SCSI ID将数据发送到相应的设备</p></li></ul><h5 id="SCSI-Channel和ID的用途"><a href="#SCSI-Channel和ID的用途" class="headerlink" title="SCSI Channel和ID的用途"></a>SCSI Channel和ID的用途</h5><ul><li><strong>设备识别</strong>：SCSI通道加上SCSI ID的组合确保了在一个SCSI总线上的设备能够被唯一识别。例如，假设一个服务器有一个双通道SCSI控制器，并且每个通道上连接多个硬盘。每个硬盘将通过特定的通道和ID被主机识别和访问。</li><li><strong>多设备管理</strong>：SCSI通道和ID的设计允许多个设备共享一个通道进行通信。例如，在旧式SCSI系统中，多个设备可以共享一条SCSI总线。ID区分了不同设备，使得主机能够管理并同时访问多个设备。</li><li><strong>优先级</strong>：在传统SCSI系统中，ID的数值还影响设备的优先级。ID越高，优先级越高。例如，SCSI ID 7（通常分配给控制器）具有最高优先级，这意味着它的操作通常会优先于其他设备。</li></ul><h4 id="SCSI-Target"><a href="#SCSI-Target" class="headerlink" title="SCSI Target"></a>SCSI Target</h4><p>在SCSI（Small Computer System Interface）系统中，<strong>Target</strong>是指一个<strong>SCSI设备</strong>，它负责响应来自<strong>Initiator</strong>（主机）发出的SCSI命令。Target设备可以是多种类型的硬件设备，通常包括存储设备如硬盘、光驱、磁带机、或者RAID控制器。</p><p><strong>Target</strong>是Initiator与SCSI系统中的设备通信的对象。在SCSI架构中：</p><ul><li><strong>Initiator</strong>：是发出SCSI命令的设备，通常是计算机的主机控制器（Host Bus Adapter, HBA）。</li><li><strong>Target</strong>：是接收并处理这些命令的设备，比如硬盘、光驱等。</li></ul><p><strong>Target设备的例子</strong>：</p><ul><li>SCSI硬盘</li><li>SCSI磁带机</li><li>SCSI光驱</li><li>RAID控制器</li></ul><p><strong>Target与ID</strong>：</p><ul><li><strong>Target</strong>设备通过一个SCSI总线的<strong>ID</strong>来标识。每个Target在SCSI总线上都有一个唯一的<strong>Target ID</strong>。多个设备（Target）可以连接在同一个SCSI总线上，每个设备都通过不同的ID来区分。</li><li>SCSI ID是Target设备在SCSI总线上的唯一标识符，决定了系统如何识别和寻址该设备。</li></ul><p><strong>Target与LUN（Logical Unit Number，逻辑单元号）</strong>：</p><ul><li>一个Target设备可以包含多个<strong>LUN</strong>，每个LUN代表设备内部的一个逻辑单元。例如，一个硬盘可能有多个逻辑卷（partition），每个卷会有一个不同的LUN。</li><li>LUN的存在让Target设备能够表示多个逻辑资源（例如，一个RAID控制器有多个磁盘阵列，每个阵列可能分配一个LUN）。</li></ul><h4 id="LUN"><a href="#LUN" class="headerlink" title="LUN"></a>LUN</h4><p><strong>LUN作为SCSI命令接收主体</strong>：</p><ul><li><strong>LUN（逻辑单元号）</strong>可以代表不同的设备或逻辑实体，能够接收并处理来自SCSI Initiator的命令。例如，它可以是一个物理硬盘、光驱等存储设备，或是UFS固件虚拟出来的设备，比如RPMB（Replay Protected Memory Block）、Boot0、Boot1等。</li></ul><p><strong>非物理实体的LUN</strong>：</p><ul><li>有些LUN并不对应实际的物理设备，而是虚拟逻辑单元，例如<code>REPORT LUNS</code>命令会返回设备上存在的LUN信息，这些LUN也是SCSI协议中的有效目标。</li></ul><p><strong>每个LUN在Linux通用块设备层（generic block layer）拥有独立的request queue</strong>：</p><ul><li>在Linux内核中，每个LUN都有自己的<strong>request queue</strong>，即请求队列，用于管理该LUN的I&#x2F;O请求。</li></ul><p><strong>逻辑分区</strong>：</p><ul><li>如果一个硬盘被分为多个逻辑分区（通过GPT或MBR），这些分区是在一个LUN内，因此它们共享同一个request queue。这种分区属于文件系统的层级，而不是在SCSI子系统内处理的。</li></ul><h3 id="scsi-三个重要组成"><a href="#scsi-三个重要组成" class="headerlink" title="scsi 三个重要组成"></a>scsi 三个重要组成</h3><h3 id="1-SCSI-Bus"><a href="#1-SCSI-Bus" class="headerlink" title="1. SCSI Bus"></a>1. <strong>SCSI Bus</strong></h3><ul><li><p><strong>SCSI Bus</strong> 是所有SCSI主机（Host）、目标设备（Target）和逻辑单元号（LUN）连接的总线。每个设备都对应一个 <code>struct device</code>，这些设备通过SCSI Bus进行组织和管理。</p></li><li><p>常见的SCSI设备驱动如 <strong>sd</strong>（磁盘驱动）、<strong>sr</strong>（光盘驱动）、<strong>osst</strong>（磁带驱动）等都挂载在SCSI Bus上，并通过 <code>struct device</code> 激活它们。</p><p><strong>作用</strong>：SCSI Bus 承载了所有设备的通信，使主机能够与各种目标设备（包括磁盘、光驱等）进行数据交换。</p></li></ul><h3 id="2-SCSI-Host"><a href="#2-SCSI-Host" class="headerlink" title="2. SCSI Host"></a>2. <strong>SCSI Host</strong></h3><ul><li><p><strong>SCSI Host</strong> 是主机控制器，它负责管理主机系统与SCSI设备之间的交互。它通过 <code>struct device</code> 注册到系统中，并挂载在 <code>scsi_host</code> class 下。</p></li><li><p>每个 SCSI Host 控制器都具有特定的属性，例如通过它的 <code>struct device</code> 的属性组（attr group, type）可以查看和控制其特性，如触发扫描操作。</p></li><li><p>可以通过在 <code>scsi_host</code> 上使用扫描（scan）机制来强制系统扫描主机下的所有SCSI设备。</p><p><strong>作用</strong>：SCSI Host 控制器通过处理SCSI命令，使主机能够与连接的SCSI设备进行交互，并协调设备的发现和管理。</p></li></ul><h3 id="3-SCSI-Device"><a href="#3-SCSI-Device" class="headerlink" title="3. SCSI Device"></a>3. <strong>SCSI Device</strong></h3><ul><li><p><strong>SCSI Device</strong> 表示SCSI子系统中的每一个 <strong>LUN（逻辑单元）</strong>。每个LUN在SCSI系统中都有一个对应的 <code>struct device</code>，并且这些设备都会挂载在 <code>scsi_device</code> class 上。</p></li><li><p>操作LUN的通用驱动程序是 <strong>sg.c</strong>，即SCSI通用（SCSI Generic）驱动，它提供了对LUN的直接操作接口。</p><p><strong>作用</strong>：SCSI Device 是SCSI子系统中的具体目标设备（如硬盘、光驱等）。每个LUN都可以独立接收并处理来自主机的SCSI命令。</p></li></ul><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://blog.csdn.net/feelabclihu/article/details/108675669">https://blog.csdn.net/feelabclihu/article/details/108675669</a></p>]]></content>
    
    
    <categories>
      
      <category>scsi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scsi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kgdb</title>
    <link href="/debug/kgdb/"/>
    <url>/debug/kgdb/</url>
    
    <content type="html"><![CDATA[<h2 id="KGDB"><a href="#KGDB" class="headerlink" title="KGDB"></a>KGDB</h2><p>kgdb是Linux内核提供的用于调试内核的源码级调试工具，支持断点设置，单步调试等源码调试常用功能，类似于在用户空间用gdb调试应用程序。kgdb从形式上来说类似于gdb server，你需要两台设备，一台主机，用于运行普通的gdb程序，一台被调试设备，需要安装所需调试的内核或者驱动，同时运行kgdb。kgdb与主机通过串口通讯，所以要在内核的启动参数里指定kgdb所需使用的串口设备号。</p><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h3><table><thead><tr><th>配置名称</th><th>作用</th></tr></thead><tbody><tr><td>CONFIG_KGDB_SERIAL_CONSOLE</td><td>使KGDB通过串口与主机通信(使用串口KGDB时必须打开)</td></tr><tr><td>CONFIG_KGDB_KDB</td><td>打开KGDB调试+KDB支持</td></tr><tr><td>CONFIG_DEBUG_INFO</td><td>使内核包含基本调试信息</td></tr><tr><td>CONFIG_DEBUG_KERNEL</td><td>包含驱动调试信息</td></tr><tr><td>CONFIG_GDB_SCRIPTS</td><td>用于支持vmlinux-gdb.py扩展</td></tr></tbody></table><h3 id="设置kgdboc参数"><a href="#设置kgdboc参数" class="headerlink" title="设置kgdboc参数"></a>设置kgdboc参数</h3><p><code>kgdboc</code> 是kgdb over consle的缩写，用来指定内核调试信息从哪里输出，这里我们使用了ttyUSB0串口输出，未来gdb便需要连接到对应串口来接收调试数据。</p><p><code>kgdbwait</code> 该参数可以让内核启动时准备好数据后等待gdb接入再继续启动内核。</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>主要用于调试内核初始化，在kernel的启动参数上添加<code>kgdboc=ttyXXX,115200 kgdbwait</code>，前者设置测试机使用的串口，后者数字设置波特率。</p><div class="note note-warning">            <p>​kgdbwait这个字符串的作用就是让内核停在刚启动的地方。</p>          </div><img src="/debug/kgdb/grub.png" class="" title="grub"><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>​在系统启动后，设置进入kgdb模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置调试串口</span><br>echo &quot;kgdboc=ttyXXX,115200&quot; &gt; /sys/module/kgdboc/parameters/kgdboc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置魔术键，g就是进行KGDB模式</span><br>echo g &gt; /proc/sysrq-trigger<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>​这里设置魔术键执行完后，测试机进入kgdb模块，这时测试机按任何键都不会有任何反应，内核等待接受gdb调试请求</p>          </div><h3 id="设置主机串口"><a href="#设置主机串口" class="headerlink" title="设置主机串口"></a>设置主机串口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install minicom<br>sudo minicom -s<br></code></pre></td></tr></table></figure><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>首先，在主机上安装gdb-multiarch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gdb-multiarch<br></code></pre></td></tr></table></figure><p>进入到内核源码根目录，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gdb-multiarch vmlinux<br></code></pre></td></tr></table></figure><p>我们需要设置目标平台，串口波特率，并且通过串口连接到开发板上的kgdb上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设备目标平台</span><br>set architecture aarch64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置串口波特率</span><br>set serial baud 115200<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主机通过串口连接到开发板上的kgdb</span><br>target remote /dev/ttyUSB0<br></code></pre></td></tr></table></figure><p>设置成功后会有如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set architecture aarch64<br>The target architecture is assumed to be aarch64<br>(gdb) set serial baud 115200<br>(gdb) target remote /dev/ttyUSB0<br>Remote debugging using /dev/ttyUSB0<br>arch_kgdb_breakpoint () at ./arch/arm64/include/asm/kgdb.h:21<br>21asm (&quot;brk %0&quot; : : &quot;I&quot; (KGDB_COMPILED_DBG_BRK_IMM));<br></code></pre></td></tr></table></figure><h3 id="agent-proxy"><a href="#agent-proxy" class="headerlink" title="agent-proxy"></a>agent-proxy</h3><p>kgdb目前有一个问题，它和测试机的Linux终端共用一个串口，所以在进行信息输出的时候无法使用kgdb，因为kgdb还等着使用该串口，一般测试机只有一个串口，这就给调试带来了很大的麻烦，因为一般驱动是要应用程序调用的，也就是说我在调试时可能需要不停的在kgdb和终端之间来回切换，因为经常需要运行程序，停下程序，甚至输入一些参数。而且在实际的过程当中，切换也会有问题。</p><p>官网解释：</p><img src="/debug/kgdb/kgdb_bug.png" class="" title="kgdb"><p>也就是说官网目前已知该问题</p><p>这时我们需要一个工具agent-proxy</p><p>源码地址：<a href="https://git.kernel.org/pub/scm/utils/kernel/kgdb/agent-proxy.git/">https://git.kernel.org/pub/scm/utils/kernel/kgdb/agent-proxy.git/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://git.kernel.org/cgit/utils/kernel/kgdb/agent-proxy.git/<br></code></pre></td></tr></table></figure><p>下载源码后。在源码目录下直接<code>make</code>即可，然后创建软连接到&#x2F;bin目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /media/uos/work_kernel/agent-proxy-1.97/agent-proxy /usr/bin/agent-proxy<br></code></pre></td></tr></table></figure><h4 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h4><p>启动代理，将串口映射成两个本地网络端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">agent-proxy 5550^5551 0 /dev/ttyUSB0,115200<br></code></pre></td></tr></table></figure><p>telnet登录一个端口，充当控制台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet localhost 5550<br></code></pre></td></tr></table></figure><p>gdb连接另一个端口，充当调试通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">target remote localhost:5551<br></code></pre></td></tr></table></figure><h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><p>如果调试某个驱动我们需要打开驱动文件所在rootfs文件夹，使用<code>insmod</code>安装.ko驱动，然后输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cat /sys/module/usbhid/sections/.text<br><br>0xffffffffc014d000<br></code></pre></td></tr></table></figure><p>为什么要获取这个.text信息：</p><p>直接用.ko文件调试，可能无法设置断点，在内核模块的调试中，GDB 需要知道模块代码在内存中的实际位置，以便正确设置断点。如果内核启用了 <code>CONFIG_RANDOMIZE_BASE</code>（即启用地址随机化），模块的加载地址可能会发生变化，通过获取模块的 <code>.text</code> 段的实际地址，调试工具可以根据这些信息来调整断点的位置。</p><p>解决地址随机化问题：</p><p>在内核中启用了地址随机化（KASLR，Kernel Address Space Layout Randomization）时，内核模块的加载地址会被随机化，这使得直接在源代码中设置断点变得困难。获取模块的 <code>.text</code> 段信息有助于了解实际的加载地址，从而在调试时提供正确的断点信息。</p><p>也可以在启动参数添加<code>nokaslr kgdboc=ttyUSB0,115200 kgdbwait</code></p><p>接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo g &gt; /proc/sysrq-trigger<br></code></pre></td></tr></table></figure><p>这个指令是触发kgdb运行的，输入该指令后，内核就会停下，等待远端gdb连接。</p><p>然后在主机打开新的终端，进入驱动源码所在目录，输入如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gdb-multiarch<br>(gdb) set architecture aarch64<br>The target architecture is assumed to be aarch64<br>(gdb) set serial baud 115200<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将这个地址信息告知 GDB，以便它可以正确地设置断点</span><br>(gdb) add-symbol-file /path/to/usbhid.ko 0xffffffffc014d000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">主机通过串口连接到测试机上的kgdb</span><br>(gdb) target remote localhost:5551<br></code></pre></td></tr></table></figure><h4 id="add-symbol-file"><a href="#add-symbol-file" class="headerlink" title="add-symbol-file"></a>add-symbol-file</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) add-symbol-file &#123;filename&#125; &#123;addr&#125;<br></code></pre></td></tr></table></figure><p><code>&#123;filename&#125;</code> 是你要加载的符号文件的路径，通常是一个带有调试符号的可执行文件或库文件。</p><p><code>&#123;addr&#125;</code> 是该符号文件在内存中的基地址（装载地址），告诉 GDB 这个文件的代码段被加载到哪个内存地址上。</p><p><code>add-symbol-file</code> 命令在 GDB 中用于动态加载调试符号文件，并指定该文件的装载地址。它的作用是告诉 GDB 某个特定的二进制文件在内存中的加载位置，以便调试。</p><p>如果你的系统有很多ko，这将是很麻烦的事情，所以我们进行替代使用<code>lx-symbols</code>命令，可以自动查找所有ko文件并加载符号。</p><p>首先执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) add-auto-load-safe-path ./#指定./路径为可信的路径，便于gdb执行启动的python脚本<br>(gdb) file vmlinux#指定符号文件<br>(gdb) source vmlinux-gdb.py#执行./vmlinux-gdb.py添加环境用于kgdb的命令扩展<br>(gdb) target remote localhost:5551<br></code></pre></td></tr></table></figure><h3 id="kgdb扩展命令"><a href="#kgdb扩展命令" class="headerlink" title="kgdb扩展命令"></a>kgdb扩展命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) lx-<br>lx-clk-summary        lx-device-list-class  lx-iomem              lx-ps<br>lx-cmdline            lx-device-list-tree   lx-ioports            lx-symbols<br>lx-configdump         lx-dmesg              lx-list-check         lx-timerlist<br>lx-cpus               lx-fdtdump            lx-lsmod              lx-version<br>lx-device-list-bus    lx-genpd-summary      lx-mounts  <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) apropos lx<br>function lx_clk_core_lookup -- Find struct clk_core by name<br>function lx_current -- Return current task<br>function lx_device_find_by_bus_name -- Find struct device by bus and name (both strings)<br>function lx_device_find_by_class_name -- Find struct device by class and name (both strings)<br>function lx_module -- Find module by name and return the module variable<br>function lx_per_cpu -- Return per-cpu variable<br>function lx_rb_first -- Lookup and return a node from an RBTree<br>function lx_rb_last -- Lookup and return a node from an RBTree<br>function lx_rb_next -- Lookup and return a node from an RBTree<br>function lx_rb_prev -- Lookup and return a node from an RBTree<br>function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable<br>function lx_thread_info -- Calculate Linux thread_info from task variable<br>function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid<br>lx-clk-summary -- Print clk tree summary<br>lx-cmdline --  Report the Linux Commandline used in the current kernel<br>lx-configdump -- Output kernel config to the filename specified as the command<br>lx-cpus -- List CPU status arrays<br>lx-device-list-bus -- Print devices on a bus (or all buses if not specified)<br>lx-device-list-class -- Print devices in a class (or all classes if not specified)<br>lx-device-list-tree -- Print a device and its children recursively<br>lx-dmesg -- Print Linux kernel log buffer<br>lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename<br>lx-genpd-summary -- Print genpd summary<br>lx-iomem -- Identify the IO memory resource locations defined by the kernel<br>lx-ioports -- Identify the IO port resource locations defined by the kernel<br>lx-list-check -- Verify a list consistency<br>lx-lsmod -- List currently loaded modules<br>lx-mounts -- Report the VFS mounts of the current process namespace<br>lx-ps -- Dump Linux tasks<br>lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules<br>lx-timerlist -- Print /proc/timer_list<br>lx-version --  Report the Linux Version of the current kernel<br></code></pre></td></tr></table></figure><p>对于<code>(gdb) lx-symbols</code>时出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Python Exception &lt;class &#x27;gdb.MemoryError&#x27;&gt; Cannot access memory at address<br></code></pre></td></tr></table></figure><p>修改<code>scripts/gdb/linux/symbols.py</code>中<code>_section_arguments</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_section_arguments</span>(<span class="hljs-params">self, module</span>):<br>    <span class="hljs-keyword">try</span>:<br>        sect_attrs = module[<span class="hljs-string">&#x27;sect_attrs&#x27;</span>].dereference()<br>        attrs = sect_attrs[<span class="hljs-string">&#x27;attrs&#x27;</span>]<br>        section_name_to_address = &#123;<br>            attrs[n][<span class="hljs-string">&#x27;battr&#x27;</span>][<span class="hljs-string">&#x27;attr&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>].string(): attrs[n][<span class="hljs-string">&#x27;address&#x27;</span>]<br>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(sect_attrs[<span class="hljs-string">&#x27;nsections&#x27;</span>]))&#125;<br>    <span class="hljs-keyword">except</span> gdb.error:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    args = []<br>    <span class="hljs-keyword">for</span> section_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;.data&quot;</span>, <span class="hljs-string">&quot;.data..read_mostly&quot;</span>, <span class="hljs-string">&quot;.rodata&quot;</span>, <span class="hljs-string">&quot;.bss&quot;</span>,<br>                        <span class="hljs-string">&quot;.text&quot;</span>, <span class="hljs-string">&quot;.text.hot&quot;</span>, <span class="hljs-string">&quot;.text.unlikely&quot;</span>]:<br>        address = section_name_to_address.get(section_name)<br>        <span class="hljs-keyword">if</span> address:<br>            args.append(<span class="hljs-string">&quot; -s &#123;name&#125; &#123;addr&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                name=section_name, addr=<span class="hljs-built_in">str</span>(address)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(args)<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在用gdb来调试内核的时候，由于内核在初始化的时候，会创建很多子线程。而默认gdb会接管所有的线程，如果你从一个线程切换到另外一个线程，gdb会马上把原先的线程暂停。但是这样很容易导致kernel死掉，所以需要设置一下gdb。<br>一般用gdb进行多线程调试，需要注意两个参数：<code>follow-fork-mode</code>和<code>detach-on-fork</code></p><p><code>detach-on-fork</code>：</p><ul><li><code>on</code>：在 <code>fork</code> 之后，GDB 会断开对子进程的调试，仅继续调试父进程。</li><li><code>off</code>：GDB 将继续调试父进程和子进程。需要注意，这可能会导致调试会话变得非常复杂，因为 GDB 会同时控制多个进程。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set detach-on-fork on<br></code></pre></td></tr></table></figure><p><code>follow-fork-mode</code>：</p><ul><li><code>parent</code>：在 <code>fork</code> 之后，GDB 继续调试父进程，而子进程将处于暂停状态。</li><li><code>child</code>：在 <code>fork</code> 之后，GDB 继续调试子进程，而父进程将处于暂停状态。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set follow-fork-mode child<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ftrace</title>
    <link href="/debug/ftrace/"/>
    <url>/debug/ftrace/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是ftrace"><a href="#什么是ftrace" class="headerlink" title="什么是ftrace"></a>什么是ftrace</h3><p>​ftrace是 Linux 内核中一个功能强大的跟踪框架，用于跟踪和分析内核及其模块的执行情况。它提供了一系列工具和功能，帮助开发者调试内核、分析性能瓶颈、查看系统调用、函数调用、上下文切换等信息。</p><p>​<code>ftrace</code> 的主要功能：</p><ol><li><strong>函数跟踪</strong> (<code>function tracing</code>):<ul><li>可以跟踪内核中每个函数的调用情况，包括函数进入、退出的时间和执行时间。</li><li>例如，可以跟踪某个特定函数的调用频率及其调用者。</li></ul></li><li><strong>函数调用图</strong> (<code>function graph tracing</code>):<ul><li>记录函数调用的完整调用栈。与简单的函数跟踪不同，函数调用图会显示函数的调用关系以及调用链中的每个函数的执行时间。</li></ul></li><li><strong>系统调用跟踪</strong>:<ul><li>可以跟踪所有的系统调用或特定的系统调用，从而了解用户空间程序如何与内核交互。</li></ul></li><li><strong>调度器跟踪</strong>:<ul><li><code>ftrace</code> 可以记录和分析调度器行为，比如任务切换、任务调度延迟等，帮助分析多任务系统中的调度性能。</li></ul></li><li><strong>事件跟踪</strong>:<ul><li><code>ftrace</code> 支持各种内核事件的跟踪（例如，IRQ 处理、中断、软中断等），并允许用户定义和过滤感兴趣的事件。</li></ul></li></ol><p>传统的ftrace操作较为繁琐，需要向多个文件写入信息，当前我们紧介绍ftrace前端工具：trace-cmd</p><h3 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h3><ul><li><p>trace-cmd record：记录实时跟踪数据并将其写入trace.dat 文件</p></li><li><p>trace-cmd report：读取 trace.dat 文件并将二进制数据转换为可读的 ASCII 文本格式。</p></li><li><p>trace-cmd start：开始跟踪但不记录到 trace.dat 文件。</p></li><li><p>trace-cmd stop：停止跟踪。</p></li><li><p>trace-cmd extract：从内核缓冲区提取数据并创建 trace.dat 文件。</p></li><li><p>trace-cmd reset：禁用所有跟踪并恢复系统性能。</p></li><li><p>查看可用追踪器</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd list -t<br>hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop<br></code></pre></td></tr></table></figure><ul><li>查看可跟踪的函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~/tom-blog] ➜  sudo trace-cmd list -f | grep mmap<br><br>xen_hvm_exit_mmap<br>xen_dup_mmap<br>xen_exit_mmap<br>ldt_arch_exit_mmap<br>__ia32_compat_sys_ia32_mmap<br>...<br></code></pre></td></tr></table></figure><ul><li>查看可跟踪的事件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~/tom-blog] ➜  sudo trace-cmd list -e | grep snd<br><br>asoc:snd_soc_bias_level_start<br>asoc:snd_soc_bias_level_done<br>asoc:snd_soc_dapm_start<br>asoc:snd_soc_dapm_done<br>...<br></code></pre></td></tr></table></figure><ul><li>查看函数调用栈</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd record -p function -l do_mmap --func-stack<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 ctrl-c 退出trace-cmd时，会在当前目录生成 trace.dat文件,使用report读取trace.dat</span><br>uos@uos-PC [~] ➜  trace-cmd report | head -20<br><br>CPU 0 is empty<br>cpus=16<br>    explorer.exe-14504 [008] 1274475.231218: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231223: kernel_stack:         &lt;stack trace&gt;<br>=&gt; ftrace_trampoline (ffffffffc0d6106a)<br>=&gt; do_mmap (ffffffff94891c45)<br>=&gt; vm_mmap_pgoff (ffffffff94869ee4)<br>=&gt; ksys_mmap_pgoff (ffffffff9488f472)<br>=&gt; do_syscall_64 (ffffffff951e9690)<br>=&gt; entry_SYSCALL_64_after_hwframe (ffffffff952000ea)<br>    explorer.exe-14504 [008] 1274475.231269: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231271: kernel_stack:         &lt;stack trace&gt;<br>=&gt; ftrace_trampoline (ffffffffc0d6106a)<br>=&gt; do_mmap (ffffffff94891c45)<br>=&gt; vm_mmap_pgoff (ffffffff94869ee4)<br>=&gt; ksys_mmap_pgoff (ffffffff9488f472)<br>=&gt; do_syscall_64 (ffffffff951e9690)<br>=&gt; entry_SYSCALL_64_after_hwframe (ffffffff952000ea)<br>    explorer.exe-14504 [008] 1274475.231285: function:             do_mmap<br>    explorer.exe-14504 [008] 1274475.231286: kernel_stack:         &lt;stack trace&gt;<br><br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><p><code>-p</code>：指定当前的 tracer，类似 <code>echo function &gt; current_tracer</code>，可以是支持的 tracer 中的任意一个</p></li><li><p><code>-l</code>：指定跟踪的函数，可以设置多个，类似 <code>echo function_name &gt; set_ftrace_filter</code></p></li><li><p><code>--func-stack</code>：记录被跟踪函数的调用栈</p></li><li><p>-n 指定不跟踪的函数</p><ul><li>比如：<code>trace-cmd record -p function -l &#39;dev*&#39; -n dev_attr_show</code></li><li>设置跟踪所有 dev 开头的函数，但是不跟踪 <code>dev_attr_show</code></li></ul></li><li><p><code>-g</code>：指定 function_graph tracer 跟踪的 函数，类似 <code>echo function_name &gt; set_graph_function</code></p></li><li><p><code>-O</code>：设置 options，比如设置 <code>options/func_stack_trace</code> 可以用 <code>-O func_stack_trace</code>，在 optoin 名称前加上 <code>no</code> 就是将 option 清 0</p></li><li><p><code>-P</code>：设置跟踪的进程</p></li></ul><p>注意，function_graph tracer 同时支持 <code>-l/-g</code> 参数，但是两者是有区别的，他们区别的本质还是 <code>set_ftrace_filter</code> 与 <code>set_graph_function</code> 的区别。</p><ul><li><code>-l</code> 表示被跟踪的函数是叶子函数，不会跟踪其内部的调用子函数。</li><li><code>-g</code> 会跟踪函数内部调用的子函数。</li></ul><p>​默认情况下，<code>trace-cmd</code> 的 <code>function_graph</code> 会记录所有嵌套的函数调用。可以通过设置 <code>--max-graph-depth</code> 来限制跟踪深度。例如要将深度设置为 2，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd record -p function_graph --max-graph-depth 2 -P 1656<br></code></pre></td></tr></table></figure><ul><li>直接跟踪执行命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-cmd record -p function_graph smartctl -i /dev/sg1<br>sudo trace-cmd report<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C调试</title>
    <link href="/debug/I2C%E8%B0%83%E8%AF%95/I2C%E8%B0%83%E8%AF%95/"/>
    <url>/debug/I2C%E8%B0%83%E8%AF%95/I2C%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="I2C调试"><a href="#I2C调试" class="headerlink" title="I2C调试"></a>I2C调试</h2><h3 id="busybox-devmem"><a href="#busybox-devmem" class="headerlink" title="busybox  devmem"></a>busybox  devmem</h3><p>在Linux系统，如果我们想要访问某个寄存器，就需要写一个驱动程序，在驱动中映射寄存器地址，转为虚拟地址后就可以访问。<br>但有时候，我们只是单纯想知道某个寄存器的值，不想这么麻烦，怎么办呢？<br>Linux早就想到这一点了，于是提供了一个工具devmem，通过devmem就可以直接读写寄存器，<br>devmem是一个命令，在shell中输入devmem命令就可以非常方便的读写寄存器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">BusyBox v1.30.1 (Uos 1:1.30.1.5-1+dde) multi-call binary.<br><br>Usage: devmem ADDRESS [WIDTH [VALUE]]<br><br>Read/write from physical address<br><br>        ADDRESS Address to act upon#物理地址<br>        WIDTH   Width (8/16/...)#位宽<br>        VALUE   Data to be written#写入<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo busybox devmem 0x28007000 8     #读取物理地址0x28007000处一个字节的数据<br>0x63<br><br>sudo busybox devmem 0x280070ac 8<br>0x01<br><br>sudo busybox devmem 0x28007000 8 0x63#将0x63写入物理地址0x28007000<br><br>sudo busybox devmem 0x280070ac 8 0x01#将0x01写入物理地址0x280070ac<br></code></pre></td></tr></table></figure><h3 id="i2c-tools"><a href="#i2c-tools" class="headerlink" title="i2c-tools"></a>i2c-tools</h3><p>应用层访问硬件肯定是需要驱动程序的。对于I2C设备，Linux内核已经提供驱动程序**<code>drivers/i2c/i2c-dev.c</code>**，通过它可以直接使用下面的I2C控制器驱动程序来访问I2C设备，而i2c-tools正是基于该驱动开发的一套示例代码，也是一套好用的调试工具。框架如下：</p><img src="/debug/I2C%E8%B0%83%E8%AF%95/I2C%E8%B0%83%E8%AF%95/i2c-tools.png" class="" title="i2c-tools"><p>i2c-tools 包括 ： <strong>i2cdetect</strong>（检测I2C器件工具） 、<strong>i2cdump</strong>（查看寄存器值工具） 、<strong>i2cget</strong>（读取寄存器值工具）、 <strong>i2cset</strong>（设置寄存器值工具）</p><h4 id="i2cdetect"><a href="#i2cdetect" class="headerlink" title="i2cdetect"></a>i2cdetect</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]<br>       i2cdetect -F I2CBUS<br>       i2cdetect -l<br>  I2CBUS is an integer or an I2C bus name<br>  If provided, FIRST and LAST limit the probing range.<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-f强制访问设备</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-y禁用交互模式</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-a扫描总显示所有设备</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">-l列出已知的I2C适配器</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">I2CBUSi2c总线编号</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">FIRST LAST扫描地址范围</span><br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">返回值</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">– ：表示该地址被检测，但没有芯片应答；</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">UU ：表示该地址当前由内核驱动程序使用。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">** ：表示以十六进制表示的设备地址编号，如 “2d”或“4e”。</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cdetect -y  0<br><br>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f<br>00:          -- -- -- -- -- 08 -- -- -- -- -- -- -- <br>10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>30: 30 -- -- -- -- 35 UU UU -- -- -- -- -- -- -- -- <br>40: -- -- -- -- 44 -- -- -- -- -- -- -- -- -- -- -- <br>50: UU -- -- -- -- -- -- 57 -- -- -- -- -- -- -- -- <br>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- <br>70: -- -- -- -- -- -- -- -- <br><br>uos@uos-PC [~] ➜  sudo i2cdetect -l<br><br>i2c-3   i2c             i915 gmbus dpc                          I2C adapter<br>i2c-1   i2c             Synopsys DesignWare I2C adapter         I2C adapter<br>i2c-6   i2c             AUX C/port C                            I2C adapter<br>i2c-4   i2c             i915 gmbus dpb                          I2C adapter<br>i2c-2   i2c             Synopsys DesignWare I2C adapter         I2C adapter<br>i2c-0   smbus           SMBus I801 adapter at efa0              SMBus adapter<br>i2c-7   i2c             AUX D/port D                            I2C adapter<br>i2c-5   i2c             i915 gmbus dpd                          I2C adapter<br><br><br>uos@uos-PC [~] ➜  sudo i2cdetect -F 0<br><br>Functionalities implemented by /dev/i2c-0:<br>I2C                              no<br>SMBus Quick Command              yes<br>SMBus Send Byte                  yes<br>SMBus Receive Byte               yes<br>SMBus Write Byte                 yes<br>SMBus Read Byte                  yes<br>SMBus Write Word                 yes<br>SMBus Read Word                  yes<br>SMBus Process Call               no<br>SMBus Block Write                yes<br>SMBus Block Read                 yes<br>SMBus Block Process Call         yes<br>SMBus PEC                        yes<br>I2C Block Write                  yes<br>I2C Block Read                   yes<br></code></pre></td></tr></table></figure><h4 id="i2cget"><a href="#i2cget" class="headerlink" title="i2cget"></a>i2cget</h4><p>读取指定IIC设备的某个寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cget [-f] [-y] [-a] I2CBUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    b (read byte data, default)<br>    w (read word data)<br>    c (write byte/read byte)<br>    Append p for SMBus PEC<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cget -y 0 0x57 0x00       #读地址0x57设备的0x00处寄存器的值<br>0xff<br></code></pre></td></tr></table></figure><h4 id="i2cset"><a href="#i2cset" class="headerlink" title="i2cset"></a>i2cset</h4><p>写入指定IIC设备的某个寄存器的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cset [-f] [-y] [-m MASK] [-r] [-a] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    c (byte, no value)<br>    b (byte data, default)<br>    w (word data)<br>    i (I2C block data)<br>    s (SMBus block data)<br>    Append p for SMBus PEC<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cset -y 0 0x57 0x00 0x01      #设置地址0x57设备的0x00处寄存器的值为0x01<br></code></pre></td></tr></table></figure><h4 id="i2cdump"><a href="#i2cdump" class="headerlink" title="i2cdump"></a>i2cdump</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: i2cdump [-f] [-y] [-r first-last] [-a] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]<br>  I2CBUS is an integer or an I2C bus name<br>  ADDRESS is an integer (0x03 - 0x77, or 0x00 - 0x7f if -a is given)<br>  MODE is one of:<br>    b (byte, default)<br>    w (word)<br>    W (word on even register addresses)<br>    s (SMBus block)<br>    i (I2C block)<br>    c (consecutive byte)<br>    Append p for SMBus PEC<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  sudo i2cdump -y 0 0x57   #读取总线0  0x57处设备的所有寄存器<br><br>No size specified (using byte-data access)<br>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef<br>00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>10: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>20: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>30: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>40: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>50: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>60: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>70: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>90: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>a0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>b0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>c0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>d0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>e0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br>f0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>i2c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ioctl</title>
    <link href="/ioctl/ioctl/"/>
    <url>/ioctl/ioctl/</url>
    
    <content type="html"><![CDATA[<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>在驱动程序的ioctl函数体中，实现了一个switch-case结构，每一个case对应一个命令码，case内部是驱动程序实现该命令的相关操作。</p><p>ioctl的实现函数要传递给file_operations结构体中对应的函数指针，函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ioctl.h&gt;</span></span><br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file * fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file * fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br></code></pre></td></tr></table></figure><p>unlocked_ioctl在无大内核锁（BKL）的情况下调用。64位用户程序运行在64位的kernel，或32位的用户程序运行在32位的kernel上，都是调用unlocked_ioctl函数。</p><p>compat_ioctl是64位系统提供32位ioctl的兼容方法，也在无大内核锁的情况下调用。即如果是32位的用户程序调用64位的kernel，则会调用compat_ioctl。如果驱动程序没有实现compat_ioctl，则用户程序在执行ioctl时会返回错误Not a typewriter。</p><p>另外，如果32位用户态和64位内核态发生交互时，第三个参数的长度需要保持一致，否则交互协议会出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *fp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> args);<br></code></pre></td></tr></table></figure><p>在2.6.35.7及以前的内核版本中，file_operations还定义了ioctl()接口，与unlocked_ioctl是等价的。但是在2.6.36以后就不再支持这个接口，全部使用unlocked_ioctl了</p><p>以上函数参数的含义如下。<br>1）inode和fp用来确定被操作的设备。<br>2）request就是用户程序下发的命令。<br>3）args就是用户程序在必要时传递的参数。</p><p>返回值：可以在函数体中随意定义返回值，这个返回值也会被直接返回到用户程序中。通常使用非负数表示正确的返回，而返回一个负数系统会判定为ioctl调用失败。</p><p>三、用户与驱动之间的ioctl协议构成<br>也就是request或cmd，本质上就是一个32位数字，理论上可以是任何一个数，但为了保证命令码的唯一性，linux定义了一套严格的规定，通过计算得到这个命令吗数字。linux将32位划分为四段</p><img src="/ioctl/ioctl/ioctl.png" class="" title="ioctl"><ul><li>dir，即direction，表示ioctl命令的访问模式，分为无数据(_IO)、读数据(_IOR)、写数据(_IOW)、读写数据(_IOWR)四种模式。</li><li>type，即device type，表示设备类型，也可翻译成“幻数”或“魔数”，可以是任意一个char型字符，如’a’、‘b’、‘c’等，其主要作用是使ioctl命令具有唯一的设备标识。不过在内核中’w’、‘y’、’z’三个字符已经被使用了。</li><li>nr，即number，命令编号&#x2F;序数，取值范围0~255，在定义了多个ioctl命令的时候，通常从0开始顺次往下编号。</li><li>size，涉及到ioctl的参数arg，占据13bit或14bit，这个与体系有关，arm使用14bit。用来传递arg的数据类型的长度，比如如果arg是int型，我们就将这个参数填入int，系统会检查数据类型和长度的正确性。</li></ul><p>在上面的四个参数都需要用户自己定义，linux系统提供了宏可以使程序员方便的定义ioctl命令码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">include/uapi/<span class="hljs-keyword">asm</span>-generic/ioctl.h<br><span class="hljs-comment">/* used to create numbers */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span><br><br>分别对应了四个dir：<br>_IO(type, nr)：用来定义不带参数的ioctl命令。<br>_IOR(type,nr,size)：用来定义用户程序向驱动程序写参数的ioctl命令。<br>_IOW(type,nr,size)：用来定义用户程序从驱动程序读参数的ioctl命令。<br>_IOWR(type,nr,size)：用来定义带读写参数的驱动命令。<br></code></pre></td></tr></table></figure><p>当然了，系统也定义反向解析ioctl命令的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include/uapi/<span class="hljs-keyword">asm</span>-generic/ioctl.h<br><span class="hljs-comment">/* used to decode ioctl numbers */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_DIR(nr)        (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_TYPE(nr)       (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_NR(nr)     (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IOC_SIZE(nr)       (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ioctl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ioctl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S3 问题根因分析技术文档</title>
    <link href="/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="S3-问题根因分析技术文档"><a href="#S3-问题根因分析技术文档" class="headerlink" title="S3 问题根因分析技术文档"></a>S3 问题根因分析技术文档</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><ul><li>x8610705.10</li><li>联想昭阳k4e-iml 待机自动唤醒</li></ul><p>首先我们看一下日志</p><img src="/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/k4e-iml.png" class="" title="log"><p>我们可以看到在准备Disabling non-boot CPUs 的时候检测到wakeup事件了（wake up pending），abort CPU freeze</p><p>一般这个wakeup事件产生可能是某些设备下电的时候出现异常，或者此时外部设备来了一个中断，打断S3的操作导致S3停止</p><h3 id="S3-待机流程"><a href="#S3-待机流程" class="headerlink" title="S3 待机流程"></a>S3 待机流程</h3><p>我们先来了解一下S3的流程是怎么样的</p><img src="/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/S3%E5%BE%85%E6%9C%BA.png" class="" title="S3待机流程"><p>如上图所示，这是S3待机过程的流程图，简单介绍一下：</p><ul><li>state_store：处理系统进入不同的电源状态</li><li>pm_suspend：suspend入口</li><li>suspend_prepare：suspend前的一些准备工作</li><li>suspend_freeze_processes：冻结用户进程以及内核线程</li><li>suspend_devices_and_enter：开始进行挂起设备</li><li>suspend_enter：关闭设备中断，关闭辅助cpu，检查irq事件，CPU进入suspend</li></ul><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><p>问题是它唤醒了，在知道了S3的流程以后，他在哪里检测唤醒事件呢？pm_wakeup_pending，没错就是这里，我们查看此部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">pm_wakeup_pending</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><br>raw_spin_lock_irqsave(&amp;events_lock, flags);<br><span class="hljs-keyword">if</span> (events_check_enabled) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cnt, inpr;<br><br>split_counters(&amp;cnt, &amp;inpr);<br>ret = (cnt != saved_count || inpr &gt; <span class="hljs-number">0</span>);<br>events_check_enabled = !ret;<br>&#125;<br>raw_spin_unlock_irqrestore(&amp;events_lock, flags);<br><br><span class="hljs-keyword">if</span> (ret) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Wakeup pending, aborting suspend\n&quot;</span>);<br>pm_print_active_wakeup_sources();<br>&#125;<br><br><span class="hljs-keyword">return</span> ret || <span class="hljs-type">atomic_read</span>(&amp;pm_abort_suspend) &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现他在检测到中断事件的时候就会return  false，暂停S3的操作</p><p>具体检测irq函数为pm_system_irq_wakeup</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">pm_system_irq_wakeup</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq_number)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>raw_spin_lock_irqsave(&amp;wakeup_irq_lock, flags);<br><br><span class="hljs-keyword">if</span> (wakeup_irq[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>wakeup_irq[<span class="hljs-number">0</span>] = irq_number;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wakeup_irq[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>wakeup_irq[<span class="hljs-number">1</span>] = irq_number;<br><span class="hljs-keyword">else</span><br>irq_number = <span class="hljs-number">0</span>;<br><br>raw_spin_unlock_irqrestore(&amp;wakeup_irq_lock, flags);<br><br><span class="hljs-keyword">if</span> (irq_number)<br>pm_system_wakeup();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数里面我们可以添加printk打印出中断号，或者可以使用bpftrace工具进行打印，kprobe:pm_system_irq_wakeup</p><img src="/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/k4e-iml1.png" class="" title="int"><p>此时发现中断号为122，接下来通过cat &#x2F;proc&#x2F;interrupts 查看这个中断相应的中断处理程序</p><img src="/pm/S3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/122-irq.png" class="" title="irq"><p>此中断所挂载的相关中断处理程序是aerdrv和pcie-dpc，这2个中断处理程序主要负责处理pcie上面的错误信号的</p><p>通过lspci -tv查看到这个pcie总线上挂载了一张amd的显卡，此时基本可以判断问题出在显卡驱动上面</p><h3 id="AER和DPC"><a href="#AER和DPC" class="headerlink" title="AER和DPC"></a>AER和DPC</h3><ul><li>AER：是一种用于检测和报告PCIe设备中发生的错误的机制。它允许PCIe设备检测到并报告各种类型的错误，如非致命的、可恢复的以及严重的错误。AER在PCIe设备上实现了一组寄存器和相应的错误通知机制，可以通过读取这些寄存器来获取关于错误的信息。使用AER，系统能够更好地监控和处理PCIe设备的错误情况，以提高数据完整性和可靠性。</li><li>DPC：是一种用于处理PCIe链路中错误情况的机制。当PCIe链路上的一个设备发送错误信号时，DPC机制允许系统针对该错误进行处理，以避免错误的传播和影响其他设备。具体而言，DPC机制会隔离出故障设备，从而限制错误的影响范围，确保其他设备继续正常工作。</li></ul><div class="note note-warning">            <p>DPC机制依赖于AER提供的错误信息来进行错误处理</p>          </div><p>由于后期任务较多，该问题当时并未深究amdgpu驱动为何报错，不过知道了中断处理程序上报的错误，最后采用pcie_ports&#x3D;compat进行规避。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">pcie_ports</span>=[<span class="hljs-type">PCIE</span>] <span class="hljs-type">PCIe</span> <span class="hljs-keyword">port</span> services handling:<br>nativeUse native PCIe services (<span class="hljs-type">PME</span>, <span class="hljs-type">AER</span>, <span class="hljs-type">DPC</span>, <span class="hljs-type">PCIe</span> hotplug)<br>even if the platform doesn&#x27;t give the OS permission to<br>use them.  This may cause conflicts if the platform<br>also tries to use these services.<br>dpc-nativeUse native PCIe service for DPC only.  May<br>cause conflicts if firmware uses AER or DPC.<br>compatDisable native PCIe services (<span class="hljs-type">PME</span>, <span class="hljs-type">AER</span>, <span class="hljs-type">DPC</span>, <span class="hljs-type">PCIe</span><br>hotplug).<br></code></pre></td></tr></table></figure><p>compat参数用于禁用原生的 PCIe 服务，包括 PME、AER、DPC 和 PCIe 热插拔功能，忽略该错误进行规避。</p>]]></content>
    
    
    <categories>
      
      <category>Power Management</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
      <tag>Power Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存寻址</title>
    <link href="/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
    <url>/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h3><p>​逻辑地址：用来指定一个操作数或一条指令的地址，段（segment）+偏移量（offset | displacement），偏移量指明了从段开始的地方到实际地址之间的距离</p><p>​线性地址：也称作虚拟地址，32位无符号整数，通常用十六位进制数表示，值的范围从0x00000000~0xffffffff</p><p>​物理地址：内存芯片级内存单元寻址</p><p>​在内存寻址中，我们通常以字节为单位</p><h3 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h3><p>​逻辑地址：段标识符+段内相对地址偏移量</p><p>​<strong>段标识符</strong>是一个16位长的字段，成为<strong>段选择符</strong></p><p>​段寄存器：快速查找段选择符，cs，ss，ds，es，fs，gs，程序可以把同一个段寄存器用于不同的目的，先将其值保存在内存中，用完后再恢复</p><p>​cs：代码段寄存器，指向包含程序指令的段，它含有一个两位的字段，指明CPU当前的特权级（CPL），0内核态，3用户态</p><p>​ss：栈段寄存器，指向包含当前程序栈的段</p><p>​ds：数据段寄存器，指向包含静态数据或全局数据段</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>​每个段由一个8字节的段描述符表示，它描述段的特征。放在全局描述符表（GDT）或局部描述符表（LDT）中。</p><p>​通常只定义一个GDT，而每个进程除了存放在GDT的段以外如果还需创建附加段就可以有自己的LDT。GDT在主存中的地址和大小放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中</p><p>​段描述符字段</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>Base</td><td>段首地址的线性地址</td></tr><tr><td>G</td><td>粒度标志：如果该位清0，则段大小以字节为单位，否则以4096字节的倍数计</td></tr><tr><td>Limit</td><td>存放段中最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化</td></tr><tr><td>S</td><td>系统标志：如果它被清0，则这是一个系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段</td></tr><tr><td>Type</td><td>描述了段的类型特征和它的存取权限（请看表下面的描述）</td></tr><tr><td>DPL</td><td>描述符特权级（Descriptor Privilege Level）字段：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。因此，DPL设为0的段只能当CPL为0时（即在内核态）才是可访问的，而DPL设为3的段对任何CPL值都是可访问的</td></tr><tr><td>P</td><td>Segment-Present标志：等于0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去</td></tr><tr><td>D或B</td><td>称为D或B的标志，取决于是代码段还是数据段。D或B的含义在两种情况下稍微有所区别，但是如果段偏移量的地址是32位长，就基本上把它置为1，如果这个偏移量是16位长，它被清0（更详细的描述参见Intel使用手册）</td></tr><tr><td>AVL标志</td><td>可以由操作系统使用，但是被Linux忽略</td></tr></tbody></table><h3 id="段选择符字段"><a href="#段选择符字段" class="headerlink" title="段选择符字段"></a>段选择符字段</h3><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>指定了放在GDT或LDT中的相应段描述符的入口</td></tr><tr><td>TI</td><td>（Table Indicator）标志，指明段描述符是在GDT中（TI&#x3D;0）或在LDT中（TI&#x3D;1）</td></tr><tr><td>RPL</td><td>请求者特权级：当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td></tr></tbody></table><h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>​逻辑地址—-&gt;线性地址</p><p>​从段选择符的index字段计算段描述符的地址，index字段乘以8（一个段描述符大小），结果与gdtr或ldtr相加</p><p>​逻辑地址偏移量+段描述符地址—&gt;线性地址</p><h3 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h3><p>​分段可以给每一个进程分配不同的线性地址空间</p><p>​分页可以把同一线性地址空间映射到不同的物理空间（Linux多用这个）</p><h3 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h3><p>​分页单元把线性地址转换为物理地址</p><p>​其中一个关键任务，把请求访问的类型和线性地址的访问权限相比较，如果这次内存访问无效，就产生一个缺页异常</p><p>​线性地址被分为以固定长度位单位的组，称为<strong>页</strong>。页内部连续的线性地址被映射到连续的物理地址中</p><p>​分页单元把所有RAM分成固定长度的<strong>页框（page frame）</strong>（有时叫做物理页）。每一个页框包含一个页（page），也就是说一个页框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。页只是一个数据块，可以存放在任何页框或磁盘中。</p><p>​把线性地址映射到物理地址的数据结构称为<strong>页表（page table）</strong>。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化</p><p>​正在使用的页目录的物理地址存放在控制寄存器cr3中。线性地址内的Directory字段决定页目录中的目录项，而目录项指向适当的页表。地址的Table字段依次又决定页表中的表项，而表项含有页所在页框的物理地址。Offset字段决定页框内的相对位置。由于它是12位长，故每一页含有4096字节的数据</p><img src="/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/page.png" class="" title="page"><h3 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h3><p>​四级分页模型</p><ul><li>页全局目录</li><li>页上级目录</li><li>页中级目录</li><li>页表</li></ul><img src="/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/linux_page.png" class="" title="linux_page">]]></content>
    
    
    <categories>
      
      <category>内存寻址</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存寻址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Suspend (kernel 5.10)</title>
    <link href="/pm/Suspend/"/>
    <url>/pm/Suspend/</url>
    
    <content type="html"><![CDATA[<h2 id="Suspend-kernel-5-10"><a href="#Suspend-kernel-5-10" class="headerlink" title="Suspend (kernel 5.10)"></a>Suspend (kernel 5.10)</h2><ul><li><p><a href="#state_sotre">state_store</a></p><ul><li><p><a href="#pm_suspend">pm_suspend</a></p><ul><li><p><a href="#enter_state">enter_state</a></p><ul><li><p><a href="#valid_state">valid_state</a></p></li><li><p><a href="#suspend_prepare">suspend_prepare</a></p></li><li><p><a href="#sleep_state_supported">sleep_state_supported</a></p><ul><li><p><a href="#pm_notifier_call_chain_robust">pm_notifier_call_chain_robust</a></p></li><li><p><a href="#suspend_freeze_processes">suspend_freeze_processes</a></p><ul><li><a href="#freeze_processes">freeze_processes</a></li></ul></li><li><p><a href="#freeze_kernel_threads">freeze_kernel_threads</a></p></li><li><p><a href="#suspend_devices_and_enter">suspend_devices_and_enter</a></p><ul><li><a href="#dpm_suspend_start">dpm_suspend_start</a><ul><li><a href="#dpm_prepare">dpm_prepare</a></li><li><a href="#dpm_suspend">dpm_suspend</a><ul><li><a href="#device_suspend">device_suspend</a></li></ul></li></ul></li><li><a href="#suspend_enter">suspend_enter</a><ul><li><a href="#dpm_suspend_noirq">dpm_supsend_noirq</a><ul><li><a href="#device_wakeup_arm_wake_irqs">device_wakeup_arm_wake_irqs</a></li><li><a href="#suspend_device_irqs">suspend_device_irqs</a><ul><li><a href="#suspend_device_irq">suspend_device_irq</a></li></ul></li><li><a href="#dpm_noirq_suspend_devices">dpm_noirq_suspend_devices</a><ul><li><a href="#device_suspend_noirq">device_suspend_noirq</a></li></ul></li></ul></li><li><a href="#suspend_disable_secondary_cpus">suspend_disable_secondary_cpus</a><ul><li><a href="#freeze_secondary_cpus">freeze_secondary_cpus</a></li></ul></li><li><a href="#arch_suspend_disable_irqs">arch_suspend_disable_irqs</a><ul><li><a href="#local_irq_disable">local_irq_disable</a></li></ul></li><li><a href="#syscore_suspend">syscore_suspend</a></li><li><a href="#suspend_ops-%3Eenter">suspend_ops-&gt;enter</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="state-store"><a href="#state-store" class="headerlink" title="state_store"></a>state_store</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">state_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-keyword">struct</span> kobj_attribute *attr,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br><span class="hljs-type">suspend_state_t</span> state;<br><span class="hljs-type">int</span> error;<br><br>error = pm_autosleep_lock();<span class="hljs-comment">//获取autosleep锁</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br><span class="hljs-keyword">if</span> (pm_autosleep_state() &gt; PM_SUSPEND_ON) &#123;<span class="hljs-comment">//判断当前autosleep状态</span><br>error = -EBUSY;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>    <span class="hljs-comment">/*关于suspend状态如下：</span><br><span class="hljs-comment">    #define PM_SUSPEND_ON((__force suspend_state_t) 0)</span><br><span class="hljs-comment">#define PM_SUSPEND_TO_IDLE((__force suspend_state_t) 1)</span><br><span class="hljs-comment">#define PM_SUSPEND_STANDBY((__force suspend_state_t) 2)</span><br><span class="hljs-comment">#define PM_SUSPEND_MEM((__force suspend_state_t) 3)</span><br><span class="hljs-comment">#define PM_SUSPEND_MINPM_SUSPEND_TO_IDLE</span><br><span class="hljs-comment">#define PM_SUSPEND_MAX((__force suspend_state_t) 4)*/</span><br><br>state = decode_state(buf, n);<span class="hljs-comment">//解析传入的state状态值</span><br><span class="hljs-keyword">if</span> (state &lt; PM_SUSPEND_MAX) &#123;<br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_MEM)<br>state = mem_sleep_current;<br><br>error = pm_suspend(state);<span class="hljs-comment">//S3</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == PM_SUSPEND_MAX) &#123;<br>error = hibernate();<span class="hljs-comment">//S4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>error = -EINVAL;<br>&#125;<br><br> out:<br>pm_autosleep_unlock();<br><span class="hljs-keyword">return</span> error ? error : n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pm-suspend"><a href="#pm-suspend" class="headerlink" title="pm_suspend"></a>pm_suspend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pm_suspend - Externally visible function for suspending the system.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Check if the value of @state represents one of the supported states,</span><br><span class="hljs-comment"> * execute enter_state() and update system suspend statistics.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pm_suspend</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (state &lt;= PM_SUSPEND_ON || state &gt;= PM_SUSPEND_MAX)<span class="hljs-comment">//再次判断state</span><br><span class="hljs-keyword">return</span> -EINVAL;<br><br>pr_info(<span class="hljs-string">&quot;suspend entry (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>error = enter_state(state);<br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.fail++;<br>dpm_save_failed_errno(error);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>suspend_stats.success++;<br>&#125;<br>pr_info(<span class="hljs-string">&quot;suspend exit\n&quot;</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="enter-state"><a href="#enter-state" class="headerlink" title="enter_state"></a>enter_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * enter_state - Do common work needed to enter system sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Make sure that no one else is trying to put the system into a sleep state.</span><br><span class="hljs-comment"> * Fail if that&#x27;s not the case.  Otherwise, prepare for system suspend, make the</span><br><span class="hljs-comment"> * system enter the given sleep state and clean up after wakeup.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enter_state</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;suspend_enter&quot;</span>), state, <span class="hljs-literal">true</span>);<span class="hljs-comment">//记录挂起过程的跟踪信息</span><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM_DEBUG</span><br><span class="hljs-keyword">if</span> (pm_test_level != TEST_NONE &amp;&amp; pm_test_level &lt;= TEST_CPUS) &#123;<br>pr_warn(<span class="hljs-string">&quot;Unsupported test mode for suspend to idle, please choose none/freezer/devices/platform.\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!valid_state(state)) &#123;<span class="hljs-comment">//判断平台是否支持该睡眠状态</span><br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><span class="hljs-keyword">if</span> (!mutex_trylock(&amp;system_transition_mutex))<br><span class="hljs-keyword">return</span> -EBUSY;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE)<br>s2idle_begin();<br><br><span class="hljs-keyword">if</span> (sync_on_suspend_enabled) &#123;<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;sync_filesystems&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>ksys_sync_helper();<span class="hljs-comment">//同步文件系统</span><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;sync_filesystems&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br>pm_pr_dbg(<span class="hljs-string">&quot;Preparing system for sleep (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>pm_suspend_clear_flags();<br>error = suspend_prepare(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Unlock;<br><br><span class="hljs-keyword">if</span> (suspend_test(TEST_FREEZER))<br><span class="hljs-keyword">goto</span> Finish;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;suspend_enter&quot;</span>), state, <span class="hljs-literal">false</span>);<br>pm_pr_dbg(<span class="hljs-string">&quot;Suspending system (%s)\n&quot;</span>, mem_sleep_labels[state]);<br>pm_restrict_gfp_mask();<br>error = suspend_devices_and_enter(state);<span class="hljs-comment">//挂起设备</span><br>pm_restore_gfp_mask();<br><br> Finish:<br>events_check_enabled = <span class="hljs-literal">false</span>;<br>pm_pr_dbg(<span class="hljs-string">&quot;Finishing wakeup.\n&quot;</span>);<br>suspend_finish();<br> Unlock:<br>mutex_unlock(&amp;system_transition_mutex);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="valid-state"><a href="#valid-state" class="headerlink" title="valid_state"></a>valid_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">valid_state</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><span class="hljs-comment">//判断该平台是否支持该状态睡眠</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * PM_SUSPEND_STANDBY and PM_SUSPEND_MEM states need low level</span><br><span class="hljs-comment"> * support and need to be valid to the low level</span><br><span class="hljs-comment"> * implementation, no valid callback implies that none are valid.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> suspend_ops &amp;&amp; suspend_ops-&gt;valid &amp;&amp; suspend_ops-&gt;valid(state);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-prepare"><a href="#suspend-prepare" class="headerlink" title="suspend_prepare"></a>suspend_prepare</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_prepare - Prepare for entering system sleep state.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Common code run for every system sleep state that can be entered (except for</span><br><span class="hljs-comment"> * hibernation).  Run suspend notifiers, allocate the &quot;suspend&quot; console and</span><br><span class="hljs-comment"> * freeze processes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_prepare</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (!sleep_state_supported(state))<span class="hljs-comment">//检查指定的睡眠状态是否受支持</span><br><span class="hljs-keyword">return</span> -EPERM;<br><br>pm_prepare_console();<span class="hljs-comment">//切换控制台，将内核消息重定向到指定的控制台。这样做可以确保在睡眠过程中，内核消息能够正确地输出到指定的控制台,重定向kmsg</span><br><br>error = pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND);<span class="hljs-comment">//运行挂起通知器链。这些通知器允许设备驱动程序和其他子系统在系统挂起之前和之后执行必要的操作</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Restore;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;freeze_processes&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>error = suspend_freeze_processes();<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;freeze_processes&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!error)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>suspend_stats.failed_freeze++;<br>dpm_save_failed_step(SUSPEND_FREEZE);<br>pm_notifier_call_chain(PM_POST_SUSPEND);<br> Restore:<br>pm_restore_console();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sleep-state-supported"><a href="#sleep-state-supported" class="headerlink" title="sleep_state_supported"></a>sleep_state_supported</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">sleep_state_supported</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-keyword">return</span> state == PM_SUSPEND_TO_IDLE || (suspend_ops &amp;&amp; suspend_ops-&gt;enter);<br>    <span class="hljs-comment">// 检查 suspend_ops 结构体和其中的 enter 成员是否存在。如果 suspend_ops 结构体存在且其中的 enter 成员不为 NULL，则返回 true。这表示系统支持进入指定的睡眠状态</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pm-notifier-call-chain-robust"><a href="#pm-notifier-call-chain-robust" class="headerlink" title="pm_notifier_call_chain_robust"></a>pm_notifier_call_chain_robust</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pm_notifier_call_chain_robust</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val_up, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val_down)</span><br>&#123;<span class="hljs-comment">//用于调用睡眠相关的通知链</span><br><span class="hljs-type">int</span> ret;<br>ret = blocking_notifier_call_chain_robust(&amp;pm_chain_head, val_up, val_down, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> notifier_to_errno(ret);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-freeze-processes"><a href="#suspend-freeze-processes" class="headerlink" title="suspend_freeze_processes"></a>suspend_freeze_processes</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_freeze_processes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br>error = freeze_processes();<span class="hljs-comment">//冻结所有用户进程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freeze_processes() automatically thaws every task if freezing</span><br><span class="hljs-comment"> * fails. So we need not do anything extra upon error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br>error = freeze_kernel_threads();<span class="hljs-comment">//冻结内核线程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freeze_kernel_threads() thaws only kernel threads upon freezing</span><br><span class="hljs-comment"> * failure. So we have to thaw the userspace tasks ourselves.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (error)<br>thaw_processes();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="freeze-processes"><a href="#freeze-processes" class="headerlink" title="freeze_processes"></a>freeze_processes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * freeze_processes - Signal user space processes to enter the refrigerator.</span><br><span class="hljs-comment"> * The current thread will not be frozen.  The same process that calls</span><br><span class="hljs-comment"> * freeze_processes must later call thaw_processes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On success, returns 0.  On failure, -errno and system is fully thawed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_processes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>error = __usermodehelper_disable(UMH_FREEZING);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br><span class="hljs-comment">/* Make sure this task doesn&#x27;t get frozen */</span><br>current-&gt;flags |= PF_SUSPEND_TASK;<br><br><span class="hljs-keyword">if</span> (!pm_freezing)<br><span class="hljs-type">atomic_inc</span>(&amp;system_freezing_cnt);<br><br>pm_wakeup_clear(<span class="hljs-number">0</span>);<br>pr_info(<span class="hljs-string">&quot;Freezing user space processes ... &quot;</span>);<br>pm_freezing = <span class="hljs-literal">true</span>;<br>error = try_to_freeze_tasks(<span class="hljs-literal">true</span>);<span class="hljs-comment">//冻结所有用户空间进程</span><br><span class="hljs-keyword">if</span> (!error) &#123;<br>__usermodehelper_set_disable_depth(UMH_DISABLED);<br>pr_cont(<span class="hljs-string">&quot;done.&quot;</span>);<br>&#125;<br>pr_cont(<span class="hljs-string">&quot;\n&quot;</span>);<br>BUG_ON(in_atomic());<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now that the whole userspace is frozen we need to disable</span><br><span class="hljs-comment"> * the OOM killer to disallow any further interference with</span><br><span class="hljs-comment"> * killable tasks. There is no guarantee oom victims will</span><br><span class="hljs-comment"> * ever reach a point they go away we have to wait with a timeout.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!error &amp;&amp; !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))<br>error = -EBUSY;<br><br><span class="hljs-keyword">if</span> (error)<br>thaw_processes();<span class="hljs-comment">//解冻所有进程</span><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="freeze-kernel-threads"><a href="#freeze-kernel-threads" class="headerlink" title="freeze_kernel_threads"></a>freeze_kernel_threads</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * freeze_kernel_threads - Make freezable kernel threads go to the refrigerator.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * On success, returns 0.  On failure, -errno and only the kernel threads are</span><br><span class="hljs-comment"> * thawed, so as to give a chance to the caller to do additional cleanups</span><br><span class="hljs-comment"> * (if any) before thawing the userspace tasks. So, it is the responsibility</span><br><span class="hljs-comment"> * of the caller to thaw the userspace tasks, when the time is right.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_kernel_threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br>pr_info(<span class="hljs-string">&quot;Freezing remaining freezable tasks ... &quot;</span>);<br>pm_nosig_freezing = <span class="hljs-literal">true</span>;<br>error = try_to_freeze_tasks(<span class="hljs-literal">false</span>);<span class="hljs-comment">//冻结内核线程通过true和false来区别冻结用户进程还是内核线程</span><br><span class="hljs-keyword">if</span> (!error)<br>pr_cont(<span class="hljs-string">&quot;done.&quot;</span>);<br>pr_cont(<span class="hljs-string">&quot;\n&quot;</span>);<br>BUG_ON(in_atomic());<br><span class="hljs-keyword">if</span> (error)<br>thaw_kernel_threads();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend-devices-and-enter"><a href="#suspend-devices-and-enter" class="headerlink" title="suspend_devices_and_enter"></a>suspend_devices_and_enter</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_devices_and_enter - Suspend devices and enter system sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">suspend_devices_and_enter</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><span class="hljs-type">bool</span> wakeup = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (!sleep_state_supported(state))<span class="hljs-comment">//判断当前平台是否实现了suspend_ops-&gt;enter</span><br><span class="hljs-keyword">return</span> -ENOSYS;<br><br>pm_suspend_target_state = state;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE)<br>pm_set_suspend_no_platform();<br><br>error = platform_suspend_begin(state);<span class="hljs-comment">//平台挂起</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Close;<br><br>suspend_console();<span class="hljs-comment">//挂起控制台</span><br>suspend_test_start();<br>error = dpm_suspend_start(PMSG_SUSPEND);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;Some devices failed to suspend, or early wake event detected\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Recover_platform;<br>&#125;<br>suspend_test_finish(<span class="hljs-string">&quot;suspend devices&quot;</span>);<br><span class="hljs-keyword">if</span> (suspend_test(TEST_DEVICES))<br><span class="hljs-keyword">goto</span> Recover_platform;<br><br><span class="hljs-keyword">do</span> &#123;<br>error = suspend_enter(state, &amp;wakeup);<br>&#125; <span class="hljs-keyword">while</span> (!error &amp;&amp; !wakeup &amp;&amp; platform_suspend_again(state));<br><br> Resume_devices:<br>suspend_test_start();<br>dpm_resume_end(PMSG_RESUME);<br>suspend_test_finish(<span class="hljs-string">&quot;resume devices&quot;</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;resume_console&quot;</span>), state, <span class="hljs-literal">true</span>);<br>resume_console();<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;resume_console&quot;</span>), state, <span class="hljs-literal">false</span>);<br><br> Close:<br>platform_resume_end(state);<br>pm_suspend_target_state = PM_SUSPEND_ON;<br><span class="hljs-keyword">return</span> error;<br><br> Recover_platform:<br>platform_recover(state);<br><span class="hljs-keyword">goto</span> Resume_devices;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dpm-suspend-start"><a href="#dpm-suspend-start" class="headerlink" title="dpm_suspend_start"></a>dpm_suspend_start</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend_start - Prepare devices for PM transition and suspend them.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Prepare all non-sysdev devices for system PM transition and execute &quot;suspend&quot;</span><br><span class="hljs-comment"> * callbacks for them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend_start</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><span class="hljs-comment">//挂起设备</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error;<br><br>error = dpm_prepare(state);<span class="hljs-comment">//执行所有设备的prepare回调函数</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_prepare++;<br>dpm_save_failed_step(SUSPEND_PREPARE);<br>&#125; <span class="hljs-keyword">else</span><br>error = dpm_suspend(state);<span class="hljs-comment">//执行所有设备的suspend回调函数</span><br>dpm_show_time(starttime, state, error, <span class="hljs-string">&quot;start&quot;</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-prepare"><a href="#dpm-prepare" class="headerlink" title="dpm_prepare"></a>dpm_prepare</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_prepare - Prepare all non-sysdev devices for a system PM transition.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Execute the -&gt;prepare() callback(s) for all devices.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_prepare</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_prepare&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>might_sleep();<span class="hljs-comment">//在可能会导致进程睡眠的上下文中检查睡眠情况</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Give a chance for the known devices to complete their probes, before</span><br><span class="hljs-comment"> * disable probing of devices. This sync point is important at least</span><br><span class="hljs-comment"> * at boot time + hibernation restore.</span><br><span class="hljs-comment"> */</span><br>wait_for_device_probe();<span class="hljs-comment">//等待所有设备的探测完成。在系统启动或从休眠状态恢复时，设备可能正在被探测，这个函数确保在进行电源管理转换之前，所有设备的探测都已完成</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * It is unsafe if probing of devices will happen during suspend or</span><br><span class="hljs-comment"> * hibernation and system behavior will be unpredictable in this case.</span><br><span class="hljs-comment"> * So, let&#x27;s prohibit device&#x27;s probing here and defer their probes</span><br><span class="hljs-comment"> * instead. The normal behavior will be restored in dpm_complete().</span><br><span class="hljs-comment"> */</span><br>device_block_probing();<span class="hljs-comment">//禁止设备探测,在执行系统挂起或休眠操作期间，新的设备探测可能会导致不确定的系统行为，因此需要禁止设备探测。这个函数会暂时禁止设备探测，并推迟设备的探测直到稍后的时间点</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_list.next);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>trace_device_pm_callback_start(dev, <span class="hljs-string">&quot;&quot;</span>, state.event);<br>error = device_prepare(dev, state);<span class="hljs-comment">//准备设备进行电源管理转换。调用设备的 prepare() 回调函数来执行准备工作，以确保设备在进行电源管理转换之前处于正确的状态</span><br>trace_device_pm_callback_end(dev, error);<br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-keyword">if</span> (error == -EAGAIN) &#123;<br>put_device(dev);<br>error = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>pr_info(<span class="hljs-string">&quot;Device %s not prepared for power transition: code %d\n&quot;</span>,<br>dev_name(dev), error);<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dev-&gt;power.is_prepared = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move_tail(&amp;dev-&gt;power.entry, &amp;dpm_prepared_list);<span class="hljs-comment">//用于将准备好的设备移到已准备列表中</span><br>put_device(dev);<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_prepare&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-suspend"><a href="#dpm-suspend" class="headerlink" title="dpm_suspend"></a>dpm_suspend</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend - Execute &quot;suspend&quot; callbacks for all non-sysdev devices.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><span class="hljs-comment">//执行所有非系统设备的 &quot;suspend&quot; 回调函数</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>might_sleep();<br><br>devfreq_suspend();<span class="hljs-comment">//暂时挂起设备频率调节器</span><br>cpufreq_suspend();<span class="hljs-comment">//暂时挂起 CPU 频率调节器</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br>pm_transition = state;<br>async_error = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_prepared_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_prepared_list.prev);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>error = device_suspend(dev);<span class="hljs-comment">//调用设备的挂起回调函数，执行设备的挂起操作</span><br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pm_dev_err(dev, state, <span class="hljs-string">&quot;&quot;</span>, error);<br>dpm_save_failed_dev(dev_name(dev));<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move(&amp;dev-&gt;power.entry, &amp;dpm_suspended_list);<span class="hljs-comment">//将已挂起的设备从准备好的设备列表移到已挂起的设备列表中</span><br>put_device(dev);<br><span class="hljs-keyword">if</span> (async_error)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>async_synchronize_full();<br><span class="hljs-keyword">if</span> (!error)<br>error = async_error;<br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_suspend++;<br>dpm_save_failed_step(SUSPEND_SUSPEND);<br>&#125;<br>dpm_show_time(starttime, state, error, <span class="hljs-literal">NULL</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-suspend"><a href="#device-suspend" class="headerlink" title="device_suspend"></a>device_suspend</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_suspend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dpm_async_fn(dev, async_suspend))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> __device_suspend(dev, pm_transition, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="suspend-enter"><a href="#suspend-enter" class="headerlink" title="suspend_enter"></a>suspend_enter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_enter - Make the system enter the given sleep state.</span><br><span class="hljs-comment"> * @state: System sleep state to enter.</span><br><span class="hljs-comment"> * @wakeup: Returns information that the sleep state should not be re-entered.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function should be called after devices have been suspended.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_enter</span><span class="hljs-params">(<span class="hljs-type">suspend_state_t</span> state, <span class="hljs-type">bool</span> *wakeup)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>error = platform_suspend_prepare(state);<span class="hljs-comment">//调用平台相关的prepare回调函数</span><br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Platform_finish;<br><br>error = dpm_suspend_late(PMSG_SUSPEND);<span class="hljs-comment">//对所有设备执行“suspend late”回调</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;late suspend of devices failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Platform_finish;<br>&#125;<br>error = platform_suspend_prepare_late(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Devices_early_resume;<br><br>error = dpm_suspend_noirq(PMSG_SUSPEND);<span class="hljs-comment">//执行系统挂起过程中的&quot;noirq挂起&quot;回调函数。这些回调函数会在设备驱动程序的中断处理程序被调用之前执行</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>pr_err(<span class="hljs-string">&quot;noirq suspend of devices failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Platform_early_resume;<br>&#125;<br>error = platform_suspend_prepare_noirq(state);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> Platform_wake;<br><br><span class="hljs-keyword">if</span> (suspend_test(TEST_PLATFORM))<br><span class="hljs-keyword">goto</span> Platform_wake;<br><br><span class="hljs-keyword">if</span> (state == PM_SUSPEND_TO_IDLE) &#123;<br>s2idle_loop();<br><span class="hljs-keyword">goto</span> Platform_wake;<br>&#125;<br><br>error = suspend_disable_secondary_cpus();<br><span class="hljs-keyword">if</span> (error || suspend_test(TEST_CPUS))<br><span class="hljs-keyword">goto</span> Enable_cpus;<br><br>arch_suspend_disable_irqs();<span class="hljs-comment">//禁用本地 CPU 上的中断</span><br>BUG_ON(!irqs_disabled());<br><br>system_state = SYSTEM_SUSPEND;<br><br>error = syscore_suspend();<br><span class="hljs-keyword">if</span> (!error) &#123;<br>*wakeup = pm_wakeup_pending();<br><span class="hljs-keyword">if</span> (!(suspend_test(TEST_CORE) || *wakeup)) &#123;<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;machine_suspend&quot;</span>),<br>state, <span class="hljs-literal">true</span>);<br>error = suspend_ops-&gt;enter(state);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;machine_suspend&quot;</span>),<br>state, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*wakeup) &#123;<br>error = -EBUSY;<br>&#125;<br>syscore_resume();<br>&#125;<br><br>system_state = SYSTEM_RUNNING;<br><br>arch_suspend_enable_irqs();<br>BUG_ON(irqs_disabled());<br><br> Enable_cpus:<br>suspend_enable_secondary_cpus();<br><br> Platform_wake:<br>platform_resume_noirq(state);<br>dpm_resume_noirq(PMSG_RESUME);<br><br> Platform_early_resume:<br>platform_resume_early(state);<br><br> Devices_early_resume:<br>dpm_resume_early(PMSG_RESUME);<br><br> Platform_finish:<br>platform_resume_finish(state);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dpm-suspend-noirq"><a href="#dpm-suspend-noirq" class="headerlink" title="dpm_suspend_noirq"></a>dpm_suspend_noirq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dpm_suspend_noirq - Execute &quot;noirq suspend&quot; callbacks for all devices.</span><br><span class="hljs-comment"> * @state: PM transition of the system being carried out.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Prevent device drivers&#x27; interrupt handlers from being called and invoke</span><br><span class="hljs-comment"> * &quot;noirq&quot; suspend callbacks for all non-sysdev devices.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dpm_suspend_noirq</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>cpuidle_pause();<span class="hljs-comment">//暂停CPU空闲状态管理器，以确保CPU不会在挂起过程中进入空闲状态</span><br><br>device_wakeup_arm_wake_irqs();<span class="hljs-comment">//激活设备唤醒的唤醒中断</span><br>suspend_device_irqs();<span class="hljs-comment">//暂停设备的中断处理程序，防止在挂起过程中中断被处理</span><br><br>ret = dpm_noirq_suspend_devices(state);<span class="hljs-comment">//执行所有设备的&quot;noirq挂起&quot;回调函数。这些回调函数是在设备的中断处理程序被禁用后执行的</span><br><span class="hljs-keyword">if</span> (ret)<br>dpm_resume_noirq(resume_event(state));<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-wakeup-arm-wake-irqs"><a href="#device-wakeup-arm-wake-irqs" class="headerlink" title="device_wakeup_arm_wake_irqs"></a>device_wakeup_arm_wake_irqs</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * device_wakeup_arm_wake_irqs(void)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Itereates over the list of device wakeirqs to arm them.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">device_wakeup_arm_wake_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//迭代设备的唤醒中断列表，以启用它们的唤醒状态</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wakeup_source</span> *<span class="hljs-title">ws</span>;</span><br><span class="hljs-type">int</span> srcuidx;<br><br>srcuidx = srcu_read_lock(&amp;wakeup_srcu);<br>list_for_each_entry_rcu_locked(ws, &amp;wakeup_sources, entry)<br>dev_pm_arm_wake_irq(ws-&gt;wakeirq);<br>srcu_read_unlock(&amp;wakeup_srcu, srcuidx);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="suspend-device-irqs"><a href="#suspend-device-irqs" class="headerlink" title="suspend_device_irqs"></a>suspend_device_irqs</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend_device_irqs - disable all currently enabled interrupt lines</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * During system-wide suspend or hibernation device drivers need to be</span><br><span class="hljs-comment"> * prevented from receiving interrupts and this function is provided</span><br><span class="hljs-comment"> * for this purpose.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * So we disable all interrupts and mark them IRQS_SUSPENDED except</span><br><span class="hljs-comment"> * for those which are unused, those which are marked as not</span><br><span class="hljs-comment"> * suspendable via an interrupt request with the flag IRQF_NO_SUSPEND</span><br><span class="hljs-comment"> * set and those which are marked as active wakeup sources.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The active wakeup sources are handled by the flow handler entry</span><br><span class="hljs-comment"> * code which checks for the IRQD_WAKEUP_ARMED flag, suspends the</span><br><span class="hljs-comment"> * interrupt and notifies the pm core about the wakeup.</span><br><span class="hljs-comment"> * 在系统全局挂起或休眠期间，防止设备驱动程序接收中断。在挂起期间，函数将禁用所有中断，并将它们标记为 IRQS_SUSPENDED，除非中断未使用、被标记为不可挂起（通过设置 IRQF_NO_SUSPEND 标志），或者被标记为活动唤醒源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">suspend_device_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//在系统挂起或休眠期间禁用所有当前已启用的中断线</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> *<span class="hljs-title">desc</span>;</span><br><span class="hljs-type">int</span> irq;<br><br>for_each_irq_desc(irq, desc) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">bool</span> sync;<br><br><span class="hljs-keyword">if</span> (irq_settings_is_nested_thread(desc))<br><span class="hljs-keyword">continue</span>;<br>raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<br>sync = suspend_device_irq(desc);<br>raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<br><br><span class="hljs-keyword">if</span> (sync)<br>synchronize_irq(irq);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="suspend-device-irq"><a href="#suspend-device-irq" class="headerlink" title="suspend_device_irq"></a>suspend_device_irq</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">suspend_device_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> chipflags = irq_desc_get_chip(desc)-&gt;flags;<span class="hljs-comment">//获取与中断描述符相关联的中断控制器的标志</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> *<span class="hljs-title">irqd</span> =</span> &amp;desc-&gt;irq_data;<br><br><span class="hljs-keyword">if</span> (!desc-&gt;action || irq_desc_is_chained(desc) ||<br>    desc-&gt;no_suspend_depth)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (irqd_is_wakeup_set(irqd)) &#123;<span class="hljs-comment">//检查中断是否设置为唤醒中断</span><br>irqd_set(irqd, IRQD_WAKEUP_ARMED);<span class="hljs-comment">//设置中断数据结构的 IRQD_WAKEUP_ARMED 标志，表示该中断已被设置为唤醒中断</span><br><br><span class="hljs-keyword">if</span> ((chipflags &amp; IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &amp;&amp;<br>     irqd_irq_disabled(irqd)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupt marked for wakeup is in disabled state.</span><br><span class="hljs-comment"> * Enable interrupt here to unmask/enable in irqchip</span><br><span class="hljs-comment"> * to be able to resume with such interrupts.</span><br><span class="hljs-comment"> */</span><br>__enable_irq(desc);<span class="hljs-comment">//启用该中断，以便在中断控制器中取消屏蔽该中断</span><br>irqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);<span class="hljs-comment">//设置中断数据结构的 IRQD_IRQ_ENABLED_ON_SUSPEND 标志，表示该中断在挂起期间已被启用</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We return true here to force the caller to issue</span><br><span class="hljs-comment"> * synchronize_irq(). We need to make sure that the</span><br><span class="hljs-comment"> * IRQD_WAKEUP_ARMED is visible before we return from</span><br><span class="hljs-comment"> * suspend_device_irqs().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>desc-&gt;istate |= IRQS_SUSPENDED;<span class="hljs-comment">//将中断描述符的 istate 字段的 IRQS_SUSPENDED 标志设置为1，表示该中断已被挂起</span><br>__disable_irq(desc);<span class="hljs-comment">//禁用该中断</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Hardware which has no wakeup source configuration facility</span><br><span class="hljs-comment"> * requires that the non wakeup interrupts are masked at the</span><br><span class="hljs-comment"> * chip level. The chip implementation indicates that with</span><br><span class="hljs-comment"> * IRQCHIP_MASK_ON_SUSPEND.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (chipflags &amp; IRQCHIP_MASK_ON_SUSPEND)<span class="hljs-comment">//检查中断控制器标志是否设置了 IRQCHIP_MASK_ON_SUSPEND 标志，如果设置了，表示硬件没有唤醒源配置功能，需要在芯片级别屏蔽非唤醒中断</span><br>mask_irq(desc);<span class="hljs-comment">//在硬件层面屏蔽非唤醒中断，调用中断控制器芯片中的特定函数来实现这一操作</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="dpm-noirq-suspend-devices"><a href="#dpm-noirq-suspend-devices" class="headerlink" title="dpm_noirq_suspend_devices"></a>dpm_noirq_suspend_devices</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dpm_noirq_suspend_devices</span><span class="hljs-params">(<span class="hljs-type">pm_message_t</span> state)</span><br>&#123;<br><span class="hljs-type">ktime_t</span> starttime = ktime_get();<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend_noirq&quot;</span>), state.event, <span class="hljs-literal">true</span>);<br>mutex_lock(&amp;dpm_list_mtx);<br>pm_transition = state;<br>async_error = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (!list_empty(&amp;dpm_late_early_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> to_device(dpm_late_early_list.prev);<br><br>get_device(dev);<br>mutex_unlock(&amp;dpm_list_mtx);<br><br>error = device_suspend_noirq(dev);<br><br>mutex_lock(&amp;dpm_list_mtx);<br><span class="hljs-keyword">if</span> (error) &#123;<br>pm_dev_err(dev, state, <span class="hljs-string">&quot; noirq&quot;</span>, error);<br>dpm_save_failed_dev(dev_name(dev));<br>put_device(dev);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!list_empty(&amp;dev-&gt;power.entry))<br>list_move(&amp;dev-&gt;power.entry, &amp;dpm_noirq_list);<br>put_device(dev);<br><br><span class="hljs-keyword">if</span> (async_error)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>mutex_unlock(&amp;dpm_list_mtx);<br>async_synchronize_full();<br><span class="hljs-keyword">if</span> (!error)<br>error = async_error;<br><br><span class="hljs-keyword">if</span> (error) &#123;<br>suspend_stats.failed_suspend_noirq++;<br>dpm_save_failed_step(SUSPEND_SUSPEND_NOIRQ);<br>&#125;<br>dpm_show_time(starttime, state, error, <span class="hljs-string">&quot;noirq&quot;</span>);<br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;dpm_suspend_noirq&quot;</span>), state.event, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="device-suspend-noirq"><a href="#device-suspend-noirq" class="headerlink" title="device_suspend_noirq"></a>device_suspend_noirq</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_suspend_noirq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dpm_async_fn(dev, async_suspend_noirq))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> __device_suspend_noirq(dev, pm_transition, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="suspend-disable-secondary-cpus"><a href="#suspend-disable-secondary-cpus" class="headerlink" title="suspend_disable_secondary_cpus"></a>suspend_disable_secondary_cpus</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">suspend_disable_secondary_cpus</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> cpu = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU))<span class="hljs-comment">//如果启用了这个配置选项，将 cpu 的值设置为-1，表示要禁用所有辅助 CPU</span><br>cpu = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">return</span> freeze_secondary_cpus(cpu);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="freeze-secondary-cpus"><a href="#freeze-secondary-cpus" class="headerlink" title="freeze_secondary_cpus"></a>freeze_secondary_cpus</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">freeze_secondary_cpus</span><span class="hljs-params">(<span class="hljs-type">int</span> primary)</span><br>&#123;<br><span class="hljs-type">int</span> cpu, error = <span class="hljs-number">0</span>;<br><br>cpu_maps_update_begin();<br><span class="hljs-keyword">if</span> (primary == <span class="hljs-number">-1</span>) &#123;<br>primary = cpumask_first(cpu_online_mask);<br><span class="hljs-keyword">if</span> (!housekeeping_cpu(primary, HK_FLAG_TIMER))<br>primary = housekeeping_any_cpu(HK_FLAG_TIMER);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (!cpu_online(primary))<br>primary = cpumask_first(cpu_online_mask);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We take down all of the non-boot CPUs in one shot to avoid races</span><br><span class="hljs-comment"> * with the userspace trying to use the CPU hotplug at the same time</span><br><span class="hljs-comment"> */</span><br>cpumask_clear(frozen_cpus);<br><br>pr_info(<span class="hljs-string">&quot;Disabling non-boot CPUs ...\n&quot;</span>);<br>for_each_online_cpu(cpu) &#123;<br><span class="hljs-keyword">if</span> (cpu == primary)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (pm_wakeup_pending()) &#123;<br>pr_info(<span class="hljs-string">&quot;Wakeup pending. Abort CPU freeze\n&quot;</span>);<br>error = -EBUSY;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;CPU_OFF&quot;</span>), cpu, <span class="hljs-literal">true</span>);<br>error = _cpu_down(cpu, <span class="hljs-number">1</span>, CPUHP_OFFLINE);<span class="hljs-comment">//禁用指定的 CPU</span><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;CPU_OFF&quot;</span>), cpu, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!error)<br>cpumask_set_cpu(cpu, frozen_cpus);<br><span class="hljs-keyword">else</span> &#123;<br>pr_err(<span class="hljs-string">&quot;Error taking CPU%d down: %d\n&quot;</span>, cpu, error);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!error)<br>BUG_ON(num_online_cpus() &gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>pr_err(<span class="hljs-string">&quot;Non-boot CPUs are not disabled\n&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Make sure the CPUs won&#x27;t be enabled by someone else. We need to do</span><br><span class="hljs-comment"> * this even in case of failure as all freeze_secondary_cpus() users are</span><br><span class="hljs-comment"> * supposed to do thaw_secondary_cpus() on the failure path.</span><br><span class="hljs-comment"> */</span><br>cpu_hotplug_disabled++;<br><br>cpu_maps_update_done();<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="arch-suspend-disable-irqs"><a href="#arch-suspend-disable-irqs" class="headerlink" title="arch_suspend_disable_irqs"></a>arch_suspend_disable_irqs</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* default implementation */</span><br><span class="hljs-type">void</span> __weak <span class="hljs-title function_">arch_suspend_disable_irqs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>local_irq_disable();<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="local-irq-disable"><a href="#local-irq-disable" class="headerlink" title="local_irq_disable"></a>local_irq_disable</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> local_irq_disable()\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">bool was_disabled = raw_irqs_disabled();\<span class="hljs-comment">//检查中断是否已经被禁用</span></span><br>raw_local_irq_disable();\<span class="hljs-comment">//禁用本地 CPU 上的中断，这是一个底层函数，用于将中断掩码设置为禁用状态</span><br><span class="hljs-keyword">if</span> (!was_disabled)\<br>trace_hardirqs_off();\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="syscore-suspend"><a href="#syscore-suspend" class="headerlink" title="syscore_suspend"></a>syscore_suspend</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * syscore_suspend - Execute all the registered system core suspend callbacks.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is executed with one CPU on-line and disabled interrupts.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">syscore_suspend</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">syscore_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;syscore_suspend&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>pm_pr_dbg(<span class="hljs-string">&quot;Checking wakeup interrupts\n&quot;</span>);<br><br><span class="hljs-comment">/* Return error code if there are any wakeup interrupts pending. */</span><br><span class="hljs-keyword">if</span> (pm_wakeup_pending())<br><span class="hljs-keyword">return</span> -EBUSY;<br><br>WARN_ONCE(!irqs_disabled(),<br><span class="hljs-string">&quot;Interrupts enabled before system core suspend.\n&quot;</span>);<br><br>list_for_each_entry_reverse(ops, &amp;syscore_ops_list, node)<br><span class="hljs-keyword">if</span> (ops-&gt;suspend) &#123;<br>pm_pr_dbg(<span class="hljs-string">&quot;Calling %pS\n&quot;</span>, ops-&gt;suspend);<br>ret = ops-&gt;suspend();<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> err_out;<br>WARN_ONCE(!irqs_disabled(),<br><span class="hljs-string">&quot;Interrupts enabled after %pS\n&quot;</span>, ops-&gt;suspend);<br>&#125;<br><br>trace_suspend_resume(TPS(<span class="hljs-string">&quot;syscore_suspend&quot;</span>), <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err_out:<br>pr_err(<span class="hljs-string">&quot;PM: System core suspend callback %pS failed.\n&quot;</span>, ops-&gt;suspend);<br><br>list_for_each_entry_continue(ops, &amp;syscore_ops_list, node)<br><span class="hljs-keyword">if</span> (ops-&gt;resume)<br>ops-&gt;resume();<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="suspend-ops-enter"><a href="#suspend-ops-enter" class="headerlink" title="suspend_ops-&gt;enter"></a>suspend_ops-&gt;enter</h4><p>执行挂起操作等待唤醒信号</p>]]></content>
    
    
    <categories>
      
      <category>Power Management</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Power Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用脚本</title>
    <link href="/script/README/"/>
    <url>/script/README/</url>
    
    <content type="html"><![CDATA[<h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><p><code>cat_usb_device_power_wakeup.sh</code>查看USB设备是否支持电源唤醒</p>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB</title>
    <link href="/usb/usb/"/>
    <url>/usb/usb/</url>
    
    <content type="html"><![CDATA[<h1 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h1><h2 id="USB-简介"><a href="#USB-简介" class="headerlink" title="USB 简介"></a>USB 简介</h2><h3 id="什么是USB"><a href="#什么是USB" class="headerlink" title="什么是USB"></a>什么是USB</h3><p>USB 全称为 Universal Serial Bus，翻译过来就是通用串行总线。由英特尔与众多电脑公司提出来，用于规范电脑与外部设备的连接与通讯。目前 USB 接口已经得到了大范围的应用，已经是电脑、手机等终端设备的必配接口，甚至取代了大量的其他接口。比如最新的智能手机均采用 USB Typec 取代了传统的 3.5mm 耳机接口，苹果最新的 MacBook 只有 USB Typec 接口，至于其他的 HDMI、网口等均可以通过 USB Typec 扩展坞来扩展。<br>按照大版本划分，USB 目前可以划分为 USB1.0、USB2.0、USB3.0 以及即将到来的 USB4.0。</p><p><strong>USB1.0：</strong>USB 规范于 1995 年第一次发布，由 Inter、IBM、Microsoft 等公司组成的 USB-IF(USB Implement Forum)组织提出。USB-IF 于 1996 年正式发布USB1.0，理论速度为 1.5Mbps。1998 年 USBIF 在 USB1.0 的基础上提出了 USB1.1 规范。</p><p><strong>USB2.0：</strong>USB2.0 依旧由 Inter、IBM、Microsoft 等公司提出并发布，USB2.0 分为两个版本:Full-Speed 和 High-Speed，也就是全速(FS)和高速(HS)。USB2.0 FS 的速度为 12Mbps，USB2.0 HS 速度为 480Mbps。目前大多数单片机以及低端 Cortex-A 芯片配置的都是 USB2.0 接口，比如 STM32 和 ALPHA 开发板所使用的 I.MX6ULL。USB2.0 全面兼容 USB1.0 标准。</p><p><strong>USB3.0：</strong>USB3.0 同样有 Inter 等公司发起的，USB3.0 最大理论传输速度为 5.0Gbps，USB3.0引入了全双工数据传输，USB2.0 的 480Mbps 为半双工。USB3.0 中两根线用于发送数据，另外两根用于接收数据。在 USB3.0 的基础上又提出了 USB3.1、USB3.2 等规范，USB3.1 理论传输速度提升到了 10Gbps，USB3.2 理论传输速度为 20Gbps。为了规范 USB3.0 标准的命名，USBIF 公布了最新的 USB 命名规范，原来的 USB3.0 和 USB3.1 命名将不会采用，所有的 3.0 版本的 USB 都命名为 USB3.2，以前的 USB3.0、USB3.1 和 USB3.2 分别叫做 USB3.2 Gen1、USB3.2 Gen2、USB3.2 Gen 2X2。</p><p><strong>USB4.0：</strong>目前还在标准定制中，目前还没有设备搭载，据说是在 Inter 的雷电接口上改进而来。USB4.0 的速度将提升到了 40Gbps，最高支持 100W 的供电能力，只需要一根线就可以完成数据传输与供电，极大的简化了设备之间的链接线数，期待 USB4.0 设备上市。</p><p>如果按照接口类型划分的话 USB 就要分为很多种了，最常见的就是 USB A 插头和插座，如图 67.1.1.1 所示：</p><img src="/usb/usb/a.png" class="" title="a"><p>使用过JLINK 调试器的朋友应该还见过USB B插头和插座，USB B插头和插座如图67.1.1.2所示：</p><img src="/usb/usb/b.png" class="" title="b"><p>USB 插头在不断的缩小，由此产生了 Mini USB 接口，正点原子的 I.MX6ULL-ALPHA 开发板使用的就是 Mini USB，Mini USB 插头和插座如图 67.1.1.3 所示：</p><img src="/usb/usb/c.png" class="" title="c"><p>比 Mini USB 更小的就是 Micro USB 接口了，以前的智能手机基本都是 Micro USB 接口的，Micro USB 插头和插座如图 67.1.1.4 所示：</p><img src="/usb/usb/d.png" class="" title="d"><p>现在最流行的就是 USB Typec 了，USB Typec 插头和插座如图 67.1.1.5 所示：</p><img src="/usb/usb/e.png" class="" title="e"><h3 id="USB-电气特性"><a href="#USB-电气特性" class="headerlink" title="USB 电气特性"></a>USB 电气特性</h3><p>此我们就以 Mini USB 为例讲解一下 USB 的基本电气属性。Mini USB 线一般都是一头为 USB A 插头，一头为 Mini USB插头。一共有四个触点，也就是 4 根线，这四根线的顺序如图 67.1.2.1 所示：</p><img src="/usb/usb/f.png" class="" title="f"><p>如图 67.1.2.1 所示，USB A 插头从左到右线序依次为 1,2,3,4，第 1 根线为 VBUS，电压为5V，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 GND。USB 采用差分信号来传输数据，因此有 D-和 D+两根差分信号线。大家仔细观察的话会发现 USB A 插头的 1 和 4 这两个触点比较长，2 和 3 这两个触点比较短。1 和 4 分别为 VBUS 和 GND，也就是供电引脚，当插入 USB 的时候会先供电，然后再接通数据线。拔出的时候先断开数据线，然后再断开电源线。<br>大家再观察一下 Mini USB 插头，会发现 Mini USB 插头有 5 个触点，也就是 5 根线，线序从左往右依次是 1-5。第 1 根线为 VCC(5V)，第 2 根线为 D-，第 3 根线为 D+，第 4 根线为 ID，第 5 根线为 GND。可以看出 Mini USB 插头相比 USB A 插头多了一个 ID 线，这个 ID 线用于实现 OTG 功能，通过 ID 线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。<br>USB 是一种支持热插拔的总线接口，使用差分线(D-和 D+)来传输数据，USB 支持两种供电模式：总线供电和自供电，总线供电就是由 USB 接口为外部设备供电，在 USB2.0 下，总线供电最大可以提供 500mA 的电流。</p><h3 id="USB-拓扑结构"><a href="#USB-拓扑结构" class="headerlink" title="USB 拓扑结构"></a>USB 拓扑结构</h3><p>USB 是主从结构的，也就是分为主机和从机两部分，一般主机叫做 Host，从机叫做 Device。主机就是提供 USB A 插座来连接外部的设备，比如电脑作为主机，对外提供 USB A 插座，我们可以通过 USB 线来连接一些 USB 设备，比如声卡、手机等。因此电脑带的 USB A 插座数量就决定了你能外接多少个 USB 设备，如果不够用的话我们可以购买 USB 集线器来扩展电脑的USB 插口，USB 集线器也叫做 USB HUB，USB HUB 如图 67.1.3.1 所示：</p><img src="/usb/usb/g.png" class="" title="g"><p>图 67.1.3.1 是一个一拖四的 USB HUB，也就是将一个 USB 接口扩展为 4 个。主机一般会带几个原生的 USB 主控制器，比如 I.MX6ULL 就有两个原生的 USB 主控制器，因此 I.MX6ULL对外提供两个 USB 接口，这两个接口肯定不够用，正点原子的 ALPHA 开发板上有 4 个 HOST接口，其中一路是 USB1 的 OTG 接口，其他的三路就是 USB2 通过 USB HUB 芯片扩展出来的，稍后我们会讲解其原理图。<br>虽然我们可以对原生的 USB 口数量进行扩展，但是我们不能对原生 USB 口的带宽进行扩展，比如 I.MX6ULL 的两个原生 USB 口都是 USB2.0 的，带宽最大为 480Mbps，因此接到下面的的所有 USB 设备总带宽最大为 480Mbps。</p><p>USB 只能主机与设备之间进行数据通信，USB 主机与主机、设备与设备之间是不能通信的。因此两个正常通信的 USB 接口之间必定有一个主机，一个设备。为此使用了不同的插头和插座来区分主机与设备，比如主机提供 USB A 插座，从机提供 Mini USB、Micro USB 等插座。在一个 USB 系统中，仅有一个 USB 主机，但是可以有多个 USB 设备，包括 USB 功能设备和 USB HUB，最多支持 127 个设备。一个 USB 主控制器支持 128 个地址，地址 0 是默认地址，只有在设备枚举的时候才会使用，地址 0 不会分配给任何一个设备。所以一个 USB 主控制器最多可以分配 127 个地址。整个 USB 的拓扑结构就是一个分层的金字塔形，如图 67.1.3.2 所示(参考自USB2.0 协议中文版.pdf)：</p><img src="/usb/usb/h.png" class="" title="h"><p>图 67.1.3.2 中可以看出从 Root Hub 开始，一共有 7 层，金字塔顶部是 Root Hub，这个是USB 控制器内部的。图中的 Hub 就是连接的 USB 集线器，Func 就是具体的 USB 设备。<br>USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个特定的端点。</p><h3 id="什么是USB-OTG"><a href="#什么是USB-OTG" class="headerlink" title="什么是USB OTG"></a>什么是USB OTG</h3><p>前面我们讲了，USB 分为 HOST(主机)和从机(或 DEVICE)，有些设备可能有时候需要做HOST，有时候又需要做 DEVICE，配两个 USB 口当然可以实现，但是太浪费资源了。如果一个 USB 接口既可以做 HOST 又可以做 DEVICE 那就太好了，使用起来就方便很多。为此，USB OTG 应运而生，OTG 是 On-The-Go 的缩写，支持 USB OTG 功能的 USB 接口既可以做 HOST，也可以做 DEVICE。那么问题来了，一个 USB 接口如何知道应该工作在 HOST 还是 DEVICE呢？这里就引入了 ID 线这个概念，前面讲解 USB 电气属性的时候已经说过了，Mini USB 插头有 5 根线，其中一条就是 ID 线。ID 线的高低电平表示 USB 口工作在 HOST 还是 DEVICE 模式：</p><p><strong>ID&#x3D;1：</strong>OTG 设备工作在从机模式。</p><p><strong>ID&#x3D;0：</strong>OTG 设备工作在主机模式。</p><p>支持 OTG 模式的 USB 接口一般都是那些带有 ID 线的接口，比如 I.MX6ULL-ALPHA 开发板的 USB_OTG 接口就是支持 OTG 模式的，USB_OTG 连接到了I.MX6ULL 的USB1 接口上。如果只有一个 Mini USB 或者 Type-C USB 接口的话如果要使用 OTG 的主机模式，那么就需要一根 OTG 线，Mini USB 的 OTG 线如图 67.1.4.1 所示：</p><img src="/usb/usb/i.png" class="" title="i"><p>Type-C USB OTG 线如图 67.1.4.2 所示：</p><img src="/usb/usb/j.png" class="" title="j"><p>可以看出，不管是 Mini USB OTG 还是 Type-C USB OTG 线，一头都是 USB A 插座，另外一头是 Mini USB 或者 Type-C USB 插头，将 Mini USB 或者 Type-C USB 插头插入机器的 MiniUSB 或 Type-C 接口上，需要连接的 USB 设备插到另一端的 USB A 插座上，比如 U 盘啥的。USB OTG 线会将 ID 线拉低，这样机器就知道自己要做为一个主机，用来连接外部的从机设备(U 盘)。</p><h3 id="OHCI-UHCI-EHCI-XHCI"><a href="#OHCI-UHCI-EHCI-XHCI" class="headerlink" title="OHCI UHCI EHCI XHCI"></a>OHCI UHCI EHCI XHCI</h3><p><strong>OHCI：</strong>全称为 Open Host Controller Interface，这是一种 USB 控制器标准，厂商在设计 USB控制器的时候需要遵循此标准，用于 USB1.1 标准。OHCI 不仅仅用于 USB，也支持一些其他的接口，比如苹果的 Firewire 等，OHCI 由于硬件比较难，所以软件要求就降低了，软件相对来说比较简单。OHCI 主要用于非 X86 的 USB，比如扩展卡、嵌入式 USB 控制器。</p><p><strong>UHCI：</strong>全称是 Universal Host Controller Interface，UHCI 是 Inter 主导的一个用于 USB1.0&#x2F;1.1的标准，与 OHCI 不兼容。与 OHCI 相比 UHCI 硬件要求低，但是软件要求相应就高了，因此硬件成本上就比较低。</p><p><strong>EHCI：</strong>全称是 Enhanced Host Controller Interface，是 Inter 主导的一个用于 USB2.0 的 USB控制器标准。EHCI 仅提供USB2.0 的高速功能，至于全速和低速功能就由 OHCI 或 UHCI 来提供。</p><p><strong>xHCI：</strong>全称是 eXtensible Host Controller Interface，是目前最流行的 USB3.0 控制器标准，在速度、能效和虚拟化等方面比前三个都有较大的提高。xHCI 支持所有速度种类的 USB 设备，xHCI 出现的目的就是为了替换前面三个。</p><h3 id="USB-协议简析"><a href="#USB-协议简析" class="headerlink" title="USB 协议简析"></a>USB 协议简析</h3><h4 id="USB-描述符"><a href="#USB-描述符" class="headerlink" title="USB 描述符"></a>USB 描述符</h4><p>顾名思义，USB 描述符就是用来描述 USB 信息的，描述符就是一串按照一定规则构建的字符串，USB 设备使用描述符来向主机报告自己的相关属性信息，常用的描述符如表 67.3.1.1所示：</p><img src="/usb/usb/k.png" class="" title="k"><p>我们依次来看一下表 67.3.1.1 中这 5 个描述符的含义：</p><h5 id="设备描述符"><a href="#设备描述符" class="headerlink" title="设备描述符"></a>设备描述符</h5><p>设备描述符用于描述 USB 设备的一般信息，USB 设备只有一个设备描述符。设备描述符里面记录了设备的 USB 版本号、设备类型、VID(厂商 ID)、PID(产品 ID)、设备序列号等。设备描述符结构如表 67.3.1.2 所示：</p><img src="/usb/usb/l.png" class="" title="l"><img src="/usb/usb/m.png" class="" title="m"><h5 id="配置描述符"><a href="#配置描述符" class="headerlink" title="配置描述符"></a>配置描述符</h5><p>设备描述符的 bNumConfigurations 域定义了一个 USB 设备的配置描述符数量，一个 USB设备至少有一个配置描述符。配置描述符描述了设备可提供的接口(Interface)数量、配置编号、供电信息等，配置描述符结构如表 67.3.1.3 所示：</p><img src="/usb/usb/n.png" class="" title="n"><h5 id="字符串描述符"><a href="#字符串描述符" class="headerlink" title="字符串描述符"></a>字符串描述符</h5><p>字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都必须为 0，字符串描述符结构如表 67.3.1.4 所示：</p><img src="/usb/usb/o.png" class="" title="o"><p>wLANGID[0]-wLANGID[x] 指明了设备支持的语言，具体含义要查阅文档《USB_LANGIDs.pdf 》</p><p>主机会再次根据自己所需的语言向设备请求字符串描述符，这次会主机会指明要得到的字符串索引值和语言。设备返回 Unicode 编码的字符串描述符，结构如表 67.3.1.5 所示：</p><img src="/usb/usb/p.png" class="" title="p"><h5 id="接口描述符"><a href="#接口描述符" class="headerlink" title="接口描述符"></a>接口描述符</h5><p>配置描述符中指定了该配置下的接口数量，可以提供一个或多个接口，接口描述符用于描述接口属性。接口描述符中一般记录接口编号、接口对应的端点数量、接口所述的类等，接口描述符结构如表 67.3.1.6 所示：</p><img src="/usb/usb/q.png" class="" title="q"><h5 id="端点描述符"><a href="#端点描述符" class="headerlink" title="端点描述符"></a>端点描述符</h5><p>接口描述符定义了其端点数量，端点是设备与主机之间进行数据传输的逻辑接口，除了端点 0 是双向端口，其他的端口都是单向的。端点描述符描述了传输类型、方向、数据包大小、端点号等信息，端点描述符结构如表 67.3.1.7 所示：</p><img src="/usb/usb/r.png" class="" title="r"><img src="/usb/usb/s.png" class="" title="s"><h4 id="USB-数据包类型"><a href="#USB-数据包类型" class="headerlink" title="USB 数据包类型"></a>USB 数据包类型</h4><p>USB 是串行通信，需要一位一位的去传输数据，USB 传输的时候先将原始数据进行打包，所以 USB 中传输的基本单元就是数据包。根据用途的不同，USB 协议定义了 4 种不同的包结构：令牌(Token)包、数据(Data)包、握手(Handshake)包和特殊(Special)包。这四种包通过包标识符 PID 来区分，PID 共有 8 位，USB 协议使用低 4 位 PID3-PID0，另外的高四位 PID7-PID4 是PID3-PID0 的取反，传输顺序是 PID0、PID1、PID2、PID3…PID7。令牌包的 PID1-0 为 01，数据包的 PID1-0 为 11，握手包的 PID1-0 为 10，特殊包的 PID1-0 为 00。每种类型的包又有多种具体的包，如表 67.3.3.1 所示：</p><img src="/usb/usb/t.png" class="" title="t"><p>一个完整的包分为多个域，所有的数据包都是以同步域(SYNC)开始，后面紧跟着包标识符(PID)，最终都以包结束(EOP)信号结束。不同的数据包中间位域不同，一般有包目标地址(ADDR)、包目标端点(ENDP)、数据、帧索引、CRC 等，这个要具体数据包具体分析。接下来简单看一下这些数据包的结构。</p><h5 id="令牌包"><a href="#令牌包" class="headerlink" title="令牌包"></a>令牌包</h5><p>令牌包结构如图 67.3.3.1 所示：</p><img src="/usb/usb/u.png" class="" title="u"><p>图 67.3.3.1 是一个 SETUP 令牌包结构，首先是 SYNC 同步域，包同步域为 00000001，也就是连续 7 个 0，后面跟一个 1，如果是高速设备的话就是 31 个 0 后面跟一个 1。紧跟着是 PID，这里是 SETUP 包，为 0XB4，大家可能会好奇为什么不是 0X2D(00101101)，0XB4 的原因如下：</p><p>①、SETUP 包的 PID3-PID0 为 1101，因此对应的 PID7-PID4 就是 0010。</p><p>②、PID 传输顺序为 PID0、PID1、PID2…PID7，因此按照传输顺序排列的话此处的 PID 就是 10110100&#x3D;0XB4，并不是 0X2D。</p><p>PID 后面跟着地址域(ADDR)和端点域(ENDP)，为目标设备的地址和端点号。CRC5 域是 5位 CRC 值，是 ADDR 和 ENDP 这两个域的校验值。最后就是包结束域(EOP)，标记本数据包结束。其他令牌包的结构和 SETUP 基本类似，只是 SOF 令包中间没有 ADDR 和 ENDP 这两个域，而是只有一个 11 位的帧号域。</p><h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><p>数据包结构如图 67.3.3.2 所示：</p><img src="/usb/usb/v.png" class="" title="v"><p>数据包比较简单，同样的，数据包从 SYNC 同步域开始，然后紧跟着是 PID，这里就是DATA0，PID 值为 0XC3。接下来就是具体的数据，数据完了以后就是 16 位的 CRC 校验值，最后是 EOP。</p><h5 id="握手包"><a href="#握手包" class="headerlink" title="握手包"></a>握手包</h5><p>握手包结构如图 67.3.3.3 所示：</p><img src="/usb/usb/w.png" class="" title="w"><p>图 67.3.3.3 是 ACK 握手包，很简单，首先是 SYNC 同步域，然后就是 ACK 包的 PID，为0X4B，最后就是 EOP。其他的 NAK、STALL、NYET 和 ERR 握手包结构都是一样的，只是其中的 PID 不同而已。</p><h4 id="USB-传输类型"><a href="#USB-传输类型" class="headerlink" title="USB 传输类型"></a>USB 传输类型</h4><p>在端点描述符中 bmAttributes 指定了端点的传输类型，一共有 4 种，本节我们来看一下这四种传输类型的区别。</p><h5 id="控制传输"><a href="#控制传输" class="headerlink" title="控制传输"></a>控制传输</h5><p>控制传输一般用于特定的请求，比如枚举过程就是全部由控制传输来完成的，比如获取描述符、设置地址、设置配置等。控制传输分为三个阶段：建立阶段(SETUP)、数据阶段(DATA)和状态阶段(STATUS)，其中数据阶段是可选的。建立阶段使用 SETUP 令牌包，SETUP 使用DATA0 包。数据阶段是 0 个、1 个或多个输入(IN)&#x2F;输出(OUT)事务，数据阶段的所有输入事务必须是同一个方向的，比如都为 IN 或都为 OUT。数据阶段的第一个数据包必须是 DATA1，每次正确传输以后就在 DATA0 和 DATA1 之间进行切换。数据阶段完成以后就是状态阶段，状态阶段的传输方向要和数据阶段相反，比如数据阶段为 IN 的话状态阶段就要为 OUT，状态阶段使用 DATA1 包。比如一个读控制传输格式如图 67.3.4.1 所示：</p><img src="/usb/usb/x.png" class="" title="x"><h5 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h5><p>同步传输用于周期性、低时延、数据量大的场合，比如音视频传输，这些场合对于时延要求很高，但是不要求数据 100%正确，允许有少量的错误。因此，同步传输没有握手阶段，即使数据传输出错了也不会重传。</p><h5 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h5><p>提起“批量”，我们第一反应就是“多”、“大”等，因此，批量传输就是用于大批量传输大块数据的，这些数据对实时性没有要求，比如 MSD 类设备(存储设备)，U 盘之类的。批量传输分为批量读(输入)和批量写(输出)，如果是批量读的话第一阶段的 IN 令牌包，如果是批量写那么第一阶段就是 OUT 令牌包。</p><p>我们就以批量写为例简单介绍一下批量传输过程：</p><p>①、主机发出 OUT 令牌包，令牌包里面包含了设备地址、端点等信息。</p><p>②、如果 OUT 令牌包正确的话，也就是设备地址和端点号匹配，主机就会向设备发送一个数据(DATA)包，发送完成以后主机进入接收模式，等待设备返回握手包，一切都正确的话设备就会向主机返回一个 ACK 握手信号。</p><p>批量读的过程刚好相反：</p><p>①、主机发出 IN 令牌包，令牌包里面包含了设备地址、端点等信息。发送完成以后主机就进入到数据接收状态，等待设备返回数据。</p><p>②、如果 IN 令牌包正确的话，设备就会将一个 DATA 包放到总线上发送给主机。主机收到这个 DATA 包以后就会向设备发送一个 ACK 握手信号。</p><h5 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h5><p>这里的中断传输并不是我们传统意义上的硬件中断，而是一种保持一定频率的传输，中断传输适用于传输数据量小、具有周期性并且要求响应速度快的数据，比如键盘、鼠标等。中断的端点会在端点描述符中报告自己的查询时间间隔，对于时间要求严格的设备可以采用中断传输。</p><h4 id="USB-枚举"><a href="#USB-枚举" class="headerlink" title="USB 枚举"></a>USB 枚举</h4><p>当 USB 设备与 USB 主机连接以后主机就会对 USB 设备进行枚举，通过枚举来获取设备的描述符信息，主机得到这些信息以后就知道该加载什么样的驱动、如何进行通信等。USB 枚举过程如下：</p><p>①、第一回合，当 USB 主机检测到 USB 设备插入以后主机会发出总线复位信号来复位设备。USB 设备复位完成以后地址为 0，主机向地址 0 的端点 0 发送数据，请求设备的描述符。设备得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。</p><p>②、第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0 的端点 0 发送设置地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0 字节状态数据包，表明设备已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到主机发送的 ACK 包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。</p><p>③、第三回合，主机向新的设备地址端点 0 发送请求设备描述符数据包，这一次主机要获取整个设备描述符，一共是 18 个字节。</p><p>④、和第③步类似，接下来依次获取配置描述符、配置集合、字符串描述符等等。</p><h2 id="USB子系统"><a href="#USB子系统" class="headerlink" title="USB子系统"></a>USB子系统</h2><h3 id="USB子系统框架"><a href="#USB子系统框架" class="headerlink" title="USB子系统框架"></a>USB子系统框架</h3><img src="/usb/usb/usb.png" class="" title="usb"> <ul><li>USB设备驱动：用于和枚举到的USB设备进行绑定，完成特定的功能</li><li>USB Core：用于内核USB总线的初始化及USB相关API，为设备驱动和HCD的交互提供桥梁</li><li>USB主机控制器HCD：完成主机控制器的初始化以及数据的传输，并监测外部设备插入，完成设备枚举</li></ul><h3 id="USB传输类型"><a href="#USB传输类型" class="headerlink" title="USB传输类型"></a>USB传输类型</h3><ul><li>控制传输：控制传输是双向传输，数据量通常比较小，主要指由USB总线驱动程序用来进行查询、配置以及给USB设备发送通用的命令。控制传输典型地用在主计算机和USB外设之间的端点0(Endpoint 0)之间的传输，但是指定供应商的控制传输可能用到其它的端点。比如：USB设备的识别过程。</li><li>批量传输：主要应用在数据大量传输，同时又没有带宽和间隔时间要求的情况下，进行可靠传输。比如：U盘拷贝数据。</li><li>中断传输：中断传输主要用于定时查询设备是否有中断数据要传输，设备的端点模式器的结构决定了它的查询频率，从1到255ms之间。这种传输方式典型的应用在少量的、分散的、不可预测数据的传输，比如，键盘和鼠标就属于这一类型。中断传输是单向的并且对于host来说只有输入的方式。</li><li>实时传输：实时传输提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传输率的即时应用中。比如：USB摄像头。</li></ul><h3 id="USB设备描述符"><a href="#USB设备描述符" class="headerlink" title="USB设备描述符"></a>USB设备描述符</h3><img src="/usb/usb/usb_intf_image.png" class="" title="usb_intf">  <ul><li>一个USB设备描述符中可以有多个配置描述符，即USB设备可以有多种配置；一个配置描述符中可以有多个接口描述符，即USB设备可以支持多种功能（接口）；一个接口描述符中可以有多个端点描述符。</li><li>一设备至少要包含设备描述符、配置描述符和接口描述符，如果USB设备没有端点描述符，则它仅仅用默认管道与主机进行数据传输。</li><li>接口，表示逻辑上的设备，比如USB声卡可以分为接口1-录音设备，接口2-播放设备。</li><li>访问设备时，即访问某个接口，接口表示逻辑设备。</li><li>传输数据时，即读写某个端口，端口是数据通道。</li></ul><h4 id="设备描述符-1"><a href="#设备描述符-1" class="headerlink" title="设备描述符"></a>设备描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_DEVICE: Device descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType; <span class="hljs-comment">//描述符类型 （此处应为0x01，即设备描述符）</span><br><br>    __le16 bcdUSB; <span class="hljs-comment">//usb版本号 200 -&gt; USB2.0</span><br>    __u8  bDeviceClass; <span class="hljs-comment">//设备类 </span><br>    __u8  bDeviceSubClass; <span class="hljs-comment">//设备类子类</span><br>    __u8  bDeviceProtocol; <span class="hljs-comment">//设备协议，以上三点都是USB官方定义</span><br>    __u8  bMaxPacketSize0; <span class="hljs-comment">//端点0最大包大小 （只能为8,16,32,64）</span><br>    __le16 idVendor; <span class="hljs-comment">//厂家id</span><br>    __le16 idProduct; <span class="hljs-comment">//产品id</span><br>    __le16 bcdDevice; <span class="hljs-comment">//设备出厂编号</span><br>    __u8  iManufacturer; <span class="hljs-comment">//描述厂商信息的字符串描述符的索引值</span><br>    __u8  iProduct; <span class="hljs-comment">//描述产品信息的字串描述符的索引值</span><br>    __u8  iSerialNumber; <span class="hljs-comment">//描述设备序列号信息的字串描述符的索引值 </span><br>    __u8  bNumConfigurations; <span class="hljs-comment">//可能的配置描述符的数目</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><p> USB设备描述符位于USB设备结构体usb_device中的成员descriptor中。同样地,配置、接口、端点描述符也是位于USB配置、接口、端点结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_device - kernel&#x27;s representation of a USB device</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> &#123;</span><br><span class="hljs-type">int</span>devnum;                    <span class="hljs-comment">// 设备编号；在USB总线上的地址</span><br><span class="hljs-type">char</span>devpath[<span class="hljs-number">16</span>];              <span class="hljs-comment">// 设备ID字符串，用于消息（例如，/port/...）</span><br>u32route;                    <span class="hljs-comment">// 树拓扑的十六进制字符串，用于xHCI</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_state</span><span class="hljs-title">state</span>;</span>                <span class="hljs-comment">// 设备状态：配置、未连接等</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">speed</span>;</span>                <span class="hljs-comment">// 设备速度：高/全/低（或错误）</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>rx_lanes;              <span class="hljs-comment">// 使用中的接收通道数量，USB 3.2添加了双通道支持</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>tx_lanes;              <span class="hljs-comment">// 使用中的传输通道数量，USB 3.2添加了双通道支持</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_tt</span>*<span class="hljs-title">tt</span>;</span>                    <span class="hljs-comment">// 事务转换器信息；用于低/全速设备、高速集线器</span><br><span class="hljs-type">int</span>ttport;                   <span class="hljs-comment">// 在事务转换器集线器上的设备端口</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> toggle[<span class="hljs-number">2</span>];                   <span class="hljs-comment">// 每个端点一个位，([0] = 输入， [1] = 输出) 端点</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">parent</span>;</span>                <span class="hljs-comment">// 我们的集线器，除非我们是根</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_bus</span> *<span class="hljs-title">bus</span>;</span>                      <span class="hljs-comment">// 我们所属的总线</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> <span class="hljs-title">ep0</span>;</span>             <span class="hljs-comment">// 端点0数据（默认控制管道）</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                        <span class="hljs-comment">// 通用设备接口</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span> <span class="hljs-title">descriptor</span>;</span>  <span class="hljs-comment">// USB设备描述符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_bos</span> *<span class="hljs-title">bos</span>;</span>                 <span class="hljs-comment">// USB设备BOS描述符集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">config</span>;</span>           <span class="hljs-comment">// 设备的所有配置</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_config</span> *<span class="hljs-title">actconfig</span>;</span>        <span class="hljs-comment">// 活动配置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_in</span>[16];</span>      <span class="hljs-comment">// 输入端点数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">ep_out</span>[16];</span>     <span class="hljs-comment">// 输出端点数组</span><br><br><span class="hljs-type">char</span> **rawdescriptors;                    <span class="hljs-comment">// 每个配置的原始描述符</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> bus_mA;                    <span class="hljs-comment">// 总线可用电流</span><br>u8 portnum;                               <span class="hljs-comment">// 父端口号（起始值为1）</span><br>u8 level;                                 <span class="hljs-comment">// USB集线器祖先的数量</span><br>u8 devaddr;                               <span class="hljs-comment">// 设备地址，XHCI：由硬件分配，其他：与devnum相同</span><br><br><span class="hljs-type">unsigned</span> can_submit:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 可以提交URB</span><br><span class="hljs-type">unsigned</span> persist_enabled:<span class="hljs-number">1</span>;               <span class="hljs-comment">// 启用USB_PERSIST</span><br><span class="hljs-type">unsigned</span> reset_in_progress:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 设备正在复位</span><br><span class="hljs-type">unsigned</span> have_langid:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// string_langid是否有效</span><br><span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                    <span class="hljs-comment">// 策略已允许我们使用它</span><br><span class="hljs-type">unsigned</span> authenticated:<span class="hljs-number">1</span>;                 <span class="hljs-comment">// 通过加密认证</span><br><span class="hljs-type">unsigned</span> wusb:<span class="hljs-number">1</span>;                          <span class="hljs-comment">// 设备是无线USB</span><br><span class="hljs-type">unsigned</span> lpm_capable:<span class="hljs-number">1</span>;                   <span class="hljs-comment">// 设备支持LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_capable:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 设备可以执行USB2硬件LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_besl_capable:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 设备可以执行USB2硬件BESL LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB2硬件LPM</span><br><span class="hljs-type">unsigned</span> usb2_hw_lpm_allowed:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 用户空间允许启用USB 2.0 LPM</span><br><span class="hljs-type">unsigned</span> usb3_lpm_u1_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U1 LPM</span><br><span class="hljs-type">unsigned</span> usb3_lpm_u2_enabled:<span class="hljs-number">1</span>;           <span class="hljs-comment">// 启用USB3硬件U2 LPM</span><br><span class="hljs-type">int</span> string_langid;                        <span class="hljs-comment">// 字符串的语言ID</span><br><br><span class="hljs-comment">/* static strings from the device */</span><br><span class="hljs-type">char</span> *product;                            <span class="hljs-comment">// 如果存在，iProduct字符串（静态）</span><br><span class="hljs-type">char</span> *manufacturer;                       <span class="hljs-comment">// 如果存在，iManufacturer字符串（静态）</span><br><span class="hljs-type">char</span> *serial;                             <span class="hljs-comment">// 如果存在，iSerialNumber字符串（静态）</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">filelist</span>;</span>                <span class="hljs-comment">// 此设备打开的usbfs文件</span><br><br><span class="hljs-type">int</span> maxchild;                             <span class="hljs-comment">// 如果是集线器，端口数量</span><br><br>u32 quirks;                               <span class="hljs-comment">// 设备的怪癖</span><br><span class="hljs-type">atomic_t</span> urbnum;                          <span class="hljs-comment">// 提交的URB数量</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> active_duration;            <span class="hljs-comment">// 设备未挂起的总时间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> connect_time;               <span class="hljs-comment">// 设备首次连接时间</span><br><br><span class="hljs-type">unsigned</span> do_remote_wakeup:<span class="hljs-number">1</span>;              <span class="hljs-comment">// 启用远程唤醒</span><br><span class="hljs-type">unsigned</span> reset_resume:<span class="hljs-number">1</span>;                  <span class="hljs-comment">// 需要复位而不是恢复</span><br><span class="hljs-type">unsigned</span> port_is_suspended:<span class="hljs-number">1</span>;             <span class="hljs-comment">// 上游端口被挂起（L2或U3）</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wusb_dev</span> *<span class="hljs-title">wusb_dev</span>;</span>                <span class="hljs-comment">// 如果这是无线USB设备，则链接到设备的WUSB特定数据</span><br><span class="hljs-type">int</span> slot_id;                              <span class="hljs-comment">// xHCI分配的插槽ID</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_removable</span> <span class="hljs-title">removable</span>;</span>      <span class="hljs-comment">// 设备可以从此端口物理移除</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb2_lpm_parameters</span> <span class="hljs-title">l1_params</span>;</span>     <span class="hljs-comment">// USB2 L1 LPM状态的最佳努力服务延迟和L1超时</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u1_params</span>;</span>     <span class="hljs-comment">// USB3 U1 LPM状态的退出延迟和集线器启动的超时</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb3_lpm_parameters</span> <span class="hljs-title">u2_params</span>;</span>     <span class="hljs-comment">// USB3 U2 LPM状态的退出延迟和集线器启动的超时</span><br><span class="hljs-type">unsigned</span> lpm_disable_count;               <span class="hljs-comment">// Ref计数用于usb_disable_lpm()和usb_enable_lpm()跟踪需要禁用USB 3.0链路电源管理的函数数量。该计数应仅由这些函数在持有带宽互斥锁时操作。</span><br><br>u16 hub_delay;                            <span class="hljs-comment">// 缓存值，包括：</span><br>                                          <span class="hljs-comment">// parent-&gt;hub_delay + wHubDelay + tTPTransmissionDelay (40ns)</span><br>                                          <span class="hljs-comment">// 将用作SetIsochDelay请求的wValue。</span><br><span class="hljs-type">unsigned</span> use_generic_driver:<span class="hljs-number">1</span>;            <span class="hljs-comment">// 请求驱动程序核心使用通用驱动程序重新探测。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="配置描述符-1"><a href="#配置描述符-1" class="headerlink" title="配置描述符"></a>配置描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_config_descriptor</span> &#123;</span><br>    __u8  bLength; <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//描述符类型（本结构体中固定为0x02)  </span><br><br>    __le16 wTotalLength; <span class="hljs-comment">//该配置下，信息的总长度（包括配置，接口，端点和设备类及厂商定义的描述符）</span><br>    __u8  bNumInterfaces; <span class="hljs-comment">//接口的个数</span><br>    __u8  bConfigurationValue; <span class="hljs-comment">//Set_Configuration命令所需要的参数值，用来选定此配置</span><br>    __u8  iConfiguration; <span class="hljs-comment">//描述该配置的字符串描述的索引值 </span><br>    __u8  bmAttributes;<span class="hljs-comment">//供电模式的选择  </span><br>    __u8  bMaxPower;<span class="hljs-comment">//设备从总线提取的最大电流</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="接口描述符-1"><a href="#接口描述符-1" class="headerlink" title="接口描述符"></a>接口描述符</h4><p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为“功能”更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> &#123;</span><br>    __u8  bLength;      <span class="hljs-comment">//该结构体大小</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//接口描述符的类型编号(0x04）</span><br><br>    __u8  bInterfaceNumber;  <span class="hljs-comment">//该接口的编号  </span><br>    __u8  bAlternateSetting; <span class="hljs-comment">//备用的接口描述符编号  </span><br>    __u8  bNumEndpoints; <span class="hljs-comment">//该接口使用的端点数，不包括端点0  </span><br>    __u8  bInterfaceClass; <span class="hljs-comment">//接口类</span><br>    __u8  bInterfaceSubClass; <span class="hljs-comment">//子类</span><br>    __u8  bInterfaceProtocol; <span class="hljs-comment">//协议</span><br>    __u8  iInterface;<span class="hljs-comment">//描述此接口的字串描述表的索引值  </span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><p>它位于usb_interface-&gt;cur_altsetting-&gt;desc 这个成员结构体里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct usb_interface - what usb device drivers talk to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface</span> &#123;</span><br><span class="hljs-comment">/* array of alternate settings for this interface,</span><br><span class="hljs-comment"> * stored in no particular order */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">altsetting</span>;</span>              <span class="hljs-comment">// 备用设置的数组，无特定顺序</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">cur_altsetting</span>;</span>          <span class="hljs-comment">// 当前活动的备用设置</span><br><span class="hljs-type">unsigned</span> num_altsetting;                            <span class="hljs-comment">// 定义的备用设置数量</span><br><br><span class="hljs-comment">/* If there is an interface association descriptor then it will list</span><br><span class="hljs-comment"> * the associated interfaces */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_assoc_descriptor</span> *<span class="hljs-title">intf_assoc</span>;</span>  <span class="hljs-comment">// 接口关联描述符</span><br><br><span class="hljs-type">int</span> minor;                                          <span class="hljs-comment">// 分配给此接口的次设备号</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_interface_condition</span> <span class="hljs-title">condition</span>;</span>             <span class="hljs-comment">// 绑定状态</span><br><span class="hljs-type">unsigned</span> sysfs_files_created:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// sysfs属性存在</span><br><span class="hljs-type">unsigned</span> ep_devs_created:<span class="hljs-number">1</span>;                         <span class="hljs-comment">// 端点伪设备存在</span><br><span class="hljs-type">unsigned</span> unregistering:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 注销中</span><br><span class="hljs-type">unsigned</span> needs_remote_wakeup:<span class="hljs-number">1</span>;                     <span class="hljs-comment">// 驱动程序需要远程唤醒</span><br><span class="hljs-type">unsigned</span> needs_altsetting0:<span class="hljs-number">1</span>;                       <span class="hljs-comment">// 切换到备用设置0待处理</span><br><span class="hljs-type">unsigned</span> needs_binding:<span class="hljs-number">1</span>;                           <span class="hljs-comment">// 需要延迟解除绑定/重新绑定</span><br><span class="hljs-type">unsigned</span> resetting_device:<span class="hljs-number">1</span>;                        <span class="hljs-comment">// 复位后需要带宽分配</span><br><span class="hljs-type">unsigned</span> authorized:<span class="hljs-number">1</span>;                              <span class="hljs-comment">// 接口授权</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>                                  <span class="hljs-comment">// 接口特定的设备信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">usb_dev</span>;</span>                             <span class="hljs-comment">// 如果接口绑定到USB主设备号，则指向该设备的sysfs表示</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">reset_ws</span>;</span>                        <span class="hljs-comment">// 用于在原子上下文中复位的工作结构</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* host-side wrapper for one interface setting&#x27;s parsed descriptors */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_interface_descriptor</span> <span class="hljs-title">desc</span>;</span>  <span class="hljs-comment">// 接口描述符</span><br><br><span class="hljs-type">int</span> extralen;                          <span class="hljs-comment">// 额外描述符的长度</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *extra;                  <span class="hljs-comment">// 额外描述符</span><br><br><span class="hljs-comment">/* array of desc.bNumEndpoints endpoints associated with this</span><br><span class="hljs-comment"> * interface setting.  these will be in no particular order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_endpoint</span> *<span class="hljs-title">endpoint</span>;</span>    <span class="hljs-comment">// 该接口设置关联的端点数组，无特定顺序</span><br><br><span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>;                          <span class="hljs-comment">// iInterface字符串，如果存在</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="端点描述符-1"><a href="#端点描述符-1" class="headerlink" title="端点描述符"></a>端点描述符</h4><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。<br>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USB_DT_ENDPOINT: Endpoint descriptor */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> &#123;</span><br>    __u8  bLength;        <span class="hljs-comment">//端点描述符字节数大小（7个字节）</span><br>    __u8  bDescriptorType;<span class="hljs-comment">//端点描述符类型编号（0x05) </span><br><br>    __u8  bEndpointAddress; <span class="hljs-comment">//此描述表所描述的端点的地址、方向 : </span><br>                            <span class="hljs-comment">// bit3~bit0:端点号，bit6~bit4:保留，</span><br>                            <span class="hljs-comment">// bit7:方向，如果是控制端点则忽略，0-输出端点（主机到设备）1-输入端点（设备到主机）</span><br>    __u8  bmAttributes; <span class="hljs-comment">// 端点特性，bit1~bit0 表示传输类型，其他位保留</span><br>                        <span class="hljs-comment">// 00-控制传输  01-实时传输   10-批量传输 11-中断传输</span><br>    __le16 wMaxPacketSize;  <span class="hljs-comment">//端点收、发的最大包大小</span><br>    __u8  bInterval; <span class="hljs-comment">// 中断传输模式中主机查询端点的时间间隔。</span><br>                     <span class="hljs-comment">// 对于实时传输的端点此域必需为1，表示周期为1ms。对于中断传输的端点此域值的范围为1ms到255ms</span><br><br>    <span class="hljs-comment">/* <span class="hljs-doctag">NOTE:</span>  these two are _only_ in audio endpoints. */</span><br>    <span class="hljs-comment">/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */</span><br>    __u8  bRefresh;<br>    __u8  bSynchAddress;<br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="字符串描述符-1"><a href="#字符串描述符-1" class="headerlink" title="字符串描述符"></a>字符串描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_string_descriptor</span> &#123;</span><br>    __u8  bLength;  <span class="hljs-comment">// 此描述表的字节数（bString域的数值N＋2）</span><br>    __u8  bDescriptorType; <span class="hljs-comment">// 字串描述表类型（此处应为0x03）</span><br><br>    __le16 wData[<span class="hljs-number">1</span>];        <span class="hljs-comment">/* UTF-16LE encoded */</span>  <br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><h4 id="人机接口描述符"><a href="#人机接口描述符" class="headerlink" title="人机接口描述符"></a>人机接口描述符</h4><p>USB 设备中有一大类就是 HID 设备，即 Human Interface Devices，人机接口设备。这类设备包括鼠标、键盘等，主要用于人与计算机进行交互。 它是 USB 协议最早支持的一种设备类。 HID 设备可以作为低速、全速、高速设备用。由于 HID 设备要求用户输入能得到及时响应，故其传输方式通常采用中断方式。 在 USB 协议中， HID 设备的定义放置在接口描述符中， USB 的设备描述符和配置描述符中不包含 HID 设备的信息。因此，对于某些特定的 HID 设备，可以定义多个接口，只有其中一个接口为 HID 设备类即可。</p><h4 id="USB描述符类型值"><a href="#USB描述符类型值" class="headerlink" title="USB描述符类型值"></a>USB描述符类型值</h4><table><thead><tr><th>类型</th><th>描述符</th><th>类型值</th></tr></thead><tbody><tr><td>标准描述符</td><td>设备描述符</td><td>0x01</td></tr><tr><td></td><td>配置描述符</td><td>0x02</td></tr><tr><td></td><td>字符串描述符</td><td>0x03</td></tr><tr><td></td><td>接口描述符</td><td>0x04</td></tr><tr><td></td><td>端点描述符</td><td>0x05</td></tr><tr><td>类描述符</td><td>集线器类描述符</td><td>0x29</td></tr><tr><td></td><td>人机接口类描述符</td><td>0x21</td></tr><tr><td>厂商定义的描述符</td><td></td><td>0xff</td></tr></tbody></table><h3 id="USB的数据传输对象"><a href="#USB的数据传输对象" class="headerlink" title="USB的数据传输对象"></a>USB的数据传输对象</h3><p>端点，一个USB设备可以有多个端点，和主机间的数据传输称为到设备端点的数据传输。比如说，对于一个U盘，可以细分为两个端点，把数据写到U盘的端点1、从U盘的端点2读取数据。</p><h2 id="USB总线驱动框架"><a href="#USB总线驱动框架" class="headerlink" title="USB总线驱动框架"></a>USB总线驱动框架</h2><h3 id="USB-Core"><a href="#USB-Core" class="headerlink" title="USB Core"></a>USB Core</h3><p>初始化内核USB总线提供USB相关API，为设备驱动和HCD的交互提供桥梁。</p><blockquote><p>Linux启动阶段，通过<strong>subsys_initcall</strong>会完成USB Core的加载</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">subsys_initcall(usb_init);<br></code></pre></td></tr></table></figure><h4 id="usb-init"><a href="#usb-init" class="headerlink" title="usb_init"></a>usb_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">usb_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> retval;<br><span class="hljs-keyword">if</span> (usb_disabled()) &#123;<br>pr_info(<span class="hljs-string">&quot;%s: USB support disabled\n&quot;</span>, usbcore_name);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>usb_init_pool_max();<br><br>usb_debugfs_init();<span class="hljs-comment">//用于调试USB的虚拟文件系统初始化</span><br><br>usb_acpi_register();<br>retval = bus_register(&amp;usb_bus_type);<span class="hljs-comment">//USB总线的创建</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_register_failed;<br>retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<span class="hljs-comment">//各个子系统往往是相互独立的，因此当总线出现变化之后，需要通知其他总线</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_notifier_failed;<br>retval = usb_major_init();<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> major_init_failed;<br>retval = usb_register(&amp;usbfs_driver);<span class="hljs-comment">//注册usbfs驱动</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> driver_register_failed;<br>retval = usb_devio_init();<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> usb_devio_init_failed;<br>retval = usb_hub_init();<span class="hljs-comment">//初始化一个USB设备集线器，用来检测USB设备的连接和断开。</span><br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> hub_init_failed;<br>retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<span class="hljs-comment">//USB通用设备驱动的注册</span><br><span class="hljs-keyword">if</span> (!retval)<br><span class="hljs-keyword">goto</span> out;<br><br>usb_hub_cleanup();<br>hub_init_failed:<br>usb_devio_cleanup();<br>usb_devio_init_failed:<br>usb_deregister(&amp;usbfs_driver);<br>driver_register_failed:<br>usb_major_cleanup();<br>major_init_failed:<br>bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br>bus_notifier_failed:<br>bus_unregister(&amp;usb_bus_type);<br>bus_register_failed:<br>usb_acpi_unregister();<br>usb_debugfs_cleanup();<br>out:<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册USB总线"><a href="#注册USB总线" class="headerlink" title="注册USB总线"></a>注册USB总线</h4><p>USB是基于总线-驱动-设备模型的框架，其初始化阶段一个重点任务就是完成USB总线的创建。usb_bus_type提供了驱动和设备匹配的匹配函数，后面注册设备和驱动时会调用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = bus_register(&amp;usb_bus_type);<br><span class="hljs-keyword">if</span> (retval) <br>    <span class="hljs-keyword">goto</span> bus_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">usb_bus_type</span> =</span> &#123;<br>.name =<span class="hljs-string">&quot;usb&quot;</span>,<br>.match =usb_device_match,<span class="hljs-comment">//只要总线上出现新的设备，match函数就会尝试为其匹配合适的驱动，每一个设备都要感谢match函数</span><br>.uevent =usb_uevent,<span class="hljs-comment">//用于发送总线相关的总线事件</span><br>.need_parent_lock =<span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用bus_register接口注册USB总线，会创建出两条链表用来分别存放向USB总线注册的设备和驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);<br>klist_init(&amp;priv-&gt;klist_drivers, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h4 id="注册USB接口驱动"><a href="#注册USB接口驱动" class="headerlink" title="注册USB接口驱动"></a>注册USB接口驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB接口驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register(&amp;usbfs_driver);<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> driver_register_failed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usbfs_driver</span> =</span> &#123;<br>    .name =     <span class="hljs-string">&quot;usbfs&quot;</span>,<br>    .probe =    driver_probe,<br>    .disconnect =   driver_disconnect,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="初始化USB-Hub"><a href="#初始化USB-Hub" class="headerlink" title="初始化USB Hub"></a>初始化USB Hub</h4><p>初始化一个USB设备集线器，用来检测USB设备的连接和断开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = usb_hub_init();<br><span class="hljs-keyword">if</span> (retval)<br>    <span class="hljs-keyword">goto</span> hub_init_failed;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_hub_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 在usb总线注册一个hub驱动，该驱动被放在usb总线的驱动链表中。</span><br><span class="hljs-keyword">if</span> (usb_register(&amp;hub_driver) &lt; <span class="hljs-number">0</span>) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;%s: can&#x27;t register hub driver\n&quot;</span>,<br>usbcore_name);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The workqueue needs to be freezable to avoid interfering with</span><br><span class="hljs-comment"> * USB-PERSIST port handover. Otherwise it might see that a full-speed</span><br><span class="hljs-comment"> * device was gone before the EHCI controller had handed its port</span><br><span class="hljs-comment"> * over to the companion full-speed controller.</span><br><span class="hljs-comment"> * 工作队列需要可冻结以避免干扰 USB-PERSIST 端口切换。 </span><br><span class="hljs-comment"> * 否则，在 EHCI 控制器将其端口移交给配套的全速控制器之前，它可能会发现全速设备已消失。</span><br><span class="hljs-comment"> */</span><br>hub_wq = alloc_workqueue(<span class="hljs-string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (hub_wq)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Fall through if kernel_thread failed */</span><br>usb_deregister(&amp;hub_driver);<br>pr_err(<span class="hljs-string">&quot;%s: can&#x27;t allocate workqueue for usb hub\n&quot;</span>, usbcore_name);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">hub_driver</span> =</span> &#123;<br>.name =<span class="hljs-string">&quot;hub&quot;</span>,<br>.probe =hub_probe,<br>.disconnect =hub_disconnect,<br>.suspend =hub_suspend,<br>.resume =hub_resume,<br>.reset_resume =hub_reset_resume,<br>.pre_reset =hub_pre_reset,<br>.post_reset =hub_post_reset,<br>.unlocked_ioctl = hub_ioctl,<br>.id_table =hub_id_table,<br>.supports_autosuspend =<span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="注册USB设备驱动"><a href="#注册USB设备驱动" class="headerlink" title="注册USB设备驱动"></a>注册USB设备驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在usb总线注册USB设备驱动，该驱动被放在usb总线的驱动链表中。</span><br>retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<br><span class="hljs-keyword">if</span> (!retval)<br>    <span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_driver</span> <span class="hljs-title">usb_generic_driver</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;usb&quot;</span>,<br>    .probe = generic_probe,<br>    .disconnect = generic_disconnect,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  CONFIG_PM</span><br>    .suspend = generic_suspend,<br>    .resume = generic_resume,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    .supports_autosuspend = <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="usb-register-和-usb-register-device-driver"><a href="#usb-register-和-usb-register-device-driver" class="headerlink" title="usb_register 和 usb_register_device_driver"></a>usb_register 和 usb_register_device_driver</h3><p>usb_register 注册一个USB接口驱动，一个设备可以有多个接口，一个接口表示一种功能。比如USB声卡设备，有两个接口，一个播放接口，一个录音接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_register(driver) \</span><br><span class="hljs-meta">usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_driver - register a USB interface driver</span><br><span class="hljs-comment"> * @new_driver: USB operations for the interface driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> * @mod_name: module name string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB interface driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached interfaces will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized interfaces.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> if you want your driver to use the USB major number, you must call</span><br><span class="hljs-comment"> * usb_register_dev() to enable that functionality.  This function no longer</span><br><span class="hljs-comment"> * takes care of that.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_driver *new_driver, <span class="hljs-keyword">struct</span> module *owner,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mod_name)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>new_driver-&gt;drvwrap.for_devices = <span class="hljs-number">0</span>;<br>new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;<br>new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb接口“设备”被匹配时，首先会调用usb_probe_interface，然后在该接口中调用driver的probe</span><br>new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;<br>new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;<br>new_driver-&gt;drvwrap.driver.owner = owner;<br>new_driver-&gt;drvwrap.driver.mod_name = mod_name;<br>new_driver-&gt;drvwrap.driver.dev_groups = new_driver-&gt;dev_groups;<br>spin_lock_init(&amp;new_driver-&gt;dynids.lock);<br>INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="hljs-built_in">list</span>);<br><br>retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><br>retval = usb_create_newid_files(new_driver);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out_newid;<br><br>pr_info(<span class="hljs-string">&quot;%s: registered new interface driver %s\n&quot;</span>,<br>usbcore_name, new_driver-&gt;name);<br><br>out:<br><span class="hljs-keyword">return</span> retval;<br><br>out_newid:<br>driver_unregister(&amp;new_driver-&gt;drvwrap.driver);<br><br>pr_err(<span class="hljs-string">&quot;%s: error %d registering interface driver %s\n&quot;</span>,<br>usbcore_name, retval, new_driver-&gt;name);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_driver);<br></code></pre></td></tr></table></figure><p>usb_register_device_driver 注册一个通用USB设备驱动，而不是USB接口驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * usb_register_device_driver - register a USB device (not interface) driver</span><br><span class="hljs-comment"> * @new_udriver: USB operations for the device driver</span><br><span class="hljs-comment"> * @owner: module owner of this driver.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Registers a USB device driver with the USB core.  The list of</span><br><span class="hljs-comment"> * unattached devices will be rescanned whenever a new driver is</span><br><span class="hljs-comment"> * added, allowing the new driver to attach to any recognized devices.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: A negative error code on failure and 0 on success.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">usb_register_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> usb_device_driver *new_udriver,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> module *owner)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>new_udriver-&gt;drvwrap.for_devices = <span class="hljs-number">1</span>;<br>new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;<br>new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;<br>    <span class="hljs-comment">// 对应的usb设备被匹配时，首先会调用usb_probe_device，然后在该接口中调用driver的probe</span><br>new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;<br>new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;<br>new_udriver-&gt;drvwrap.driver.owner = owner;<br>new_udriver-&gt;drvwrap.driver.dev_groups = new_udriver-&gt;dev_groups;<br><br>retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);<br><br><span class="hljs-keyword">if</span> (!retval) &#123;<br>pr_info(<span class="hljs-string">&quot;%s: registered new device driver %s\n&quot;</span>,<br>usbcore_name, new_udriver-&gt;name);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check whether any device could be better served with</span><br><span class="hljs-comment"> * this new driver</span><br><span class="hljs-comment"> */</span><br>bus_for_each_dev(&amp;usb_bus_type, <span class="hljs-literal">NULL</span>, new_udriver,<br> __usb_bus_reprobe_drivers);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pr_err(<span class="hljs-string">&quot;%s: error %d registering device driver %s\n&quot;</span>,<br>usbcore_name, retval, new_udriver-&gt;name);<br>&#125;<br><br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>EXPORT_SYMBOL_GPL(usb_register_device_driver);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>USB core注册了一个USB总线，并向USB总线中注册了三个驱动，分别是USB接口驱动、HUB驱动、USB设备驱动。其中在注册HUB驱动前创建了一个hub_thread线程，用来处理hub上USB设备事件，比如插入和拔出；在HUB驱动的probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件。</p><h2 id="USB主机控制器驱动（HCD）"><a href="#USB主机控制器驱动（HCD）" class="headerlink" title="USB主机控制器驱动（HCD）"></a>USB主机控制器驱动（HCD）</h2><p>USB HCD注册在平台总线上。用来处理主机控制器的初始化以及数据的传输，并监测外部设备插入、拔出，完成设备枚举。</p><h3 id="USB主机控制器-设备"><a href="#USB主机控制器-设备" class="headerlink" title="USB主机控制器-设备"></a>USB主机控制器-设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//5.10/arch/arm/mach-s3c/mach-smdk2440.c</span><br>MACHINE_START(S3C2440, <span class="hljs-string">&quot;SMDK2440&quot;</span>)<br><span class="hljs-comment">/* Maintainer: Ben Dooks &lt;ben-linux@fluff.org&gt; */</span><br>.atag_offset= <span class="hljs-number">0x100</span>,<br><br>.init_irq= s3c2440_init_irq,<br>.map_io= smdk2440_map_io,<br>.init_machine= smdk2440_machine_init,<br>.init_time= smdk2440_init_time,<br>MACHINE_END<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init smdk2440_machine_init(<span class="hljs-type">void</span>)<br>&#123;<br>s3c24xx_fb_set_platdata(&amp;smdk2440_fb_info);<br>s3c_i2c0_set_platdata(<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">/* Configure the I2S pins (GPE0...GPE4) in correct mode */</span><br>s3c_gpio_cfgall_range(S3C2410_GPE(<span class="hljs-number">0</span>), <span class="hljs-number">5</span>, S3C_GPIO_SFN(<span class="hljs-number">2</span>),<br>      S3C_GPIO_PULL_NONE);<br>platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));<br>smdk_machine_init();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">smdk2440_devices</span>[] __<span class="hljs-title">initdata</span> =</span> &#123;<br>&amp;s3c_device_ohci,<br>&amp;s3c_device_lcd,<br>&amp;s3c_device_wdt,<br>&amp;s3c_device_i2c0,<br>&amp;s3c_device_iis,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.id= <span class="hljs-number">-1</span>,<br>.num_resources= ARRAY_SIZE(s3c_usb_resource),<br>.resource= s3c_usb_resource,<br>.dev= &#123;<br>.dma_mask= &amp;samsung_device_dma_mask,<br>.coherent_dma_mask= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器-驱动"><a href="#USB主机控制器-驱动" class="headerlink" title="USB主机控制器-驱动"></a>USB主机控制器-驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// linux-2.6.22.6/drivers/usb/host/ohci-hcd.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_S3C2410</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ohci-s3c2410.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLATFORM_DRIVER     ohci_hcd_s3c2410_driver</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ohci_hcd_mod_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (usb_disabled())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>printk(KERN_INFO <span class="hljs-string">&quot;%s: &quot;</span> DRIVER_DESC <span class="hljs-string">&quot;\n&quot;</span>, hcd_name);<br>pr_debug (<span class="hljs-string">&quot;%s: block sizes: ed %zd td %zd\n&quot;</span>, hcd_name,<br><span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> ed), <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> td));<br>set_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br><br>ohci_debug_root = debugfs_create_dir(<span class="hljs-string">&quot;ohci&quot;</span>, usb_debug_root);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>retval = ps3_ohci_driver_register(&amp;PS3_SYSTEM_BUS_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_ps3;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>retval = platform_driver_register(&amp;OF_PLATFORM_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_of_platform;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>retval = sa1111_driver_register(&amp;SA1111_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_sa1111;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>retval = platform_driver_register(&amp;SM501_OHCI_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_sm501;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>retval = platform_driver_register(&amp;TMIO_OHCI_DRIVER);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error_tmio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> retval;<br><br><span class="hljs-comment">/* Error path */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> TMIO_OHCI_DRIVER</span><br>platform_driver_unregister(&amp;TMIO_OHCI_DRIVER);<br> error_tmio:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SM501_OHCI_DRIVER</span><br>platform_driver_unregister(&amp;SM501_OHCI_DRIVER);<br> error_sm501:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SA1111_DRIVER</span><br>sa1111_driver_unregister(&amp;SA1111_DRIVER);<br> error_sa1111:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OF_PLATFORM_DRIVER</span><br>platform_driver_unregister(&amp;OF_PLATFORM_DRIVER);<br> error_of_platform:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PS3_SYSTEM_BUS_DRIVER</span><br>ps3_ohci_driver_unregister(&amp;PS3_SYSTEM_BUS_DRIVER);<br> error_ps3:<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>debugfs_remove(ohci_debug_root);<br>ohci_debug_root = <span class="hljs-literal">NULL</span>;<br><br>clear_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>module_init(ohci_hcd_mod_init);<br><br><span class="hljs-comment">// drivers/usb/host/ohci-s3c2410.c</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>.probe= ohci_hcd_s3c2410_probe,<br>.remove= ohci_hcd_s3c2410_remove,<br>.shutdown= usb_hcd_platform_shutdown,<br>.driver= &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.pm= &amp;ohci_hcd_s3c2410_pm_ops,<br>.of_match_table= ohci_hcd_s3c2410_dt_ids,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器设备和驱动的匹配"><a href="#USB主机控制器设备和驱动的匹配" class="headerlink" title="USB主机控制器设备和驱动的匹配"></a>USB主机控制器设备和驱动的匹配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_driver_register-&gt;<br>    driver_register-&gt;<br>        bus_add_driver-&gt;<br>            driver_attach-&gt;<br>                bus_for_each_dev-&gt; <span class="hljs-comment">// 从平台总线的的设备链表中，取出每一项设备进行匹配</span><br>                    __driver_attach-&gt;<br>                        driver_probe_device-&gt;<br>                            <span class="hljs-comment">// 此总线类型为平台总线，其存在match函数，即调用platform_match进行匹配</span><br>                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))                            <br><br><span class="hljs-comment">// 平台总线                            </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">platform_bus_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;platform&quot;</span>,<br>.dev_groups= platform_dev_groups,<br>.match= platform_match,<br>.uevent= platform_uevent,<br>.dma_configure= platform_dma_configure,<br>.pm= &amp;platform_dev_pm_ops,<br>&#125;;<br>EXPORT_SYMBOL_GPL(platform_bus_type);             <br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> *<span class="hljs-title">pdrv</span> =</span> to_platform_driver(drv);<br><br><span class="hljs-comment">/* When driver_override is set, only bind to the matching driver */</span><br><span class="hljs-keyword">if</span> (pdev-&gt;driver_override)<br><span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);<br><br><span class="hljs-comment">/* Attempt an OF style match first */</span><br><span class="hljs-keyword">if</span> (of_driver_match_device(dev, drv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* Then try ACPI style match */</span><br><span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* Then try to match against the id table */</span><br><span class="hljs-keyword">if</span> (pdrv-&gt;id_table)<br><span class="hljs-keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* fall-back to driver name match */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// ohci 设备   name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">s3c_device_ohci</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.id= <span class="hljs-number">-1</span>,<br>.num_resources= ARRAY_SIZE(s3c_usb_resource),<br>.resource= s3c_usb_resource,<br>.dev= &#123;<br>.dma_mask= &amp;samsung_device_dma_mask,<br>.coherent_dma_mask= DMA_BIT_MASK(<span class="hljs-number">32</span>),<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// ohci 驱动 name = &quot;s3c2410-ohci&quot;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">ohci_hcd_s3c2410_driver</span> =</span> &#123;<br>.probe= ohci_hcd_s3c2410_probe,<br>.remove= ohci_hcd_s3c2410_remove,<br>.shutdown= usb_hcd_platform_shutdown,<br>.driver= &#123;<br>.name= <span class="hljs-string">&quot;s3c2410-ohci&quot;</span>,<br>.pm= &amp;ohci_hcd_s3c2410_pm_ops,<br>.of_match_table= ohci_hcd_s3c2410_dt_ids,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>匹配成功调用驱动的probe函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>    really_probe-&gt;<br>        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure><h3 id="USB主机控制器驱动的probe函数"><a href="#USB主机控制器驱动的probe函数" class="headerlink" title="USB主机控制器驱动的probe函数"></a>USB主机控制器驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ohci_hcd_s3c2410_drv_probe -&gt; <br>    usb_hcd_s3c2410_probe -&gt;<br>        usb_add_hcd -&gt; <br>            rhdev = usb_alloc_dev<br>            hcd-&gt;self.root_hub = rhdev<br>            register_root_hub -&gt; <br>                usb_new_device -&gt;<br>                    device_add -&gt;     <br>                        bus_attach_device -&gt;<br>                            device_attach -&gt; <br>                                bus_for_each_drv -&gt; <span class="hljs-comment">// 从usb总线的的驱动链表中，取出每一项驱动进行匹配</span><br>                                    __device_attach -&gt;<br>                                        driver_probe_device -&gt;<br>                                            <span class="hljs-comment">// 此总线类型为USB总线，其存在match函数，即调用usb_device_match进行匹配</span><br>                                            <span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv)) <br>                                                driver_probe_device-&gt; <span class="hljs-comment">// 在此函数中匹配成功的话，就会去调用驱动的probe函数</span><br>                                                    really_probe-&gt;<br>                                                        drv-&gt;probe(dev)<br></code></pre></td></tr></table></figure><h3 id="usb-device-match"><a href="#usb-device-match" class="headerlink" title="usb_device_match"></a>usb_device_match</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> dev-&gt;type == &amp;usb_device_type;<br>&#125;<br><br><span class="hljs-comment">/* Do the same for device drivers and interface drivers. */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_usb_device_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// struct device_driver 中 struct usbdrv_wrap 中的for_devices变量为1，则为USB设备驱动</span><br>    <span class="hljs-comment">// 上节USB Core中向USB总线注册的USB设备驱动中有将该变量设置为1（new_udriver-&gt;drvwrap.for_devices = 1;）</span><br>    <span class="hljs-keyword">return</span> container_of(drv, <span class="hljs-keyword">struct</span> usbdrv_wrap, driver)-&gt;<br>            for_devices;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_device_match</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)</span><br>&#123;<br>    <span class="hljs-comment">// USB设备 和 USB接口“设备”分开处理 </span><br>    <span class="hljs-comment">/* devices and interfaces are handled separately */</span><br>    <span class="hljs-keyword">if</span> (is_usb_device(dev)) &#123;<br>        <span class="hljs-comment">// 处理USB设备</span><br>        <span class="hljs-comment">/* interface drivers never match devices */</span><br>        <span class="hljs-keyword">if</span> (!is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Add real matching code */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理USB接口设备</span><br>        <span class="hljs-keyword">struct</span> usb_interface *intf;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> *<span class="hljs-title">usb_drv</span>;</span><br>        <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> *<span class="hljs-title">id</span>;</span><br><br>        <span class="hljs-comment">/* device drivers never match interfaces */</span><br>        <span class="hljs-keyword">if</span> (is_usb_device_driver(drv))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        intf = to_usb_interface(dev);<br>        usb_drv = to_usb_driver(drv);<br><br>        id = usb_match_id(intf, usb_drv-&gt;id_table);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        id = usb_match_dynamic_id(intf, usb_drv);<br>        <span class="hljs-keyword">if</span> (id)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>probe 向USB总线注册一个root hub 设备，从usb总线的的驱动链表中，取出每一项驱动进行匹配。在USB Core中已经向总线注册了三个驱动（USB设备驱动、USB接口驱动、USB hub驱动），根据条件匹配到USB设备驱动，则去调用USB设备驱动的probe函数。</p><h3 id="USB设备驱动的probe函数"><a href="#USB设备驱动的probe函数" class="headerlink" title="USB设备驱动的probe函数"></a>USB设备驱动的probe函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">generic_probe(<span class="hljs-keyword">struct</span> usb_device *udev) -&gt; <span class="hljs-comment">// 从上分析流程知udev为USB root hub设备 </span><br>    usb_set_configuration -&gt;<br>        device_add -&gt;  <span class="hljs-comment">// 创建USB接口设备，USB root hub接口设备被创建</span><br></code></pre></td></tr></table></figure><p>之后匹配到USB Core中注册的USB hub驱动，执行USB hub驱动的probe函数，该probe函数中，创建了一个urb并为其注册了一个中断处理函数hub_irq，用来唤醒hub_thread线程来处理USB设备事件（插入、拔出）。至此，系统启动初始化时关于USB的内容分析完成。USB Core和USB HCD的成功建立联系，为之后的USB设备驱动提供API。</p><h2 id="USB设备驱动-–USB鼠标"><a href="#USB设备驱动-–USB鼠标" class="headerlink" title="USB设备驱动 –USB鼠标"></a>USB设备驱动 –USB鼠标</h2><p>用于和枚举到的USB设备进行绑定，完成特定的功能。 比如USB鼠标设备，驱动开发主要是这一块代码的coding。</p><h3 id="注册一个USB接口驱动"><a href="#注册一个USB接口驱动" class="headerlink" title="注册一个USB接口驱动"></a>注册一个USB接口驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_driver</span> <span class="hljs-title">usb_mouse_driver</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;usbmouse&quot;</span>,<br>.probe= usb_mouse_probe,<br>.disconnect= usb_mouse_disconnect,<br>.id_table= usb_mouse_id_table,<br>&#125;;<br><br>module_usb_driver(usb_mouse_driver);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * module_usb_driver() - Helper macro for registering a USB driver</span><br><span class="hljs-comment"> * @__usb_driver: usb_driver struct</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Helper macro for USB drivers which do not do anything special in module</span><br><span class="hljs-comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span><br><span class="hljs-comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> module_usb_driver(__usb_driver) \</span><br><span class="hljs-meta">module_driver(__usb_driver, usb_register, \</span><br><span class="hljs-meta">       usb_deregister)</span><br></code></pre></td></tr></table></figure><h3 id="USB接口设备的创建"><a href="#USB接口设备的创建" class="headerlink" title="USB接口设备的创建"></a>USB接口设备的创建</h3><p>当一个USB 鼠标设备插入后，主机USB控制器检测到后，触发USB设备集线器中的”中断”处理函数hub_irq。在hub_irq中会获取USB鼠标设备的设备描述符，根据设备描述符创建USB接口设备，从而和这边的USB接口驱动匹配，调用其probe函数，通过USB总线驱动程序（USB Core和USB HCD）和USB鼠标设备建立联系，进而操作（读写控制）该设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">hub_irq<br>    kick_khubd <span class="hljs-comment">// 唤醒hub_thread线程</span><br>        hub_thread<br>            hub_events <span class="hljs-comment">// 处理USB设备插入事件</span><br>                hub_port_connect_change<br><br>                    udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);<br>                                dev-&gt;dev.bus = &amp;usb_bus_type;<br><br>                    choose_address(udev); <span class="hljs-comment">// 给新设备分配编号(地址)                                       </span><br>                    hub_port_init   <span class="hljs-comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 3</span><br><br>                        hub_set_address  <span class="hljs-comment">// 把编号(地址)告诉USB设备</span><br><br>                        usb_get_device_descriptor(udev, <span class="hljs-number">8</span>); <span class="hljs-comment">// 获取设备描述符</span><br>                        retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);<br><br>                        usb_new_device(udev)   <br>                            err = usb_get_configuration(udev); <span class="hljs-comment">// 把所有的描述符都读出来，并解析</span><br>                            usb_parse_configuration<br><br>                            device_add  <span class="hljs-comment">// 把device放入usb_bus_type的dev链表, </span><br>                                        <span class="hljs-comment">// 从usb_bus_type的driver链表里取出usb_driver，</span><br>                                        <span class="hljs-comment">// 把usb_interface和usb_driver的id_table比较</span><br>                                        <span class="hljs-comment">// 如果能匹配，调用usb_driver的probe</span><br></code></pre></td></tr></table></figure><h3 id="USB接口驱动和USB接口设备的匹配"><a href="#USB接口驱动和USB接口设备的匹配" class="headerlink" title="USB接口驱动和USB接口设备的匹配"></a>USB接口驱动和USB接口设备的匹配</h3><p>USB设备插入后根据获取到的设备描述符所创建的USB 接口设备和开发的USB接口驱动匹配： 对于设备： 将获取到的USB设备描述符信息保存在其id_table中。 对于驱动： 驱动的id_table中存放期望该驱动适用的USB设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_id</span> <span class="hljs-title">usb_mouse_id_table</span>[] =</span> &#123;<br>&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,<br>USB_INTERFACE_PROTOCOL_MOUSE) &#125;,<br>&#123; &#125;<span class="hljs-comment">/* Terminating entry */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>匹配成功后调用该驱动的probe函数，具体的过程和前面分析的差不多。接下来就是在probe函数中，和USB总线驱动程序建立联系，以达到操作USB 鼠标设备的目的。</p><h3 id="创建数据传输管道"><a href="#创建数据传输管道" class="headerlink" title="创建数据传输管道"></a>创建数据传输管道</h3><p>根据数据传输类型，有几个接口可供调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create various pipes... */</span><br><span class="hljs-comment">// 控制传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndctrlpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvctrlpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 实时传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndisocpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvisocpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 批量传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndbulkpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvbulkpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br><span class="hljs-comment">// 中断传输</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_sndintpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> usb_rcvintpipe(dev, endpoint)\</span><br><span class="hljs-meta">((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span><br></code></pre></td></tr></table></figure><p>对于USB 鼠标设备，使用中断传输方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device</span> *<span class="hljs-title">dev</span> =</span> interface_to_usbdev(intf);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_host_interface</span> *<span class="hljs-title">interface</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_endpoint_descriptor</span> *<span class="hljs-title">endpoint</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_dev</span> *<span class="hljs-title">input_dev</span>;</span><br><span class="hljs-type">int</span> pipe, maxp;<br><span class="hljs-type">int</span> error = -ENOMEM;<br><br>interface = intf-&gt;cur_altsetting;<br><br><span class="hljs-keyword">if</span> (interface-&gt;desc.bNumEndpoints != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>endpoint = &amp;interface-&gt;endpoint[<span class="hljs-number">0</span>].desc;<br><span class="hljs-keyword">if</span> (!usb_endpoint_is_int_in(endpoint))<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 端点是USB设备数据传输对象</span><br>pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);<br>maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));<br></code></pre></td></tr></table></figure><h3 id="分配urb"><a href="#分配urb" class="headerlink" title="分配urb"></a>分配urb</h3><p>urb（USB Request Block）是Linux内核中USB驱动实现上的一个数据结构，用于组织每一次的USB设备驱动的数据传输请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mouse-&gt;irq = usb_alloc_urb(<span class="hljs-number">0</span>, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!mouse-&gt;irq)<br><span class="hljs-keyword">goto</span> fail2;<br></code></pre></td></tr></table></figure><h3 id="urb数据结构初始化"><a href="#urb数据结构初始化" class="headerlink" title="urb数据结构初始化"></a>urb数据结构初始化</h3><p>根据传输类型，有几个接口可供调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 控制</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_control_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *setup_packet,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params"><span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params"><span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *context)</span><br><span class="hljs-comment">// 批量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_bulk_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">     <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">     <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">     <span class="hljs-type">void</span> *context)</span><br><br><span class="hljs-comment">// 中断</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usb_fill_int_urb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> urb *urb,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> usb_device *dev,</span><br><span class="hljs-params">    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *transfer_buffer,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> buffer_length,</span><br><span class="hljs-params">    <span class="hljs-type">usb_complete_t</span> complete_fn,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *context,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> interval)</span><br><span class="hljs-comment">// 实时   </span><br><span class="hljs-comment">// 实时urb 没有和中断、控制、批量urb 类似的初始化函数，因此它们在提交到USB核心之前，需要在驱动程序中手动的初始化</span><br></code></pre></td></tr></table></figure><p>对于USB鼠标设备，采用中断传输方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,<br> (maxp &gt; <span class="hljs-number">8</span> ? <span class="hljs-number">8</span> : maxp),<br> usb_mouse_irq, mouse, endpoint-&gt;bInterval);<br>mouse-&gt;irq-&gt;transfer_dma = mouse-&gt;data_dma;<br>mouse-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;<br></code></pre></td></tr></table></figure><h3 id="提交USB请求块"><a href="#提交USB请求块" class="headerlink" title="提交USB请求块"></a>提交USB请求块</h3><p>调用usb_submit_urb接口以获取USB设备数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">usb_mouse_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> input_dev *dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_mouse</span> *<span class="hljs-title">mouse</span> =</span> input_get_drvdata(dev);<br><br>mouse-&gt;irq-&gt;dev = mouse-&gt;usbdev;<br><span class="hljs-keyword">if</span> (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))<br><span class="hljs-keyword">return</span> -EIO;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>USB驱动开发，针对某一个USB设备的某个功能（接口）构建的驱动程序。USB驱动并不直接和USB设备进行数据交互，而是通过USB总线驱动程序（USB Core和USB HCD）来操作USB设备的。一般构建USB设备驱动的流程为：</p><ul><li>根据期望适用的USB设备信息构建一个id_table。</li><li>根据需要的数据传输类型，调用相应的接口创建数据传输管道。</li><li>分配一个urb(USB请求块)。</li><li>根据需要的数据传输类型，调用相应的接口进行urb数据结构初始化。</li><li>提交urb</li></ul><p>参考链接：</p><ul><li><a href="http://www.yuanzige.com/">www.yuanzige.com</a></li><li>[正点原子] I.MX6U嵌入式Linux驱动开发指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>usb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crash</title>
    <link href="/debug/crash/"/>
    <url>/debug/crash/</url>
    
    <content type="html"><![CDATA[<h1 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h1><p>一个用于分析 Linux 内核转储文件的工具。它提供了一个交互式的环境，让用户能够检查内核转储文件中的信息，包括进程栈、内核数据结构等</p><h3 id="进入crash环境"><a href="#进入crash环境" class="headerlink" title="进入crash环境"></a>进入crash环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -s<br>crash /lib/debug/vmlinux<br></code></pre></td></tr></table></figure><h3 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h3><p>backtrace打印内核栈回溯信息，bt pid 打印指定进程栈信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; bt 1942<br>PID: 1942   TASK: ffff88068c957300  CPU: 2   COMMAND: <span class="hljs-string">&quot;bash&quot;</span><br> <span class="hljs-comment">#0 [ffff88062b8f7b48] machine_kexec at ffffffff81051e9b</span><br> <span class="hljs-comment">#1 [ffff88062b8f7ba8] crash_kexec at ffffffff810f27e2</span><br> <span class="hljs-comment">#2 [ffff88062b8f7c78] oops_end at ffffffff81689948</span><br> <span class="hljs-comment">#3 [ffff88062b8f7ca0] no_context at ffffffff816793f1</span><br> <span class="hljs-comment">#4 [ffff88062b8f7cf0] __bad_area_nosemaphore at ffffffff81679487</span><br> <span class="hljs-comment">#5 [ffff88062b8f7d38] bad_area_nosemaphore at ffffffff816795f1</span><br> <span class="hljs-comment">#6 [ffff88062b8f7d48] __do_page_fault at ffffffff8168c6ce</span><br> <span class="hljs-comment">#7 [ffff88062b8f7da8] do_page_fault at ffffffff8168c863</span><br> <span class="hljs-comment">#8 [ffff88062b8f7dd0] page_fault at ffffffff81688b48</span><br>    [exception RIP: sysrq_handle_crash+22]<br>    RIP: ffffffff813baf16  RSP: ffff88062b8f7e80  RFLAGS: 00010046<br>    RAX: 000000000000000f  RBX: ffffffff81a7b180  RCX: 0000000000000000<br>    RDX: 0000000000000000  RSI: ffff88086ec8f6c8  RDI: 0000000000000063<br>    RBP: ffff88062b8f7e80   R8: 0000000000000092   R9: 0000000000000e37<br>    R10: 0000000000000e36  R11: 0000000000000003  R12: 0000000000000063<br>    R13: 0000000000000246  R14: 0000000000000004  R15: 0000000000000000<br>    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018<br> <span class="hljs-comment">#9 [ffff88062b8f7e88] __handle_sysrq at ffffffff813bb6d2</span><br><span class="hljs-comment">#10 [ffff88062b8f7ec0] write_sysrq_trigger at ffffffff813bbbaf</span><br><span class="hljs-comment">#11 [ffff88062b8f7ed8] proc_reg_write at ffffffff812494bd</span><br><span class="hljs-comment">#12 [ffff88062b8f7ef8] vfs_write at ffffffff811dee9d</span><br><span class="hljs-comment">#13 [ffff88062b8f7f38] sys_write at ffffffff811df93f</span><br><span class="hljs-comment">#14 [ffff88062b8f7f80] system_call_fastpath at ffffffff81691049</span><br>    RIP: 00007fb320bcb500  RSP: 00007ffde533c198  RFLAGS: 00000246<br>    RAX: 0000000000000001  RBX: ffffffff81691049  RCX: ffffffffffffffff<br>    RDX: 0000000000000002  RSI: 00007fb3214eb000  RDI: 0000000000000001<br>    RBP: 00007fb3214eb000   R8: 000000000000000a   R9: 00007fb3214d5740<br>    R10: 0000000000000001  R11: 0000000000000246  R12: 0000000000000001<br>    R13: 0000000000000002  R14: 00007fb320e9f400  R15: 0000000000000002<br>    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b<br></code></pre></td></tr></table></figure><p>解析：</p><p>可以看到最后几步触发了缺页异常，进入crash_kexec的流程，最后调用 machine_kexec()。这通常是一个硬件相关的函数。它会引导启动捕获内核，从而完成 kdump 的过程。<br>代码就是走到了sysrq_handle_crash函数首地址+0x22这段命令的时候，触发的缺页异常。</p><p>注意：</p><p>这里，对应x86-64汇编，应用层下来的系统调用对应的6个参数存放的寄存器依次对应：rdi、rsi、rdx、rcx、r8、r9。对于多于6个参数的，仍存储在栈上。</p><ul><li>查看调用栈（默认查看的导致crash的进程的调用栈）<br><code>bt</code></li><li>查看调用栈，显示返回地址在函数内的偏移<br><code>bt -sx</code></li><li>查看调用栈中函数的返回地址对应的代码行<br><code>bt -l</code></li><li>查看详细的调用栈内容<br><code>bt -fsx</code></li><li>查看详细的调用栈，并且翻译栈里可以识别的符号<br><code>bt -FFsx</code></li><li>想查看指定进程的栈<br><code>bt &lt;进程pid&gt;</code><br>或者<br><code>bt &lt;进程的task_struct地址&gt;</code><ul><li>如果想查看多个进程的调用栈的话，可以直接在后面追加<code>进程pid</code>或者<code>进程的task_struct地址</code>，也可以使用<code>foreach bt</code></li><li><code>进程pid</code>和<code>进程的task_struct</code>可以同时出现在bt后面</li></ul></li><li>查看所有cpu上当前的调用栈<br><code>bt -a</code></li><li>查看指定cpu上的当前调用栈<br><code>bt -c 0,1,3-6</code></li><li>只显示导致crash的进程的调用栈<br><code>bt -p</code></li><li>显示线程组中所有线程的调用栈<br><code>bt -g</code></li><li>列出在调用栈里发现的所有的符号<br><code>bt -t</code></li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>打印vmcore所在的系统内核dmesg日志信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; <span class="hljs-built_in">log</span><br>[    0.000000] Linux version 4.19.0-amd64-desktop (uos@x86-compile-PC) (gcc version 8.3.0 (Uos 8.3.0.5-1+dde)) (c42ec32bb9fc) <span class="hljs-comment">#6300 SMP Fri Dec 15 13:53:22 CST 2023</span><br>[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.19.0-amd64-desktop root=UUID=826567d9-9352-4ab2-a268-e23345c606df ro video=efifb:nobgrt splash quiet DEEPIN_GFXMODE= ima_appraise=off libahci.ignore_sss=1<br>[    0.000000] KERNEL supported cpus:<br>[    0.000000]   Intel GenuineIntel<br>[    0.000000]   AMD AuthenticAMD<br>[    0.000000]   Hygon HygonGenuine<br>[    0.000000]   Centaur CentaurHauls<br>[    0.000000]   zhaoxin   Shanghai  <br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: <span class="hljs-string">&#x27;x87 floating point registers&#x27;</span><br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x002: <span class="hljs-string">&#x27;SSE registers&#x27;</span><br>[    0.000000] x86/fpu: Supporting XSAVE feature 0x004: <span class="hljs-string">&#x27;AVX registers&#x27;</span><br>[    0.000000] x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256<br>[    0.000000] x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using <span class="hljs-string">&#x27;compacted&#x27;</span> format.<br>[    0.000000] BIOS-provided physical RAM map:<br>[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x0000000000086fff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000000087000-0x0000000000087fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000000088000-0x000000000009ffff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000000a0000-0x00000000000bffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x0000000009afffff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000009b00000-0x0000000009dfffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000009e00000-0x0000000009efffff] usable<br>[    0.000000] BIOS-e820: [mem 0x0000000009f00000-0x0000000009f0afff] ACPI NVS<br>[    0.000000] BIOS-e820: [mem 0x0000000009f0b000-0x00000000970f8fff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000970f9000-0x0000000097af8fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000097af9000-0x00000000add0efff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000add0f000-0x00000000aee8efff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000aee8f000-0x00000000af77efff] ACPI NVS<br>[    0.000000] BIOS-e820: [mem 0x00000000af77f000-0x00000000af7fefff] ACPI data<br>[    0.000000] BIOS-e820: [mem 0x00000000af7ff000-0x00000000af7fffff] usable<br>[    0.000000] BIOS-e820: [mem 0x00000000af800000-0x00000000afffffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000f8000000-0x00000000fbffffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fdc00000-0x00000000fec00fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fec10000-0x00000000fec10fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fed80000-0x00000000fed80fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved<br>[    0.000000] BIOS-e820: [mem 0x00000000ff800000-0x00000000fff3ffff] reserved<br>[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000040effffff] usable<br>[    0.000000] BIOS-e820: [mem 0x000000040f000000-0x000000044effffff] reserved<br>[    0.000000] NX (Execute Disable) protection: active<br>[    0.000000] e820: update [mem 0x94db8018-0x94dc5457] usable ==&gt; usable<br>[    0.000000] e820: update [mem 0x94db8018-0x94dc5457] usable ==&gt; usable<br>[    0.000000] extended physical RAM map:<br></code></pre></td></tr></table></figure><h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><p><code>dis -l (function+offset) 10</code> 反汇编出指令所在代码，10代表打印该指定位置开始的10行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; dis -l do_sys_poll 10<br>/home/uos/code/workspace/kernel/gerrit-V20-kernel-pipeline/x86-kernel/fs/select.c: 928<br>0xffffffff8f681540 &lt;do_sys_poll&gt;:       nopl   0x0(%rax,%rax,1) [FTRACE NOP]<br>0xffffffff8f681545 &lt;do_sys_poll+5&gt;:     push   %rbp<br>0xffffffff8f681546 &lt;do_sys_poll+6&gt;:     mov    %rsp,%rbp<br>0xffffffff8f681549 &lt;do_sys_poll+9&gt;:     push   %r15<br>0xffffffff8f68154b &lt;do_sys_poll+11&gt;:    push   %r14<br>0xffffffff8f68154d &lt;do_sys_poll+13&gt;:    push   %r13<br>0xffffffff8f68154f &lt;do_sys_poll+15&gt;:    mov    %esi,%r13d<br>0xffffffff8f681552 &lt;do_sys_poll+18&gt;:    push   %r12<br>0xffffffff8f681554 &lt;do_sys_poll+20&gt;:    push   %rbx<br>0xffffffff8f681555 &lt;do_sys_poll+21&gt;:    and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br></code></pre></td></tr></table></figure><ul><li>反汇编指定函数<br><code>dis -x &lt;function name&gt;/&lt;addr&gt;</code></li><li>反汇编指定偏移<br><code>dis -x &lt;function+0xXX&gt;</code></li><li>反汇编从函数开始到指定偏移量之间的代码<br><code>dis -rx &lt;function+0xXX&gt;</code></li></ul><h3 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h3><p>mod 查看当时内核加载的所有内核模块信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; mod<br>     MODULE       NAME                 SIZE    OBJECT        FILE<br>ffffffffc01ee200  button               20480   (not loaded)  [CONFIG_KALLSYMS]<br>ffffffffc0211f00  hid                  139264  (not loaded)  [CONFIG_KALLSYMS]<br>ffffffffc021a0c0  ecb                  16384   (not loaded)  [CONFIG_KALLSYMS]<br></code></pre></td></tr></table></figure><h3 id="sym"><a href="#sym" class="headerlink" title="sym"></a>sym</h3><p><code>sym 00007fb320bcb500 (内存地址)</code>   转换指定符号为其虚拟地址，显示系统中对应的符号表信息，并且具体到源代码的那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; sym ffffffffc07c5024<br>ffffffffc07c5024 (t) my_openat+36 [my_test_lkm] /mnt/hgfs/test_ko/lkm-test05/my_lkm.c: 25<br></code></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps 打印内核崩溃时，正常的进程信息</p><p>带 &gt; 标识代表是活跃的进程，ps pid打印某指定进程的状态信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; ps 27005<br>   PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM<br>&gt; 27005   7783   1  ffff997b388ae180  RU   0.2   91732   4124  pickup<br>&gt; <br>查看指定进程的进程树，显示进程父子关系（ps -p pid） <br>crash&gt; ps -p 85151<br>PID: 0      TASK: ffffffff818b6420  CPU: 0   COMMAND: <span class="hljs-string">&quot;swapper/0&quot;</span><br> PID: 1      TASK: ffff881f91dae040  CPU: 28  COMMAND: <span class="hljs-string">&quot;init&quot;</span><br>  PID: 14544  TASK: ffff881f8d7b05c0  CPU: 11  COMMAND: <span class="hljs-string">&quot;init.tfa&quot;</span><br>   PID: 85138  TASK: ffff880bab01a400  CPU: 8   COMMAND: <span class="hljs-string">&quot;tfactl&quot;</span><br>    PID: 85151  TASK: ffff880b7a728380  CPU: 17  COMMAND: <span class="hljs-string">&quot;perl&quot;</span><br>ps -t [pid]: 显示进程运行时间<br></code></pre></td></tr></table></figure><ul><li><p>显示所有进程的pid、task_struct、cpu以及运行状态等信息<br><code>ps</code></p><ul><li><p>MEM列：使用物理内存的百分比</p></li><li><p>VSZ列：虚拟地址空间大小，单位KB</p></li><li><p>RSS列：实际使用的物理内存大小，单位KB</p></li><li><p>在进程状态一列显示的标识跟进程状态的对应关系(task_state_string)：</p><table><thead><tr><th>标识</th><th>状态</th><th>定义</th></tr></thead><tbody><tr><td>RU</td><td>TASK_RUNNING</td><td>0</td></tr><tr><td>IN</td><td>TASK_INTERRUPTIBLE</td><td>1</td></tr><tr><td>UN</td><td>TASK_UNINTERRUPTIBLE</td><td>2</td></tr><tr><td>ZO</td><td>EXIT_ZOMBIE</td><td></td></tr><tr><td>ST</td><td>__TASK_STOPPED</td><td></td></tr><tr><td>TR</td><td>__TASK_TRACED</td><td></td></tr><tr><td>DE</td><td>EXIT_DEAD</td><td></td></tr><tr><td>SW</td><td>SWAPPING</td><td></td></tr><tr><td>WA</td><td>TASK_WAKING</td><td></td></tr><tr><td>PA</td><td>TASK_PARKED</td><td></td></tr><tr><td>ID</td><td>TASK_IDLE</td><td>TASK_UNINTERRUPTIBLE | TASK_NOLOAD</td></tr><tr><td>NE</td><td>TASK_NEW</td><td></td></tr></tbody></table></li></ul></li><li><p>显示指定进程的信息<br><code>ps &lt;进程pid&gt;</code><br>or<br><code>ps &lt;进程名字&gt;</code><br>or<br><code>ps &lt;进程task_struct地址&gt;</code></p></li><li><p>只显示内核线程<br><code>ps -k</code></p></li><li><p>只显示用户进程<br><code>ps -u</code></p></li><li><p>只显示线程组组长<br><code>ps -G</code></p></li><li><p>显示指定调度策略的任务<br><code>ps -y &lt;policy&gt;</code><br>这里的<code>policy</code>可以是左边的数组，或者对应的右边的字符串：</p><table><thead><tr><th>数字</th><th>策略</th><th>调度类</th></tr></thead><tbody><tr><td>0</td><td>NORMAL</td><td>cfs</td></tr><tr><td>1</td><td>FIFO</td><td>rt</td></tr><tr><td>2</td><td>RR</td><td>rt</td></tr><tr><td>3</td><td>BATCH</td><td>cfs</td></tr><tr><td>4</td><td>ISO</td><td></td></tr><tr><td>5</td><td>IDLE</td><td>cfs</td></tr><tr><td>6</td><td>DEADLINE</td><td>deadline</td></tr></tbody></table></li><li><p>显示每个进程的内核栈的地址<br><code>ps -s</code></p></li><li><p>显示进程之间的父子关系<br><code>ps -p</code></p></li><li><p>显示全部或者指定进程的子进程<br><code>ps -c</code></p></li><li><p>显示进程的运行时间、起始时间以及在用户态和内核态的时间<br><code>ps -t</code></p></li><li><p>显示进程上次运行的时间戳，有多个进程的话会从距离现在最近的时间戳开始进行排序<br><code>ps -l</code></p><ul><li>如果想将时间戳按<code>天-时-分-秒-毫秒</code>的形式显示，可以使用<code>ps -m</code></li><li>如果想显示在指定cpu上的时间戳，可以配合<code>-C</code>：<code>ps -C 0,2,5-8 -l</code></li></ul></li><li><p>按线程组的方式显示，<strong>如果知道了一个进程或者线程的pid，想知道所属的线程组还有哪些线程，可以使用这个命令</strong><br><code>ps -g</code></p></li><li><p>显示进程的资源限制<br><code>ps -r</code></p></li><li><p>统计每种状态的进程的数量<br><code>ps -S</code></p></li><li><p>只显示当前正在cpu上运行的进程<br><code>ps -A</code></p></li></ul><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>files pid 打印指定进程所打开的文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; files 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>ROOT: /    CWD: /<br> FD       FILE            DENTRY           INODE       TYPE PATH<br>  0 ffff8bac747f8900 ffff8bac7f00a000 ffff8bac7d02bad0 CHR  /dev/null<br>  1 ffff8bac747f9e00 ffff8bac7a23cd80 ffff8bac7abb5570 SOCK UNIX<br>  2 ffff8bac747f9e00 ffff8bac7a23cd80 ffff8bac7abb5570 SOCK UNIX<br>  3 ffff8bac794fdc00 ffff8bac7a0fd980 ffff8bac7ca64000 UNKN [eventfd]<br>  4 ffff8bac794fd700 ffff8bac7a0fc780 ffff8bac7a1771e0 FIFO <br>  5 ffff8bac794fde00 ffff8bac7a0fc780 ffff8bac7a1771e0 FIFO <br>  6 ffff8bac794fd400 ffff8bac66e9ecc0 ffff8bac7a1ec928 REG  /var/var/log/lightdm/lightdm.log<br>  7 ffff8bac794fc700 ffff8bac66e9e000 ffff8bac7ca64000 UNKN [eventfd]<br>  8 ffff8bac74d4d300 ffff8bac7a3ad680 ffff8bac7988d1a8 DIR  /var/var/lib/lightdm/data<br>  9 ffff8bac78f1d700 ffff8bac7a08cb40 ffff8bac7a090b30 SOCK UNIX<br> 10 ffff8bac73e40500 ffff8bac7985aa80 ffff8bac7ca64000 UNKN [eventfd]<br> 11 ffff8bac731c6b00 ffff8bac775a8000 ffff8bac7abfee30 SOCK UNIX<br> 15 ffff8bac74670900 ffff8bac7772e000 ffff8bac7aa704c0 FIFO <br> 16 ffff8bac74670e00 ffff8bac7772ef00 ffff8bac7aa72860 FIFO <br> 22 ffff8bac69130900 ffff8bac7772f500 ffff8bac7aa710a0 FIFO<br></code></pre></td></tr></table></figure><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><p>vm pid 打印某指定进程当时虚拟内存基本信息，查看进程的用户虚拟内存信息（mm_struct地址，vma等）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; vm 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>       MM               PGD          RSS    TOTAL_VM<br>ffff8bac695bf700  ffff8bac6ce42000  9504k   309268k <br>      VMA           START       END     FLAGS FILE<br>ffff8bac71486a90 563c12926000 563c1292d000 8000871 /usr/sbin/lightdm<br>ffff8bac714872b0 563c1292d000 563c12957000 8000875 /usr/sbin/lightdm<br>ffff8bac71486750 563c12957000 563c1296a000 8000871 /usr/sbin/lightdm<br>ffff8bac71487110 563c1296b000 563c1296c000 8100871 /usr/sbin/lightdm<br>ffff8bac713be340 563c1296c000 563c1296d000 8100873 /usr/sbin/lightdm<br>ffff8bac713be5b0 563c13820000 563c138ae000 8100073 <br>ffff8bac6ce94270 7fa728000000 7fa72802d000 8200073<br></code></pre></td></tr></table></figure><p>看进程的用户虚拟内存的映射信息<br><code>vma -p</code></p><ul><li><p>如果虚拟地址已经映射到物理地址，那么会将对应的物理地址显示出来</p></li><li><p>否则，如果映射的是文件的话，显示文件名以及偏移</p></li><li><p>如果是匿名内存，并且被交换出去了，那么会显示对应的交换设备以及偏移</p></li><li><p>如果只想查看指定vma的映射信息，可以使用<code>vm -P &lt;vma的虚拟地址&gt;</code></p></li><li><p>查看指定mm_struct的信息，用于无法通过task_struct获取mm_struct，但是可以通过其他途径获取mm_struct地址的情况<br><code>vm -M &lt;mm_struct的地址&gt;</code></p></li><li><p>查看指定进程的mm_struct的内容，跟用<code>struct mm_struct &lt;mm_struct地址&gt;</code>一个效果<br><code>vm -m</code> 或者 <code>vm -m &lt;pid&gt;</code></p></li><li><p>查看指定进程的vm_area_struct的内容，跟<code>struct vm_area_struct &lt;vma地址&gt;</code>效果类似<br><code>vm -v</code> 或者 <code>vm -v &lt;pid&gt;</code> 或者 <code>vm -v &lt;进程task_struct&gt;</code></p></li></ul><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>task 查看当前进程或指定进程task_struct和thread_info的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; task 1106<br>PID: 1106   TASK: ffff8bac7d2c0f40  CPU: 0   COMMAND: <span class="hljs-string">&quot;lightdm&quot;</span><br>struct task_struct &#123;<br>  thread_info = &#123;<br>    flags = 0, <br>    status = 0<br>  &#125;, <br>  state = 1, <br>  stack = 0xffffa530038c4000, <br>  usage = &#123;<br>    counter = 2<br>  &#125;, <br>  flags = 4194560, <br>  ptrace = 0, <br>  wake_entry = &#123;<br>    next = 0x0<br>  &#125;, <br>  on_cpu = 0, <br>  cpu = 0, <br>  wakee_flips = 16, <br>  wakee_flip_decay_ts = 4295264801, <br>  last_wakee = 0xffff8bac7d2c1e80, <br>.................<br></code></pre></td></tr></table></figure><h3 id="kmem"><a href="#kmem" class="headerlink" title="kmem"></a>kmem</h3><p><code>kmem -i</code> 查看内存整体使用情况</p><p><code>kmem -s</code>  查看slab使用情况</p><p><code>kmem [addr]</code> 搜索地址所属的内存结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; kmem -i<br>                 PAGES        TOTAL      PERCENTAGE<br>    TOTAL MEM  3847813      14.7 GB         ----<br>         FREE  2437856       9.3 GB   63% of TOTAL MEM<br>         USED  1409957       5.4 GB   36% of TOTAL MEM<br>       SHARED   197787     772.6 MB    5% of TOTAL MEM<br>      BUFFERS    43217     168.8 MB    1% of TOTAL MEM<br>       CACHED   984251       3.8 GB   25% of TOTAL MEM<br>         SLAB    73599     287.5 MB    1% of TOTAL MEM<br><br>   TOTAL HUGE        0            0         ----<br>    HUGE FREE        0            0    0% of TOTAL HUGE<br><br>   TOTAL SWAP  3971839      15.2 GB         ----<br>    SWAP USED        0            0    0% of TOTAL SWAP<br>    SWAP FREE  3971839      15.2 GB  100% of TOTAL SWAP<br><br> COMMIT LIMIT  5895745      22.5 GB         ----<br>    COMMITTED  1660064       6.3 GB   28% of TOTAL LIMIT<br></code></pre></td></tr></table></figure><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct [struct]              //查看结构体成员变量<br>struct -o [struct]           //显示结构体中成员的偏移<br>struct [struct] [address]    //显示对应地址结构体的值<br>[struct] [address]           //简化形式显示对应地址结构体的值<br>[struct] [address] -xo       //打印结构体定义和大小<br>[struct].member[address]     //显示某个成员的值<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct dentry<br>struct dentry &#123;<br>    unsigned int d_flags;<br>    seqcount_t d_seq;<br>    struct hlist_bl_node d_hash;<br>    struct dentry *d_parent;<br>    struct qstr d_name;<br>    struct inode *d_inode;<br>    unsigned char d_iname[32];<br>    struct lockref d_lockref;<br>    const struct dentry_operations *d_op;<br>    struct super_block *d_sb;<br>    unsigned long d_time;<br>    void *d_fsdata;<br>    union &#123;<br>        struct list_head d_lru;<br>        wait_queue_head_t *d_wait;<br>    &#125;;<br>    struct list_head d_child;<br>    struct list_head d_subdirs;<br>    union &#123;<br>        struct hlist_node d_alias;<br>        struct hlist_bl_node d_in_lookup_hash;<br>        struct callback_head d_rcu;<br>    &#125; d_u;<br>&#125;<br>SIZE: 192<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct -o dentry<br>struct dentry &#123;<br>    [0] unsigned int d_flags;<br>    [4] seqcount_t d_seq;<br>    [8] struct hlist_bl_node d_hash;<br>   [24] struct dentry *d_parent;<br>   [32] struct qstr d_name;<br>   [48] struct inode *d_inode;<br>   [56] unsigned char d_iname[32];<br>   [88] struct lockref d_lockref;<br>   [96] const struct dentry_operations *d_op;<br>  [104] struct super_block *d_sb;<br>  [112] unsigned long d_time;<br>  [120] void *d_fsdata;<br>        union &#123;<br>  [128]     struct list_head d_lru;<br>  [128]     wait_queue_head_t *d_wait;<br>        &#125;;<br>  [144] struct list_head d_child;<br>  [160] struct list_head d_subdirs;<br>        union &#123;<br>            struct hlist_node d_alias;<br>            struct hlist_bl_node d_in_lookup_hash;<br>            struct callback_head d_rcu;<br>  [176] &#125; d_u;<br>&#125;<br>SIZE: 192<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct  dentry.d_name<br>struct dentry &#123;<br>   [32] struct qstr d_name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; struct dentry ffffffff8fbed352<br>struct dentry &#123;<br>  d_flags = 3905390920, <br>  d_seq = &#123;<br>    sequence = 4287371206<br>  &#125;, <br>  d_hash = &#123;<br>    next = 0x9d8bf8349c78949, <br>    pprev = 0x450850f000000<br>  &#125;, <br>  d_parent = 0x334865d0458b4800, <br>  d_name = &#123;<br>    &#123;<br>      &#123;<br>        <span class="hljs-built_in">hash</span> = 2630916, <br>        len = 2232352768<br>      &#125;, <br>      hash_len = 9587882131697706244<br>    &#125;, <br>    name = 0x30c4834800000562 &lt;Address 0x30c4834800000562 out of bounds&gt;<br>  &#125;, <br>  d_inode = 0x415e415d415c415b,<br></code></pre></td></tr></table></figure><p>如果要查看二阶指针的值，可以通过rd命令需要先获取一级指针的值，然后再用struct 结构体名 + addr获取具体的值</p><h3 id="rd"><a href="#rd" class="headerlink" title="rd"></a>rd</h3><p>读取内存内容</p><p><code>rd [addr] [len]</code>                    &#x2F;&#x2F;查看指定地址，长度为len的内存<br><code>rd -S [addr][len]</code>                &#x2F;&#x2F;尝试将地址转换为对应的符号<br><code>rd [addr] -e [addr]</code>            &#x2F;&#x2F;查看指定内存区域内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; rd ffffffff8fbed352 32<br>ffffffff8fbed352:  ff8c17c6e8c78948 09d8bf8349c78949   H.......I..I....<br>ffffffff8fbed362:  000450850f000000 334865d0458b4800   .....P...H.E.eH3<br>ffffffff8fbed372:  850f000000282504 30c4834800000562   .%(.....b...H..0<br>ffffffff8fbed382:  415e415d415c415b 2140c0c748c35d5f   [A\A]A^A_].H..@!<br>ffffffff8fbed392:  1e3c050348650002 00000b8c80837042   ..eH..&lt;.Bp......<br>ffffffff8fbed3a2:  f641fffffd88e901 0f01000007412484   ......A..<span class="hljs-variable">$A</span>.....<br>ffffffff8fbed3b2:  0009bafffffdf785 df8948e6894c0000   ..........L..H..<br>ffffffff8fbed3c2:  44c741ff8c49f9e8 f641000000006c24   ..I..A.D<span class="hljs-variable">$l</span>....A.<br>ffffffff8fbed3d2:  0f02000004c82484 44f6410000032785   .$.......<span class="hljs-string">&#x27;...A.D</span><br><span class="hljs-string">ffffffff8fbed3e2:  fffdcc840f202424 8b495de8e7894cff   $$ ......L...]I.</span><br><span class="hljs-string">ffffffff8fbed3f2:  0fc08548c68949ff 3c408bfffffdb884   .I..H.........@&lt;</span><br><span class="hljs-string">ffffffff8fbed402:  4c00022140c5c749 4890509720c52c03   I..@!..L.,. .P.H</span><br><span class="hljs-string">ffffffff8fbed412:  486500022140c0c7 394970421db80503   ..@!..eH....BpI9</span><br><span class="hljs-string">ffffffff8fbed422:  6500000456850fc5 00015cc025048b48   ...V...eH..%.\..</span><br><span class="hljs-string">ffffffff8fbed432:  00044b840fc63949 0000079c868d4900   I9...K...I......</span><br><span class="hljs-string">ffffffff8fbed442:  e8b8458948c78948 3475c08500005b12   H..H.E...[....u4</span><br></code></pre></td></tr></table></figure><h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><p>p命令可以用来打印出表达式或者变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">crash&gt; p __schedule<br>__schedule = <span class="hljs-variable">$1</span> = <br> &#123;void (bool)&#125; 0xffffffff8fbed0b0<br></code></pre></td></tr></table></figure><h3 id="ptov"><a href="#ptov" class="headerlink" title="ptov"></a>ptov</h3><p>根据一个物理地址，转存成对应的内核态虚拟地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">crash&gt; </span><span class="language-bash">ptov 65065400</span><br>VIRTUAL           PHYSICAL<br>ffff800025065400  65065400<br></code></pre></td></tr></table></figure><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://www.cnblogs.com/pengdonglin137/collections/7424?page=1">https://www.cnblogs.com/pengdonglin137/collections/7424?page=1</a></p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb</title>
    <link href="/debug/gdb/"/>
    <url>/debug/gdb/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p><strong>编译程序加参数时生成调试信息</strong></p><p>g 和 -ggdb 都是令 gcc 生成调试信息，但是它们也是有区别的</p><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>g</td><td>该选项可以利用操作系统的“原生格式（native format）”生成调试信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</td></tr><tr><td>ggdb</td><td>使 GCC为GDB 生成专用的更为丰富的调试信息，但是，此时就不能用其他的调试器来进行调试了 (如 ddx)</td></tr></tbody></table><p>g也是分级别的</p><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>g1</td><td>级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储之用。回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段</td></tr><tr><td>g2</td><td>这是默认的级别，此时产生的调试信息包括扩展的符号表、行号、局部或外部变量信息</td></tr><tr><td>g3</td><td>包含级别2中的所有调试信息，以及源代码中定义的宏</td></tr></tbody></table><h2 id="gdb调试常用命令解析"><a href="#gdb调试常用命令解析" class="headerlink" title="gdb调试常用命令解析"></a><strong>gdb调试常用命令解析</strong></h2><h3 id="b-break-断点"><a href="#b-break-断点" class="headerlink" title="b break 断点"></a>b break 断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span> 函数名<br><span class="hljs-built_in">break</span> 行号<br><span class="hljs-built_in">break</span> 文件名：行号<br><span class="hljs-built_in">break</span> 文件名：函数名<br><span class="hljs-built_in">break</span> +偏移量<br><span class="hljs-built_in">break</span> -偏移量<br><span class="hljs-built_in">break</span> *地址<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb)b iseq_compile            在函数处加断点<br>(gdb)b compile.c:516           在文件名和行号处加断点<br>(gdb)b +3                      设置偏移量<br>(gdb)b *0x88116fd6             在某地址处加断点<br>(gdb)b                         如果不指定位置，就是在下一行代码上设置断点<br></code></pre></td></tr></table></figure><p>设置好的断点可以通过 info break 查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info <span class="hljs-built_in">break</span><br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007febd6225bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br></code></pre></td></tr></table></figure><h3 id="disable-enable临时禁用和启用断点"><a href="#disable-enable临时禁用和启用断点" class="headerlink" title="disable | enable临时禁用和启用断点"></a>disable | enable临时禁用和启用断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007f218fcb1bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br>(gdb) disa<br><span class="hljs-built_in">disable</span>      disassemble  <br>(gdb) <span class="hljs-built_in">disable</span> 1<br>(gdb) <span class="hljs-built_in">enable</span> 1<br></code></pre></td></tr></table></figure><h3 id="rrun-开始运行"><a href="#rrun-开始运行" class="headerlink" title="rrun 开始运行"></a>rrun 开始运行</h3><h3 id="btbacktrace-命令可以在遇到断点而停止执行时显示栈帧"><a href="#btbacktrace-命令可以在遇到断点而停止执行时显示栈帧" class="headerlink" title="btbacktrace 命令可以在遇到断点而停止执行时显示栈帧"></a>btbacktrace 命令可以在遇到断点而停止执行时显示栈帧</h3><p><code>bt N</code>只显示开头N个栈帧</p><p><code>bt -N</code>只显示最后N个栈帧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt<br><span class="hljs-comment">#0  0x00007f218fcb1bd9 in __GI___poll (fds=0x7f218400a060, nfds=2, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29</span><br><span class="hljs-comment">#1  0x00007f218ff851f6 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br><span class="hljs-comment">#2  0x00007f218ff85582 in g_main_loop_run () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br><span class="hljs-comment">#3  0x0000563b79c85395 in ?? ()</span><br><span class="hljs-comment">#4  0x00007f218fbe71fb in __libc_start_main (main=0x563b79c84640, argc=1, argv=0x7ffff90918c8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, </span><br>    stack_end=0x7ffff90918b8) at ../csu/libc-start.c:308<br><span class="hljs-comment">#5  0x0000563b79c85ffa in ?? ()</span><br></code></pre></td></tr></table></figure><p><code>bt full</code> 不仅显示backtrace，还显示局部变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt full<br><span class="hljs-comment">#0  0x00007f218fcb1bd9 in __GI___poll (fds=0x7f218400a060, nfds=2, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29</span><br>        resultvar = 18446744073709551100<br>        sc_cancel_oldtype = 0<br>        sc_ret = &lt;optimized out&gt;<br><span class="hljs-comment">#1  0x00007f218ff851f6 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br>No symbol table info available.<br><span class="hljs-comment">#2  0x00007f218ff85582 in g_main_loop_run () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br>No symbol table info available.<br><span class="hljs-comment">#3  0x0000563b79c85395 in ?? ()</span><br>No symbol table info available.<br><span class="hljs-comment">#4  0x00007f218fbe71fb in __libc_start_main (main=0x563b79c84640, argc=1, argv=0x7ffff90918c8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, </span><br>    stack_end=0x7ffff90918b8) at ../csu/libc-start.c:308<br>        self = &lt;optimized out&gt;<br>        result = &lt;optimized out&gt;<br>        unwind_buf = &#123;cancel_jmp_buf = &#123;&#123;jmp_buf = &#123;0, 3044201088132136217, 94813446234064, 140737371510976, 0, 0, 8770247100387114265, 8649937328162159897&#125;, <br>              mask_was_saved = 0&#125;&#125;, priv = &#123;pad = &#123;0x0, 0x0, 0x7ffff90918d8, 0x7f21902b2190&#125;, data = &#123;prev = 0x0, cleanup = 0x0, canceltype = -116844328&#125;&#125;&#125;<br>        not_first_call = &lt;optimized out&gt;<br><span class="hljs-comment">#5  0x0000563b79c85ffa in ?? ()</span><br></code></pre></td></tr></table></figure><h3 id="pprint显示变量"><a href="#pprint显示变量" class="headerlink" title="pprint显示变量"></a>pprint显示变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p result<br><span class="hljs-variable">$1</span> = <span class="hljs-string">&#x27;\000&#x27;</span> &lt;repeats 113 <span class="hljs-built_in">times</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="info-reg显示寄存器的值"><a href="#info-reg显示寄存器的值" class="headerlink" title="info reg显示寄存器的值"></a>info reg显示寄存器的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info reg<br>rax            0xfffffffffffffdfc  -516<br>rbx            0x7f218400a060      139781925281888<br>rcx            0x7f218fcb1bd9      139782123101145<br>rdx            0xffffffff          4294967295<br>rsi            0x2                 2<br>rdi            0x7f218400a060      139781925281888<br>rbp            0x2                 0x2<br>rsp            0x7ffff90913e0      0x7ffff90913e0<br>r8             0x0                 0<br>r9             0x1                 1<br></code></pre></td></tr></table></figure><p>在寄存器之前添加 $，即可以显示各个寄存器的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p <span class="hljs-variable">$rip</span><br><span class="hljs-variable">$2</span> = (void (*)()) 0x7f218fcb1bd9 &lt;__GI___poll+73&gt;<br></code></pre></td></tr></table></figure><h3 id="x查看内存地址保存的值"><a href="#x查看内存地址保存的值" class="headerlink" title="x查看内存地址保存的值"></a>x查看内存地址保存的值</h3><p><code>(gdb) x/nfu addr</code></p><p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是<br>指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可<br>以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当<br>我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作<br>一个值取出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/3uh 0x54320 //从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。<br></code></pre></td></tr></table></figure><p><code>x/i $rip</code>   显示汇编指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/i <span class="hljs-variable">$rip</span><br>=&gt; 0x7f218fcb1bd9 &lt;__GI___poll+73&gt;:     cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br></code></pre></td></tr></table></figure><p>显示寄存器可以使用的格式：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>显示为十六进制数</td></tr><tr><td>d</td><td>显示为十进制数</td></tr><tr><td>u</td><td>显示为无符号十进制数</td></tr><tr><td>o</td><td>显示为八进制数</td></tr><tr><td>t</td><td>显示为二进制数，t的由来是two</td></tr><tr><td>a</td><td>地址</td></tr><tr><td>c</td><td>显示为字符(ASCII)</td></tr><tr><td>f</td><td>浮点小数</td></tr><tr><td>s</td><td>显示为字符串</td></tr><tr><td>i</td><td>显示为机器语言(仅在显示内存的X命令中可以使用)</td></tr></tbody></table><h3 id="nnext，执行下一行语句，不进入函数"><a href="#nnext，执行下一行语句，不进入函数" class="headerlink" title="nnext，执行下一行语句，不进入函数"></a>nnext，执行下一行语句，不进入函数</h3><h3 id="sstep，单步进入"><a href="#sstep，单步进入" class="headerlink" title="sstep，单步进入"></a>sstep，单步进入</h3><p>遇到函数的话就会进入函数的内部，再一行一行的执行。执行完当前函数返回到调用它的函数</p><h3 id="ccontinue，继续执行"><a href="#ccontinue，继续执行" class="headerlink" title="ccontinue，继续执行"></a>ccontinue，继续执行</h3><p>程序会在遇到断点后再次暂停运行，如果没有遇到断点就会一直运行到结束</p><p>continue 次数<br>指定次数可以忽略断点，例如，continue 5则5次遇断点不停止，第六次遇到断点才停止执行</p><h3 id="finish跳出当前函数"><a href="#finish跳出当前函数" class="headerlink" title="finish跳出当前函数"></a>finish跳出当前函数</h3><p>运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，可以退出该函数返回到它的调用函数中</p><h3 id="forward-search-reverse-search"><a href="#forward-search-reverse-search" class="headerlink" title="forward-search  |  reverse-search"></a>forward-search  |  reverse-search</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) forward-search     //向前面搜索。 <br>(gdb) reverse-search    //从当前行的开始向后搜索<br></code></pre></td></tr></table></figure><h3 id="watch-发生变化时暂停运行"><a href="#watch-发生变化时暂停运行" class="headerlink" title="watch 发生变化时暂停运行"></a>watch 发生变化时暂停运行</h3><h3 id="awatch-被访问，改变时暂停运行"><a href="#awatch-被访问，改变时暂停运行" class="headerlink" title="awatch&lt;表达式&gt;  被访问，改变时暂停运行"></a>awatch&lt;表达式&gt;  被访问，改变时暂停运行</h3><h3 id="rwatch-被访问时暂停运行"><a href="#rwatch-被访问时暂停运行" class="headerlink" title="rwatch&lt;表达式&gt;  被访问时暂停运行"></a>rwatch&lt;表达式&gt;  被访问时暂停运行</h3><h3 id="info-locals打印出当前函数中所有局部变量以及值"><a href="#info-locals打印出当前函数中所有局部变量以及值" class="headerlink" title="info locals打印出当前函数中所有局部变量以及值"></a>info locals打印出当前函数中所有局部变量以及值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info locals<br>resultvar = 18446744073709551100<br>sc_cancel_oldtype = 0<br>sc_ret = &lt;optimized out&gt;<br></code></pre></td></tr></table></figure><h3 id="ddelete-删除断点和监视点"><a href="#ddelete-删除断点和监视点" class="headerlink" title="ddelete  删除断点和监视点"></a>ddelete  删除断点和监视点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br>4       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br><br>--&gt;删除1号断点<br>(gdb) d 1<br>(gdb) info b<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400450 <span class="hljs-keyword">in</span> main at watch.c:10<br>breakpoint already hit 1 time<br></code></pre></td></tr></table></figure><h3 id="set-variable-设置变量的值"><a href="#set-variable-设置变量的值" class="headerlink" title="set variable &lt;变量&gt; &#x3D; &lt;表达式&gt;设置变量的值"></a>set variable &lt;变量&gt; &#x3D; &lt;表达式&gt;设置变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb)p options<br><span class="hljs-variable">$7</span> =1<br>(gdb)<span class="hljs-built_in">set</span> varaable options = 0<br>(gdb)p options <br><span class="hljs-variable">$8</span> = 0<br></code></pre></td></tr></table></figure><h3 id="disassemble反汇编函数或指定地址范围的代码"><a href="#disassemble反汇编函数或指定地址范围的代码" class="headerlink" title="disassemble反汇编函数或指定地址范围的代码"></a>disassemble反汇编函数或指定地址范围的代码</h3><p>显示对应的汇编指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;address&gt; &lt;+offset&gt;:  &lt;assembly_instruction&gt;  &lt;operands&gt;<br><br>&lt;address&gt;：指令的地址<br>&lt;+offset&gt;：相对于函数或代码块开始处的偏移量<br>&lt;assembly_instruction&gt;：汇编指令的助记符<br>&lt;operands&gt;：汇编指令的操作数<br>在输出中，箭头 =&gt; 表示当前执行的指令<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">disassemble ：默认情况下，会反汇编当前执行点所在的函数或指定地址处的代码。<br>disassemble function_name ：反汇编指定函数的代码。<br>disassemble /m address ：从指定地址开始反汇编代码，/m 选项可用于指定反汇编的长度<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) disassemble <br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> __GI___poll:<br>   0x00007f218fcb1b90 &lt;+0&gt;:     lea    0xc6b59(%rip),%rax        <span class="hljs-comment"># 0x7f218fd786f0 &lt;__libc_multiple_threads&gt;</span><br>   0x00007f218fcb1b97 &lt;+7&gt;:     mov    (%rax),%eax<br>   0x00007f218fcb1b99 &lt;+9&gt;:     <span class="hljs-built_in">test</span>   %eax,%eax<br>   0x00007f218fcb1b9b &lt;+11&gt;:    jne    0x7f218fcb1bb0 &lt;__GI___poll+32&gt;<br>   0x00007f218fcb1b9d &lt;+13&gt;:    mov    <span class="hljs-variable">$0x7</span>,%eax<br>   0x00007f218fcb1ba2 &lt;+18&gt;:    syscall <br>   0x00007f218fcb1ba4 &lt;+20&gt;:    cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br>   0x00007f218fcb1baa &lt;+26&gt;:    ja     0x7f218fcb1c00 &lt;__GI___poll+112&gt;<br>   0x00007f218fcb1bac &lt;+28&gt;:    retq   <br>   0x00007f218fcb1bad &lt;+29&gt;:    nopl   (%rax)<br>   0x00007f218fcb1bb0 &lt;+32&gt;:    push   %r12<br>   0x00007f218fcb1bb2 &lt;+34&gt;:    mov    %edx,%r12d<br>   0x00007f218fcb1bb5 &lt;+37&gt;:    push   %rbp<br>   0x00007f218fcb1bb6 &lt;+38&gt;:    mov    %rsi,%rbp<br>   0x00007f218fcb1bb9 &lt;+41&gt;:    push   %rbx<br>   0x00007f218fcb1bba &lt;+42&gt;:    mov    %rdi,%rbx<br>   0x00007f218fcb1bbd &lt;+45&gt;:    sub    <span class="hljs-variable">$0x10</span>,%rsp<br>   0x00007f218fcb1bc1 &lt;+49&gt;:    callq  0x7f218fcc9a60 &lt;__libc_enable_asynccancel&gt;<br>   0x00007f218fcb1bc6 &lt;+54&gt;:    mov    %r12d,%edx<br>   0x00007f218fcb1bc9 &lt;+57&gt;:    mov    %rbp,%rsi<br>   0x00007f218fcb1bcc &lt;+60&gt;:    mov    %rbx,%rdi<br>   0x00007f218fcb1bcf &lt;+63&gt;:    mov    %eax,%r8d<br>   0x00007f218fcb1bd2 &lt;+66&gt;:    mov    <span class="hljs-variable">$0x7</span>,%eax<br>   0x00007f218fcb1bd7 &lt;+71&gt;:    syscall <br>=&gt; 0x00007f218fcb1bd9 &lt;+73&gt;:    cmp    <span class="hljs-variable">$0xfffffffffffff000</span>,%rax<br>   0x00007f218fcb1bdf &lt;+79&gt;:    ja     0x7f218fcb1c12 &lt;__GI___poll+130&gt;<br>   0x00007f218fcb1be1 &lt;+81&gt;:    mov    %r8d,%edi<br>   0x00007f218fcb1be4 &lt;+84&gt;:    mov    %eax,0xc(%rsp)<br>   0x00007f218fcb1be8 &lt;+88&gt;:    callq  0x7f218fcc9ac0 &lt;__libc_disable_asynccancel&gt;<br>   0x00007f218fcb1bed &lt;+93&gt;:    mov    0xc(%rsp),%eax<br>   0x00007f218fcb1bf1 &lt;+97&gt;:    add    <span class="hljs-variable">$0x10</span>,%rsp<br>   0x00007f218fcb1bf5 &lt;+101&gt;:   pop    %rbx<br>   0x00007f218fcb1bf6 &lt;+102&gt;:   pop    %rbp<br>   0x00007f218fcb1bf7 &lt;+103&gt;:   pop    %r12<br>   0x00007f218fcb1bf9 &lt;+105&gt;:   retq   <br>   0x00007f218fcb1bfa &lt;+106&gt;:   nopw   0x0(%rax,%rax,1)<br>   0x00007f218fcb1c00 &lt;+112&gt;:   mov    0xc1269(%rip),%rdx        <span class="hljs-comment"># 0x7f218fd72e70</span><br>   0x00007f218fcb1c07 &lt;+119&gt;:   neg    %eax<br>   0x00007f218fcb1c09 &lt;+121&gt;:   mov    %eax,%fs:(%rdx)<br>   0x00007f218fcb1c0c &lt;+124&gt;:   mov    <span class="hljs-variable">$0xffffffff</span>,%eax<br>   0x00007f218fcb1c11 &lt;+129&gt;:   retq   <br>   0x00007f218fcb1c12 &lt;+130&gt;:   mov    0xc1257(%rip),%rdx        <span class="hljs-comment"># 0x7f218fd72e70</span><br>   0x00007f218fcb1c19 &lt;+137&gt;:   neg    %eax<br>   0x00007f218fcb1c1b &lt;+139&gt;:   mov    %eax,%fs:(%rdx)<br>   0x00007f218fcb1c1e &lt;+142&gt;:   mov    <span class="hljs-variable">$0xffffffff</span>,%eax<br>   0x00007f218fcb1c23 &lt;+147&gt;:   jmp    0x7f218fcb1be1 &lt;__GI___poll+81&gt;<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h3 id="commands定义在断点中断后执行的命令"><a href="#commands定义在断点中断后执行的命令" class="headerlink" title="commands定义在断点中断后执行的命令"></a>commands定义在断点中断后执行的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">commands 断点编号<br>命令<br>...<br>end<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x00007f218fcb1bd9 ../sysdeps/unix/sysv/linux/poll.c:29<br>(gdb) <span class="hljs-built_in">command</span> 1 <br>Type commands <span class="hljs-keyword">for</span> breakpoint(s) 1, one per line.<br>End with a line saying just <span class="hljs-string">&quot;end&quot;</span>.<br>&gt;p <span class="hljs-variable">$rip</span><br>&gt;end<br></code></pre></td></tr></table></figure><h3 id="llist，显示源代码"><a href="#llist，显示源代码" class="headerlink" title="llist，显示源代码"></a>llist，显示源代码</h3><p>当没有参数时，它会显示当前执行代码的周围区域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">list：显示当前执行点周围的源代码。<br>list function_name：显示特定函数的源代码。<br>list filename:linenum：显示特定文件中特定行号的源代码。<br>list start, end：显示指定范围内的源代码行<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) list<br>24      <span class="hljs-keyword">in</span> ../sysdeps/unix/sysv/linux/poll.c<br></code></pre></td></tr></table></figure><h3 id="display用于设置要在每次程序停止时自动显示的表达式的值，持续监视特定变量或表达式的值"><a href="#display用于设置要在每次程序停止时自动显示的表达式的值，持续监视特定变量或表达式的值" class="headerlink" title="display用于设置要在每次程序停止时自动显示的表达式的值，持续监视特定变量或表达式的值"></a>display用于设置要在每次程序停止时自动显示的表达式的值，持续监视特定变量或表达式的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) display x<br>1: x = 5<br>(gdb) display *ptr<br>2: *ptr = 0x7fff5fbff7f<br>(gdb) display result<br>3: result = 42<br>(gdb) display a &gt; b<br>4: a &gt; b = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>用undisplay取消</p><h3 id="until进行指定位置跳转，执行完区间代码"><a href="#until进行指定位置跳转，执行完区间代码" class="headerlink" title="until进行指定位置跳转，执行完区间代码"></a>until进行指定位置跳转，执行完区间代码</h3>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kdump</title>
    <link href="/debug/kdump/"/>
    <url>/debug/kdump/</url>
    
    <content type="html"><![CDATA[<h1 id="Kdump"><a href="#Kdump" class="headerlink" title="Kdump"></a>Kdump</h1><p>kdump是在系统崩溃、死锁、或者死机的时候用来转储内存为vmcore保存到磁盘的一个工具和服务</p><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">CONFIG_KEXEC=y<br>CONFIG_KEXEC_FILE=y   <br><span class="hljs-comment">//两者选其一，或者都选也可以，对应两个版本的kexec接口</span><br><br>CONFIG_CRASH_DUMP=y   <br><span class="hljs-comment">//内核支持系统崩溃转储功能，即能够生成 vmcore 文件以便进行故障诊断和调试</span><br>CONFIG_PROC_VMCORE=y<br><span class="hljs-comment">//内核支持在 /proc 文件系统中生成 vmcore 文件以供调试和分析系统崩溃时的信息</span><br>CONFIG_RELOCATABLE=y<br><span class="hljs-comment">//内核能够在运行时进行地址重定位，从而使内核能够在不同的物理内存地址上加载和运行</span><br>CONFIG_SYSFS=y<br>CONFIG_DEBUG_INFO=y<br><span class="hljs-comment">//编译过程中会生成额外的调试信息，包括函数符号，代码注释，宏定义等</span><br></code></pre></td></tr></table></figure><h3 id="安装用户态工具包"><a href="#安装用户态工具包" class="headerlink" title="安装用户态工具包"></a>安装用户态工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install kdump-tools<br><span class="hljs-built_in">sudo</span> apt install makedumpfile<br></code></pre></td></tr></table></figure><h3 id="配置预留内存"><a href="#配置预留内存" class="headerlink" title="配置预留内存"></a>配置预留内存</h3><p>配置第一内核启动参数（&#x2F;etc&#x2F;default&#x2F;grub.d&#x2F;kdump-tools.cfg）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;<span class="hljs-variable">$GRUB_CMDLINE_LINUX_DEFAULT</span> crashkernel=512M&quot;</span><br></code></pre></td></tr></table></figure><p>完整的格式可以是：crashkernel&#x3D;1G-:512M@3G，其含义是：</p><ul><li>当内存大于1Ｇ时，预留512Ｍ</li><li>预留位置在3Ｇ</li><li>如果“@offset”部分留空的话，内核会自动寻找合适的位置。（一般都不需要指定）</li><li>在x86虚拟机环境里，直接用crashkernel&#x3D;512M就能正常运行，但某些架构不行，所以推荐用这个格式：crashkernel&#x3D;1G-:512M。</li><li>预留内存大小默认是128Ｍ，一般而言都太小了，建议使用512Ｍ</li></ul><p>注意：</p><ul><li>sw内核的crashkernel代码不完整，没有实现自动寻找的功能，所以不指定offset时会默认为offset&#x3D;0，与第一内核发生冲突而导致系统起不来，此时应该用完整的格式，比如1G-:512M@3G。</li></ul><p>配置完成后需要重启系统生效</p><p>有两种方式可以确认内核是否正确完成了内存预留：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dmesg | grep -i crashkernel<br><br>[0.008200] Reserving 512MB of memory at 1520MB <span class="hljs-keyword">for</span> crashkernel (System RAM: 4095MB)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /proc/iomem<br><br>00100000-7ffdbfff : System RAM<br>01000000-02002287 : Kernel code<br>02200000-02cb1fff : Kernel rodata<br>02e00000-0311473f : Kernel data<br>03449000-039fffff : Kernel bss<br>5f000000-7effffff : Crash kernel<br></code></pre></td></tr></table></figure><h3 id="触发Kdump"><a href="#触发Kdump" class="headerlink" title="触发Kdump"></a>触发Kdump</h3><ul><li>手动触发<ul><li>开启sysrq   <code>sysctl kernel.sysrq=1</code></li><li>触发panic   <code>echo c &gt; /proc/sysrq-trigger</code></li></ul></li><li>oops</li><li>oom</li><li>softlockup&#x2F;hardlockup</li><li>rcu-stall</li></ul>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf</title>
    <link href="/debug/perf/"/>
    <url>/debug/perf/</url>
    
    <content type="html"><![CDATA[<p>tar -xvf perf-5.10.0.tar.gz<br>cd perf-5.10.0<br>cd tools&#x2F;perf&#x2F;<br>make<br>sudo cp perf &#x2F;usr&#x2F;local&#x2F;bin</p><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;perf –version</p><p>download:<br>    <a href="https://cdn.kernel.org/pub/linux/kernel/tools/perf/">https://cdn.kernel.org/pub/linux/kernel/tools/perf/</a></p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>strace</title>
    <link href="/debug/strace/"/>
    <url>/debug/strace/</url>
    
    <content type="html"><![CDATA[<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值</p><ul><li><pre><code class="shell">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.-d 输出strace关于标准错误的调试信息.-f 跟踪由fork调用所产生的子进程.-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.-h 输出简要的帮助信息.-i 输出系统调用的入口指针.-q 禁止输出关于脱离的消息.-r 打印出相对时间关于,,每一个系统调用.-t 在输出中的每一行前加上时间信息.-tt 在输出中的每一行前加上时间信息,微秒级.-ttt 微秒级输出,以秒了表示时间.-T 显示每一调用所耗的时间.-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.-V 输出strace的版本信息.-x 以十六进制形式输出非标准字符串-xx 所有字符串以十六进制形式输出.-a column 设置返回值的输出位置.默认 为40.-e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]...qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\.-e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.-e trace=file 只跟踪有关文件操作的系统调用.-e trace=process 只跟踪有关进程控制的系统调用.-e trace=network 跟踪与网络有关的所有系统调用.-e strace=signal 跟踪所有与系统信号有关的 系统调用-e trace=ipc 跟踪所有与进程通讯有关的系统调用-e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.-e raw=set 将指定的系统调用的参数以十六进制显示.-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5-e write=set 输出写入到指定文件中的数据.-o filename 将strace的输出写入文件filename-p pid 跟踪指定的进程pid.-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.-u username 以username的UID和GID执行被跟踪的命令</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bpftrace</title>
    <link href="/debug/bpftrace/bpftrace/"/>
    <url>/debug/bpftrace/bpftrace/</url>
    
    <content type="html"><![CDATA[<h2 id="bpftrace和trace-bpfcc"><a href="#bpftrace和trace-bpfcc" class="headerlink" title="bpftrace和trace-bpfcc"></a>bpftrace和trace-bpfcc</h2><h3 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h3><ul><li><p>探针</p></li><li><img src="/debug/bpftrace/bpftrace/probe.jpg" class="" title="probe"><p>kprobeb&#x2F;kretprobe为动态跟踪、内核级探针，kprobeb是检测函数执行的开始，kretprobe为检测结束（返回）</p><p>uprobe&#x2F;uretprobe为动态跟踪、用户级探针，uprobeb是检测用户级函数执行的开始，uretprobe为检测结束（返回）。tracepoint为静态跟踪、用户级探针</p></li><li><p>单行命令</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">bpftrace -e &#x27;BEGIN &#123; printf(&quot;Hello world!\n&quot;); &#125;&#x27;<br>bpftrace -e &#x27;kprobe:vfs_read &#123; @[tid] = count();&#125;&#x27;<br>bpftrace -e &#x27;kprobe:vfs_read  /pid == 123/ &#123; @[tid, comm] = count();&#125;&#x27;<br>bpftrace -e &#x27;t:block:block_rq_insert &#123; @[kstack] = count(); &#125;&#x27;<br></code></pre></td></tr></table></figure><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">probes /filter/ &#123; actions &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>probes</code>表示事件 tracepoint、kprobe、kretprobe、uprobe、BEGIN、END</p></li><li><p><code>filter</code>表示过滤条件 当一个事件触发时，会先判断该条件，满足条件才会执行后面的action行为</p></li><li><p><code>action</code>表示具体操作</p></li><li><p><code>bpftrace -e &#39;kprobe:vfs_read  /pid == 123/ &#123; @[tid, comm] = count();&#125;&#39;</code></p></li></ul></li><li><p>变量</p><ul><li><p>内部变量（build-in）</p></li><li><pre><code class="c">uid:用户idtid：线程idpid：进程idcpu：cpu idcgroup：cgroup idprobe：当前的trace点comm：进程名字nsecs：纳秒级别的时间戳kstack：内核栈回溯ustack - 用户栈回溯curtask：当前进程的task_struct地址args:获取该kprobe或者tracepoint的参数列表arg0:获取该kprobe的第一个变量，tracepoint不可用arg1:获取该kprobe的第二个变量，tracepoint不可用arg2:获取该kprobe的第三个变量，tracepoint不可用retval: kretprobe中获取函数返回值args-&gt;ret: kretprobe中获取函数返回值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 使用`-v`选项可以列出tracepoint类型跟踪点的参数<br><br>  ```c<br>  <span class="hljs-meta"># bpftrace -lv tracepoint:syscalls:sys_enter_shmctl</span><br>  tracepoint:syscalls:sys_enter_shmctl<br>      <span class="hljs-type">int</span> __syscall_nr;<br>      <span class="hljs-type">int</span> shmid;<br>      <span class="hljs-type">int</span> cmd;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">shmid_ds</span> * buf;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="trace-bpfcc"><a href="#trace-bpfcc" class="headerlink" title="trace-bpfcc"></a>trace-bpfcc</h3><p><code>trace-bpfcc</code> 是 Linux 上基于 eBPF 的一种跟踪工具，是 BCC（BPF Compiler Collection）工具集的一部分。它用于快速设置和运行 eBPF 程序，以在系统上执行跟踪和监控任务，帮助开发者分析内核和用户空间的行为。</p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install bpfcc-tools<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs shell">uos@uos-PC [~] ➜  trace-bpfcc --help                                                                                           <br><br>usage: trace-bpfcc [-h] [-b BUFFER_PAGES] [-p PID] [-L TID] [-v]<br>                   [-Z STRING_SIZE] [-S] [-M MAX_EVENTS] [-t] [-T] [-C] [-B]<br>                   [-K] [-U] [-a] [-I header]<br>                   probe [probe ...]<br><br>Attach to functions and print trace messages.<br><br>positional arguments:<br>  probe                 probe specifier (see examples)<br><br>optional arguments:<br>  -h, --help            show this help message and exit<br>  -b BUFFER_PAGES, --buffer-pages BUFFER_PAGES<br>                        number of pages to use for perf_events ring buffer<br>                        (default: 64)<br>  -p PID, --pid PID     id of the process to trace (optional)<br>  -L TID, --tid TID     id of the thread to trace (optional)<br>  -v, --verbose         print resulting BPF program code before executing<br>  -Z STRING_SIZE, --string-size STRING_SIZE<br>                        maximum size to read from strings<br>  -S, --include-self    do not filter trace&#x27;s own pid from the trace<br>  -M MAX_EVENTS, --max-events MAX_EVENTS<br>                        number of events to print before quitting<br>  -t, --timestamp       print timestamp column (offset from trace start)<br>  -T, --time            print time column<br>  -C, --print_cpu       print CPU id<br>  -B, --bin_cmp         allow to use STRCMP with binary values<br>  -K, --kernel-stack    output kernel stack trace<br>  -U, --user-stack      output user stack trace<br>  -a, --address         print virtual address in stacks<br>  -I header, --include header<br>                        additional header files to include in the BPF program<br>                        as either full path, or relative to current working<br>                        directory, or relative to default kernel header search<br>                        path<br><br>EXAMPLES:<br><br>trace do_sys_open<br>        Trace the open syscall and print a default trace message when entered<br>trace &#x27;do_sys_open &quot;%s&quot;, arg2&#x27;<br>        Trace the open syscall and print the filename being opened<br>trace &#x27;sys_read (arg3 &gt; 20000) &quot;read %d bytes&quot;, arg3&#x27;<br>        Trace the read syscall and print a message for reads &gt;20000 bytes<br>trace &#x27;r::do_sys_open &quot;%llx&quot;, retval&#x27;<br>        Trace the return from the open syscall and print the return value<br>trace &#x27;c:open (arg2 == 42) &quot;%s %d&quot;, arg1, arg2&#x27;<br>        Trace the open() call from libc only if the flags (arg2) argument is 42<br>trace &#x27;c:malloc &quot;size = %d&quot;, arg1&#x27;<br>        Trace malloc calls and print the size being allocated<br>trace &#x27;p:c:write (arg1 == 1) &quot;writing %d bytes to STDOUT&quot;, arg3&#x27;<br>        Trace the write() call from libc to monitor writes to STDOUT<br>trace &#x27;r::__kmalloc (retval == 0) &quot;kmalloc failed!&quot;&#x27;<br>        Trace returns from __kmalloc which returned a null pointer<br>trace &#x27;r:c:malloc (retval) &quot;allocated = %x&quot;, retval&#x27;<br>        Trace returns from malloc and print non-NULL allocated buffers<br>trace &#x27;t:block:block_rq_complete &quot;sectors=%d&quot;, args-&gt;nr_sector&#x27;<br>        Trace the block_rq_complete kernel tracepoint and print # of tx sectors<br>trace &#x27;u:pthread:pthread_create (arg4 != 0)&#x27;<br>        Trace the USDT probe pthread_create when its 4th argument is non-zero<br>trace &#x27;p::SyS_nanosleep(struct timespec *ts) &quot;sleep for %lld ns&quot;, ts-&gt;tv_nsec&#x27;<br>        Trace the nanosleep syscall and print the sleep duration in ns<br>trace -I &#x27;linux/fs.h&#x27; \<br>      &#x27;p::uprobe_register(struct inode *inode) &quot;a_ops = %llx&quot;, inode-&gt;i_mapping-&gt;a_ops&#x27;<br>        Trace the uprobe_register inode mapping ops, and the symbol can be found<br>        in /proc/kallsyms<br>trace -I &#x27;kernel/sched/sched.h&#x27; \<br>      &#x27;p::__account_cfs_rq_runtime(struct cfs_rq *cfs_rq) &quot;%d&quot;, cfs_rq-&gt;runtime_remaining&#x27;<br>        Trace the cfs scheduling runqueue remaining runtime. The struct cfs_rq is defined<br>        in kernel/sched/sched.h which is in kernel source tree and not in kernel-devel<br>        package.  So this command needs to run at the kernel source tree root directory<br>        so that the added header file can be found by the compiler.<br>trace -I &#x27;net/sock.h&#x27; \<br>      &#x27;udpv6_sendmsg(struct sock *sk) (sk-&gt;sk_dport == 13568)&#x27;<br>        Trace udpv6 sendmsg calls only if socket&#x27;s destination port is equal<br>        to 53 (DNS; 13568 in big endian order)<br>trace -I &#x27;linux/fs_struct.h&#x27; &#x27;mntns_install &quot;users = %d&quot;, $task-&gt;fs-&gt;users&#x27;<br>        Trace the number of users accessing the file system of the current task<br></code></pre></td></tr></table></figure><p>跟踪hw_check_phone_read_access调用栈和库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo trace-bpfcc -UK &quot;hw_check_phone_read_access&quot;<br><br>PID     TID     COMM            FUNC   <br>131567  131636  pool            hw_check_phone_read_access <br>        hw_check_phone_read_access+0x0 [kernel]<br>        usbdev_ioctl+0x1608 [kernel]<br>        __arm64_sys_ioctl+0xa8 [kernel]<br>        el0_svc_common.constprop.4+0x84 [kernel]<br>        do_el0_svc+0x74 [kernel]<br>        el0_svc+0x1c [kernel]<br>        el0_sync_handler+0x88 [kernel]<br>        el0_sync+0x148 [kernel]<br>        __GI___ioctl+0xc [libc-2.28.so]<br>        libusb_submit_transfer+0x2b0 [libusb-1.0.so.0.1.0]<br>        [unknown] [libusb-1.0.so.0.1.0]<br>        gp_libusb1_read+0x50 [usb1.so]<br>        gp_port_read+0x74 [libgphoto2_port.so.12.0.0]<br>        ptp_usb_getpacket.constprop.7+0xc8 [ptp2.so]<br>        ptp_usb_getresp+0x8c [ptp2.so]<br>        ptp_transaction_new+0xd8 [ptp2.so]<br>        ptp_transaction+0x160 [ptp2.so]<br>        ptp_getobjectinfo+0x68 [ptp2.so]<br>        ptp_object_want+0xe0 [ptp2.so]<br>        folder_list_func+0x320 [ptp2.so]<br>        gp_filesystem_list_folders+0x14c [libgphoto2.so.6.1.0]<br>        gp_camera_folder_list_folders+0xbc [libgphoto2.so.6.1.0]<br>        [unknown] [gvfsd-gphoto2]<br>        g_vfs_job_run+0x24 [libgvfsdaemon.so]<br>        [unknown] [libgvfsdaemon.so]<br>        [unknown] [libglib-2.0.so.0.5800.3]<br>        [unknown] [libglib-2.0.so.0.5800.3]<br>        start_thread+0x18c [libpthread-2.28.so]<br>        thread_start+0xc [libc-2.28.so]<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备模型</title>
    <link href="/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-设备模型"><a href="#linux-设备模型" class="headerlink" title="linux 设备模型"></a>linux 设备模型</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><table><thead><tr><th>类型</th><th>内容</th><th>内核数据结构</th><th>对应&#x2F;sys项</th></tr></thead><tbody><tr><td>设备Devices</td><td>设备是此模型中最基本的类型，以设备本身的连接按层次组织</td><td>struct device</td><td>&#x2F;sys&#x2F;devices&#x2F;?&#x2F;?&#x2F;…&#x2F;</td></tr><tr><td>驱动Drivers</td><td>在一个系统中安装多个相同设备，只需要一份驱动程序的支持</td><td>struct device_driver</td><td>&#x2F;sys&#x2F;bus&#x2F;pci&#x2F;drivers&#x2F;?&#x2F;</td></tr><tr><td>总线Bus</td><td>在整个总线级别对此总线上连接的所有设备进行管理</td><td>struct bus_type</td><td>&#x2F;sys&#x2F;bus&#x2F;?&#x2F;</td></tr><tr><td>类Classes</td><td>这是按照功能进行分类组织的设备层次树；如 USB 接口和 PS&#x2F;2 接口的鼠标都是输入设备，都会出现在&#x2F;sys&#x2F;class&#x2F;input&#x2F;下</td><td>struct class</td><td>&#x2F;sys&#x2F;class&#x2F;?&#x2F;</td></tr></tbody></table><h3 id="目录组织结构"><a href="#目录组织结构" class="headerlink" title="目录组织结构"></a>目录组织结构</h3><table><thead><tr><th>&#x2F;sys下的子目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;sys&#x2F;devices</td><td>内核对系统中所有设备的分层次表达模型，也是&#x2F;sys文件系统管理设备的最重要的目录结构</td></tr><tr><td>&#x2F;sys&#x2F;dev</td><td>这个目录下维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(&#x2F;sys&#x2F;devices下)的符号链接文件</td></tr><tr><td>&#x2F;sys&#x2F;bus</td><td>内核设备按总线类型分层放置的目录结构， devices 中的所有设备都是连接于某种总线之下，在这里的每一种具体总线之下可以找到每一个具体设备的符号链接，它也是构成 Linux 统一设备模型的一部分</td></tr><tr><td>&#x2F;sys&#x2F;class</td><td>按照设备功能分类的设备模型，如系统所有输入设备都会出现在&#x2F;sys&#x2F;class&#x2F;input 之下，而不论它们是以何种总线连接到系统。它也是构成 Linux 统一设备模型的一部分</td></tr><tr><td>&#x2F;sys&#x2F;kernel</td><td>内核所有可调整参数的位置，目前只有 uevent_helper, kexec_loaded, mm, 和新式的slab 分配器等几项较新的设计在使用它，其它内核可调整参数仍然位于sysctl(&#x2F;proc&#x2F;sys&#x2F;kernel) 接口中</td></tr><tr><td>&#x2F;sys&#x2F;module</td><td>这里有系统中所有模块的信息，不论这些模块是以内联(inlined)方式编译到内核映像文件(vmlinuz)中还是编译为外部模块(ko文件)，都可能会出现在&#x2F;sys&#x2F;module 中</td></tr><tr><td>&#x2F;sys&#x2F;power</td><td>系统中电源选项，这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机、重启等</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设备驱动</category>
      
      <category>设备模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设备驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/config/shell/"/>
    <url>/config/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p><code>sudo apt install    fzf   ripgrep</code></p><p>~&#x2F;.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ~/.bashrc: executed by bash(1) for non-login shells.</span><br><span class="hljs-comment"># see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)</span><br><span class="hljs-comment"># for examples</span><br><br><span class="hljs-comment"># If not running interactively, don&#x27;t do anything</span><br><span class="hljs-keyword">case</span> $- <span class="hljs-keyword">in</span><br>    *i*) ;;<br>      *) <span class="hljs-built_in">return</span>;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># don&#x27;t put duplicate lines or lines starting with space in the history.</span><br><span class="hljs-comment"># See bash(1) for more options</span><br>HISTCONTROL=ignoreboth<br><br><span class="hljs-comment"># append to the history file, don&#x27;t overwrite it</span><br><span class="hljs-built_in">shopt</span> -s histappend<br><br><span class="hljs-comment"># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span><br>HISTSIZE=1000<br>HISTFILESIZE=2000<br><br><span class="hljs-comment"># check the window size after each command and, if necessary,</span><br><span class="hljs-comment"># update the values of LINES and COLUMNS.</span><br><span class="hljs-built_in">shopt</span> -s checkwinsize<br><br><span class="hljs-comment"># If set, the pattern &quot;**&quot; used in a pathname expansion context will</span><br><span class="hljs-comment"># match all files and zero or more directories and subdirectories.</span><br><span class="hljs-comment">#shopt -s globstar</span><br><br><span class="hljs-comment"># make less more friendly for non-text input files, see lesspipe(1)</span><br><span class="hljs-comment">#[ -x /usr/bin/lesspipe ] &amp;&amp; eval &quot;$(SHELL=/bin/sh lesspipe)&quot;</span><br><br><span class="hljs-comment"># set variable identifying the chroot you work in (used in the prompt below)</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;debian_chroot:-&#125;</span>&quot;</span> ] &amp;&amp; [ -r /etc/debian_chroot ]; <span class="hljs-keyword">then</span><br>    debian_chroot=$(<span class="hljs-built_in">cat</span> /etc/debian_chroot)<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># set a fancy prompt (non-color, unless we know we &quot;want&quot; color)</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> <span class="hljs-keyword">in</span><br>    xterm-color|*-256color) color_prompt=<span class="hljs-built_in">yes</span>;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># uncomment for a colored prompt, if the terminal has the capability; turned</span><br><span class="hljs-comment"># off by default to not distract the user: the focus in a terminal window</span><br><span class="hljs-comment"># should be on the output of commands, not on the prompt</span><br><span class="hljs-comment">#force_color_prompt=yes</span><br><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$force_color_prompt</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; <span class="hljs-keyword">then</span><br>        <span class="hljs-comment"># We have color support; assume it&#x27;s compliant with Ecma-48</span><br>        <span class="hljs-comment"># (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span><br>        <span class="hljs-comment"># a case would tend to support setf rather than setaf.)</span><br>        color_prompt=<span class="hljs-built_in">yes</span><br>    <span class="hljs-keyword">else</span><br>        color_prompt=<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$color_prompt</span>&quot;</span> = <span class="hljs-built_in">yes</span> ]; <span class="hljs-keyword">then</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="hljs-keyword">else</span><br>    PS1=<span class="hljs-string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">unset</span> color_prompt force_color_prompt<br><br><span class="hljs-comment"># If this is an xterm set the title to user@host:dir</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> <span class="hljs-keyword">in</span><br>xterm*|rxvt*)<br>    PS1=<span class="hljs-string">&quot;\[\e]0;<span class="hljs-variable">$&#123;debian_chroot:+($debian_chroot)&#125;</span>\u@\h: \w\a\]<span class="hljs-variable">$PS1</span>&quot;</span><br>    ;;<br>*)<br>    ;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># enable color support of ls and also add handy aliases</span><br><span class="hljs-keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b)</span>&quot;</span><br>    <span class="hljs-built_in">alias</span> <span class="hljs-built_in">ls</span>=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias dir=&#x27;dir --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span><br><br>    <span class="hljs-comment">#alias grep=&#x27;grep --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># colored GCC warnings and errors</span><br><span class="hljs-comment">#export GCC_COLORS=&#x27;error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01&#x27;</span><br><br><span class="hljs-comment"># some more ls aliases</span><br><span class="hljs-comment">#alias ll=&#x27;ls -l&#x27;</span><br><span class="hljs-comment">#alias la=&#x27;ls -A&#x27;</span><br><span class="hljs-comment">#alias l=&#x27;ls -CF&#x27;</span><br><br><span class="hljs-comment"># Alias definitions.</span><br><span class="hljs-comment"># You may want to put all your additions into a separate file like</span><br><span class="hljs-comment"># ~/.bash_aliases, instead of adding them here directly.</span><br><span class="hljs-comment"># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span><br><br><span class="hljs-keyword">if</span> [ -f ~/.bash_aliases ]; <span class="hljs-keyword">then</span><br>    . ~/.bash_aliases<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># enable programmable completion features (you don&#x27;t need to enable</span><br><span class="hljs-comment"># this, if it&#x27;s already enabled in /etc/bash.bashrc and /etc/profile</span><br><span class="hljs-comment"># sources /etc/bash.bashrc).</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">shopt</span> -oq posix; <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="hljs-keyword">then</span><br>    . /usr/share/bash-completion/bash_completion<br>  <span class="hljs-keyword">elif</span> [ -f /etc/bash_completion ]; <span class="hljs-keyword">then</span><br>    . /etc/bash_completion<br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># Set LS_COLORS environment by Deepin</span><br><span class="hljs-keyword">if</span> [[ (<span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = *256color || <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = screen* || <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = xterm* ) &amp;&amp; -f /etc/lscolor-256color ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span> -b /etc/lscolor-256color)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span>)<br><span class="hljs-keyword">fi</span><br><br>[ -f ~/.fzf.bash ] &amp;&amp; <span class="hljs-built_in">source</span> ~/.fzf.bash<br><br><span class="hljs-built_in">export</span> FZF_DEFAULT_COMMAND=<span class="hljs-string">&#x27;rg --files --hidden&#x27;</span><br><span class="hljs-built_in">export</span> FZF_CTRL_T_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$FZF_DEFAULT_COMMAND</span>&quot;</span><br><span class="hljs-comment">#export FZF_DEFAULT_OPTS=&#x27;--preview &quot;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (rougify &#123;&#125;  || highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null&quot; --height 50% --reverse --border&#x27;</span><br><br><span class="hljs-comment">#bind -x &#x27;&quot;\C-f&quot;: &quot;$(fzf)&quot;&#x27;</span><br><span class="hljs-comment"># Custom FZF command to open the selected file</span><br>fzf-<span class="hljs-function"><span class="hljs-title">open</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> file<br>  file=$(fzf --preview <span class="hljs-string">&quot;[[ \$(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (rougify &#123;&#125;  || highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null&quot;</span> --height 50% --reverse --border --select-1 --exit-0) &amp;&amp; vim <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># Bind Ctrl+F to fzf-open</span><br><span class="hljs-built_in">bind</span> -x <span class="hljs-string">&#x27;&quot;\C-f&quot;: &quot;fzf-open&quot;&#x27;</span><br><br></code></pre></td></tr></table></figure><p><code>source ~/.bashrc</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux</title>
    <link href="/config/tmux/"/>
    <url>/config/tmux/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>插件，<code>tmux-continuum</code>  <code>plugins</code>放入~&#x2F;.tmux文件夹</p><p>~&#x2F;.tmux.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置Prefix为Ctrl+x</span><br>set-option -g prefix C-x<br>unbind C-b<br><span class="hljs-built_in">bind</span> C-x send-prefix<br> <br><span class="hljs-comment"># 开始鼠标模式</span><br><span class="hljs-comment">##  tmux v2.1及上 </span><br>set-option -g mouse on<br>set-window-option -g mode-mouse on <span class="hljs-comment"># (setw其实是set-window-option的别名)</span><br>setw -g mouse-resize-pane on <span class="hljs-comment"># 开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线</span><br>setw -g mouse-select-pane on <span class="hljs-comment"># 开启用鼠标点击pane来激活该pane</span><br>setw -g mouse-select-window on <span class="hljs-comment"># 开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）</span><br>setw -g mode-mouse on <span class="hljs-comment"># 开启window/pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</span><br><br><span class="hljs-built_in">set</span> -g history-limit 100000<br><br><br><span class="hljs-comment"># 开启复制模式</span><br>setw -g mode-keys vi<br>set-window-option -g mode-keys vi<br> <br><span class="hljs-comment"># 使用快捷键r重新读取配置文件</span><br><span class="hljs-built_in">bind</span> r source-file ~/.tmux.conf\; display <span class="hljs-string">&quot;Reloaded!&quot;</span><br> <br><span class="hljs-comment"># 设置Window和Pane开始编号为1</span><br>set-option -g base-index 1<br>set-window-option -g pane-base-index 1<br> <br>bind-key k select-pane -U <span class="hljs-comment"># up</span><br>bind-key j select-pane -D <span class="hljs-comment"># down </span><br>bind-key h select-pane -L <span class="hljs-comment"># left</span><br>bind-key l select-pane -R <span class="hljs-comment"># right</span><br><br><span class="hljs-comment"># 设置Ctrl+j为横向分屏</span><br>bind-key -n C-j split-window -h<br><br><span class="hljs-comment"># 设置Ctrl+h为竖向分屏</span><br>bind-key -n C-h split-window -v<br><br><span class="hljs-comment"># List of plugins</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tpm&#x27;</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-sensible&#x27;</span><br><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;dracula/tmux&#x27;</span><br><span class="hljs-built_in">set</span> -g @dracula-plugins <span class="hljs-string">&quot;ssh-session cpu-usage ram-usage time&quot;</span>  <span class="hljs-comment">#状态栏显示的内容</span><br><span class="hljs-built_in">set</span> -g @dracula-show-flags <span class="hljs-literal">true</span> <br><span class="hljs-built_in">set</span> -g @dracula-show-left-icon session  <span class="hljs-comment"># 最左侧的图标显示当前tmux session名称</span><br><span class="hljs-built_in">set</span> -g @dracula-show-powerline <span class="hljs-literal">true</span> <span class="hljs-comment"># 显示powerline,更美观</span><br><span class="hljs-built_in">set</span> -g @dracula-time-format <span class="hljs-string">&quot;%F %R&quot;</span> <span class="hljs-comment"># 时间格式 </span><br><br>run <span class="hljs-string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br>run-shell ~/.tmux/tmux-continuum/continuum.tmux<br></code></pre></td></tr></table></figure><p><code>tmux source-file ~/.tmux.conf</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/config/vim/"/>
    <url>/config/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h3 id="安装Vim插件管理器-VimPlug"><a href="#安装Vim插件管理器-VimPlug" class="headerlink" title="安装Vim插件管理器 VimPlug"></a><strong>安装Vim插件管理器 VimPlug</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br></code></pre></td></tr></table></figure><h3 id="配置-vimrc"><a href="#配置-vimrc" class="headerlink" title="配置 ~&#x2F;.vimrc"></a><strong>配置 ~&#x2F;.vimrc</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">call plug#begin()<br><br>Plug <span class="hljs-string">&#x27;scrooloose/nerdtree&#x27;</span><br>noremap &lt;leader&gt;t :NERDTreeToggle&lt;CR&gt;<br>autocmd VimEnter * wincmd p<br>autocmd BufEnter * <span class="hljs-keyword">if</span> 0 == len(filter(range(1, winnr(<span class="hljs-string">&#x27;$&#x27;</span>)), <span class="hljs-string">&#x27;empty(getbufvar(winbufnr(v:val), &quot;&amp;bt&quot;))&#x27;</span>)) | qa! | endif<br><span class="hljs-built_in">let</span> NERDTreeWinSize=25<br><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;do&#x27;</span>: &#123; -&gt; fzf#install() &#125; &#125;<br>Plug <span class="hljs-string">&#x27;junegunn/fzf.vim&#x27;</span><br>nnoremap &lt;c-p&gt; :Files&lt;CR&gt;<br>nnoremap &lt;c-g&gt; :Ag&lt;CR&gt;<br><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;~/.fzf&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>: <span class="hljs-string">&#x27;./install --all&#x27;</span> &#125;<br>Plug <span class="hljs-string">&#x27;tracyone/fzf-funky&#x27;</span>,&#123;<span class="hljs-string">&#x27;on&#x27;</span>: <span class="hljs-string">&#x27;FzfFunky&#x27;</span>&#125;<br>nnoremap &lt;Leader&gt;f :FzfFunky&lt;CR&gt;<br><br>Plug <span class="hljs-string">&#x27;majutsushi/tagbar&#x27;</span><br>nmap &lt;Leader&gt;b :TagbarToggle&lt;CR&gt;<br><span class="hljs-built_in">let</span> g:tagbar_width=30<br>autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()<br><br>call plug#end()<br><br><span class="hljs-built_in">set</span> mouse=a<br><span class="hljs-built_in">set</span> backspace=indent,eol,start<br><span class="hljs-built_in">set</span> cursorline<br><span class="hljs-built_in">set</span> autoindent    <span class="hljs-string">&quot; 在输入文本时自动缩进</span><br><span class="hljs-string">set smartindent   &quot;</span> 根据上一行的缩进进行智能缩进<br><span class="hljs-built_in">set</span> hlsearch                                                                                                                   <span class="hljs-built_in">set</span> number <br></code></pre></td></tr></table></figure><h3 id="把插件放到-vim文件夹中"><a href="#把插件放到-vim文件夹中" class="headerlink" title="把插件放到~&#x2F;.vim文件夹中"></a>把插件放到~&#x2F;.vim文件夹中</h3><p>autoload 和 plugged</p><p>执行<code>source ~/.vimrc</code></p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctags</title>
    <link href="/commands/ctags/"/>
    <url>/commands/ctags/</url>
    
    <content type="html"><![CDATA[<h1 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h1><p><strong>生成索引文件  <code>ctags –R .</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Ctrl + ]     跳到光标所在变量的定义处<br>Ctrl + t     返回查找或跳转，从哪里跳过来的跳回哪里，即使用了很多次 Ctrl+]，该命令也会回到最初一次的位置<br>vi –t tag   找到名为 tag 的变量的定义处<br>g + ]          列出变量的所有引用供用户选择<br>:ts         tagslist  同 g + ]<br>:tp         tagspreview 上一个tag标记文件<br>:tn         tagsnext  下一个tag标记文件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/commands/vim_command/"/>
    <url>/commands/vim_command/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p><strong>vim打开文件：</strong></p><table><thead><tr><th>Vi 使用的选项</th><th>说明</th></tr></thead><tbody><tr><td>vim  filename</td><td>打开或新建一个文件，并将光标置于第一行的首部</td></tr><tr><td>vim   -r  filename</td><td>恢复上次 vim 打开时崩溃的文件</td></tr><tr><td>vim  -R  filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>vim  +  filename</td><td>打开文件，并将光标置于最后一行的首部</td></tr><tr><td>vim  +n  filename</td><td>打开文件，并将光标置于第 n 行的首部</td></tr><tr><td>vim  +&#x2F;pattern  filename</td><td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td></tr><tr><td>vim  -c command  filename</td><td>在对文件进行编辑前，先执行指定的命令</td></tr></tbody></table><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>gg</th><th>移动到首行</th></tr></thead><tbody><tr><td>G</td><td>移动到尾行</td></tr><tr><td>^或_</td><td>移动到行首第一个非空字符</td></tr><tr><td>g_</td><td>移动到行尾最后一个非空字符</td></tr><tr><td>end或者g</td><td>动到行尾最后一个字符</td></tr><tr><td>b&#x2F;B</td><td>光标向前移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>w&#x2F;W</td><td>光标向后移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>e&#x2F;E</td><td>移到单词结尾（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>数字+G</td><td>快速将光标移动到指定行</td></tr><tr><td>H</td><td>移动到屏幕顶部</td></tr><tr><td>M</td><td>移动到屏幕中间</td></tr><tr><td>L</td><td>移动到屏幕尾部</td></tr><tr><td>z+Enter</td><td>当前行在屏幕顶部</td></tr><tr><td>)</td><td>向前移动一个句子</td></tr><tr><td>(</td><td>向后移动一个句子</td></tr><tr><td>}</td><td>向前移动一个段落</td></tr><tr><td>{</td><td>向前移动一个段落</td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th>x</th><th>删除光标所在位置的字符</th></tr></thead><tbody><tr><td>X</td><td>删除光标前一个字符</td></tr><tr><td>dd</td><td>删除光标所在行，删除之后，下一行上移</td></tr><tr><td>D</td><td>删除光标位置到行尾的内容，删除之后，下一行不上移</td></tr></tbody></table><h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><table><thead><tr><th>~</th><th>转换大小写</th></tr></thead><tbody><tr><td>u</td><td>变成小写</td></tr><tr><td>U</td><td>变成大写</td></tr></tbody></table><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><table><thead><tr><th>r</th><th>替换光标所在位置的字符</th></tr></thead><tbody><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td>:s&#x2F;a1&#x2F;a2</td><td>替换当前光标所在行第一处符合条件的内容</td></tr><tr><td>:s&#x2F;a1&#x2F;a2&#x2F;g</td><td>替换当前光标所在行所有的 a1 都用 a2 替换</td></tr><tr><td>:%s&#x2F;a1&#x2F;a2</td><td>替换所有行中，第一处符合条件的内容</td></tr><tr><td>:%s&#x2F;a1&#x2F;a2&#x2F;g</td><td>替换所有行中，所有符合条件的内容</td></tr><tr><td>:n1,n2 s&#x2F;a1&#x2F;a2</td><td>将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换</td></tr><tr><td>:n1,n2 s&#x2F;a1&#x2F;a2&#x2F;g</td><td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td></tr></tbody></table><h3 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a><strong>文件切换</strong></h3><table><thead><tr><th>:files</th><th>查看当前已经打开的所有文件(%a表示激活状态，#表示上一个打开的文件)</th></tr></thead><tbody><tr><td>:open 文件名</td><td>切换到指定文件</td></tr><tr><td>:bp</td><td>切换到上一个文件</td></tr><tr><td>:bn</td><td>切换到下一个文件</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
